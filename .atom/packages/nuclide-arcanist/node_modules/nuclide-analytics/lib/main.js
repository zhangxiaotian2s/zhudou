var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _nuclideCommons = require('nuclide-commons');

var _AnalyticsBatcher = require('./AnalyticsBatcher');

var _track = require('./track');

'use babel';

var ANALYTICS_BATCHER = 'analytics-batcher';

function getBatcher() {
  return _nuclideCommons.singleton.get(ANALYTICS_BATCHER, function () {
    (0, _assert2['default'])(_track.track);
    return new _AnalyticsBatcher.AnalyticsBatcher(_track.track);
  });
}

function resetBatcher() {
  getBatcher().dispose();
  return _nuclideCommons.singleton.clear(ANALYTICS_BATCHER);
}

var batching = false;

function setBatching(newBatching) {
  if (batching !== newBatching) {
    batching = newBatching;
    if (!batching) {
      resetBatcher();
    }
  }
}

function track(eventName, values) {
  (0, _assert2['default'])(_track.track);
  if (!batching) {
    return (0, _track.track)(eventName, values || {});
  } else {
    getBatcher().track(eventName, values || {});
    return Promise.resolve();
  }
}

/**
 * A decorator factory (https://github.com/wycats/javascript-decorators) who measures the execution
 * time of an asynchronous/synchronous function which belongs to either a Class or an Object.
 * Usage:
 *
 * ```
 * Class Test{
 *   @trackTiming()
 *   foo(...) {...}
 *
 *   @trackTiming()
 *   bar(...): Promise {...}
 * }
 *
 * const obj = {
 *   @trackTiming('fooEvent')
 *   foo(...) {...}
 * }
 * ```
 *
 * @param eventName Name of the event to be tracked. It's optional and default value is
 *    `$className.$methodName` for Class method or `Object.$methodName` for Object method.
 * @returns A decorator.
 */
function trackTiming() {
  var eventName = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

  return function (target, name, descriptor) {
    var originalMethod = descriptor.value;

    // We can't use arrow function here as it will bind `this` to the context of enclosing function
    // which is trackTiming, whereas what needed is context of originalMethod.
    descriptor.value = function () {
      var _this = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (!eventName) {
        var constructorName = this.constructor ? this.constructor.name : undefined;
        eventName = constructorName + '.' + name;
      }

      return trackOperationTiming(eventName,
      // Must use arrow here to get correct 'this'
      function () {
        return originalMethod.apply(_this, args);
      });
    };
  };
}

/**
 * Obtain a monotonically increasing timestamp in milliseconds, if possible.
 * If `window.performance` is unavailable (e.g. in Node), use process.hrtime.
 * Fall back to `Date.now` otherwise â€“ note that `Date.now` does not guarantee timestamps to
 * increase monotonically, and is thus subject to system clock updates.
 *
 * Wrapped in a function rather than a module constant to facilitate testing.
 */
var getTimestamp = function getTimestamp() {
  var timingFunction = global.performance != null ? function () {
    return Math.round(global.performance.now());
  } : process != null && typeof process.hrtime === 'function' ? function () {
    var hr = process.hrtime();
    return Math.round((hr[0] * 1e9 + hr[1]) / 1e6);
  } : Date.now;
  return timingFunction();
};

var PERFORMANCE_EVENT = 'performance';

var TimingTracker = (function () {
  function TimingTracker(eventName) {
    _classCallCheck(this, TimingTracker);

    this._eventName = eventName;
    this._startTime = getTimestamp();
  }

  _createClass(TimingTracker, [{
    key: 'onError',
    value: function onError(error) {
      return this._trackTimingEvent(error);
    }
  }, {
    key: 'onSuccess',
    value: function onSuccess() {
      return this._trackTimingEvent( /* error */null);
    }
  }, {
    key: '_trackTimingEvent',
    value: function _trackTimingEvent(exception) {
      return track(PERFORMANCE_EVENT, {
        duration: (getTimestamp() - this._startTime).toString(),
        eventName: this._eventName,
        error: exception ? '1' : '0',
        exception: exception ? exception.toString() : ''
      });
    }
  }]);

  return TimingTracker;
})();

function startTracking(eventName) {
  return new TimingTracker(eventName);
}

/**
 * Reports analytics including timing for a single operation.
 *
 * Usage:
 *
 * analytics.trackOperationTiming('my-package-some-long-operation' () => doit());
 *
 * Returns (or throws) the result of the operation.
 */
function trackOperationTiming(eventName, operation) {

  var tracker = startTracking(eventName);

  try {
    var result = operation();

    if (require('nuclide-commons').promises.isPromise(result)) {
      // Atom uses a different Promise implementation than Nuclide, so the following is not true:
      // invariant(result instanceof Promise);

      // For the method returning a Promise, track the time after the promise is resolved/rejected.
      return result.then(function (value) {
        tracker.onSuccess();
        return value;
      }, function (reason) {
        tracker.onError(reason instanceof Error ? reason : new Error(reason));
        return Promise.reject(reason);
      });
    } else {
      tracker.onSuccess();
      return result;
    }
  } catch (error) {
    tracker.onError(error);
    throw error;
  }
}

module.exports = {
  track: track,
  trackOperationTiming: trackOperationTiming,
  startTracking: startTracking,
  TimingTracker: TimingTracker,
  trackTiming: trackTiming,
  setBatching: setBatching
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWFuYWx5dGljcy9saWIvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztzQkFXc0IsUUFBUTs7Ozs4QkFDTixpQkFBaUI7O2dDQUNWLG9CQUFvQjs7cUJBQ25CLFNBQVM7O0FBZHpDLFdBQVcsQ0FBQzs7QUFnQlosSUFBTSxpQkFBaUIsR0FBRyxtQkFBbUIsQ0FBQzs7QUFFOUMsU0FBUyxVQUFVLEdBQXFCO0FBQ3RDLFNBQU8sZ0JBUEQsU0FBUyxDQU9FLEdBQUcsQ0FDbEIsaUJBQWlCLEVBQUUsWUFBTTtBQUN2QixvQ0FQRSxLQUFLLENBT1ksQ0FBQztBQUNwQixXQUFPLHNCQVRMLGdCQUFnQixRQUNoQixLQUFLLENBUThCLENBQUM7R0FDdkMsQ0FBQyxDQUFDO0NBQ047O0FBRUQsU0FBUyxZQUFZLEdBQVM7QUFDNUIsWUFBVSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDdkIsU0FBTyxnQkFoQkQsU0FBUyxDQWdCRSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztDQUMzQzs7QUFFRCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7O0FBRXJCLFNBQVMsV0FBVyxDQUFDLFdBQW9CLEVBQVE7QUFDL0MsTUFBSSxRQUFRLEtBQUssV0FBVyxFQUFFO0FBQzVCLFlBQVEsR0FBRyxXQUFXLENBQUM7QUFDdkIsUUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNiLGtCQUFZLEVBQUUsQ0FBQztLQUNoQjtHQUNGO0NBQ0Y7O0FBRUQsU0FBUyxLQUFLLENBQUMsU0FBaUIsRUFBRSxNQUFnQyxFQUFrQjtBQUNsRixrQ0E3Qk0sS0FBSyxDQTZCUSxDQUFDO0FBQ3BCLE1BQUksQ0FBQyxRQUFRLEVBQUU7QUFDYixXQUFPLFdBL0JILEtBQUssRUErQk8sU0FBUyxFQUFFLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQztHQUMxQyxNQUFNO0FBQ0wsY0FBVSxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxNQUFNLElBQUksRUFBRSxDQUFDLENBQUM7QUFDNUMsV0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7R0FDMUI7Q0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkQsU0FBUyxXQUFXLEdBQWlDO01BQWhDLFNBQWtCLHlEQUFHLElBQUk7O0FBRTVDLFNBQU8sVUFBQyxNQUFNLEVBQU8sSUFBSSxFQUFVLFVBQVUsRUFBVTtBQUNyRCxRQUFNLGNBQWMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDOzs7O0FBSXhDLGNBQVUsQ0FBQyxLQUFLLEdBQUcsWUFBa0I7Ozt3Q0FBTixJQUFJO0FBQUosWUFBSTs7O0FBQ2pDLFVBQUksQ0FBQyxTQUFTLEVBQUU7QUFDZCxZQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQztBQUM3RSxpQkFBUyxHQUFNLGVBQWUsU0FBSSxJQUFJLEFBQUUsQ0FBQztPQUMxQzs7QUFFRCxhQUFPLG9CQUFvQixDQUFDLFNBQVM7O0FBRW5DO2VBQU0sY0FBYyxDQUFDLEtBQUssUUFBTyxJQUFJLENBQUM7T0FBQSxDQUFDLENBQUM7S0FDM0MsQ0FBQztHQUNILENBQUM7Q0FDSDs7Ozs7Ozs7OztBQVVELElBQU0sWUFBWSxHQUFHLFNBQWYsWUFBWSxHQUFpQjtBQUNqQyxNQUFNLGNBQWMsR0FBRyxBQUFDLE1BQU0sQ0FBQyxXQUFXLElBQUksSUFBSSxHQUM5QztXQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztHQUFBLEdBQzFDLEFBQUMsT0FBTyxJQUFJLElBQUksSUFBSSxPQUFPLE9BQU8sQ0FBQyxNQUFNLEtBQUssVUFBVSxHQUN0RCxZQUFNO0FBQ04sUUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQzVCLFdBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLEdBQUksR0FBRyxDQUFDLENBQUM7R0FDaEQsR0FDQyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ2YsU0FBTyxjQUFjLEVBQUUsQ0FBQztDQUN6QixDQUFDOztBQUVGLElBQU0saUJBQWlCLEdBQUcsYUFBYSxDQUFDOztJQUVsQyxhQUFhO0FBSU4sV0FKUCxhQUFhLENBSUwsU0FBaUIsRUFBRTswQkFKM0IsYUFBYTs7QUFLZixRQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztBQUM1QixRQUFJLENBQUMsVUFBVSxHQUFHLFlBQVksRUFBRSxDQUFDO0dBQ2xDOztlQVBHLGFBQWE7O1dBU1YsaUJBQUMsS0FBWSxFQUFXO0FBQzdCLGFBQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3RDOzs7V0FFUSxxQkFBWTtBQUNuQixhQUFPLElBQUksQ0FBQyxpQkFBaUIsYUFBYSxJQUFJLENBQUMsQ0FBQztLQUNqRDs7O1dBRWdCLDJCQUFDLFNBQWlCLEVBQVc7QUFDNUMsYUFBTyxLQUFLLENBQUMsaUJBQWlCLEVBQUU7QUFDOUIsZ0JBQVEsRUFBRSxDQUFDLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUEsQ0FBRSxRQUFRLEVBQUU7QUFDdkQsaUJBQVMsRUFBRSxJQUFJLENBQUMsVUFBVTtBQUMxQixhQUFLLEVBQUUsU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQzVCLGlCQUFTLEVBQUUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO09BQ2pELENBQUMsQ0FBQztLQUNKOzs7U0F4QkcsYUFBYTs7O0FBMkJuQixTQUFTLGFBQWEsQ0FBQyxTQUFpQixFQUFpQjtBQUN2RCxTQUFPLElBQUksYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQ3JDOzs7Ozs7Ozs7OztBQVdELFNBQVMsb0JBQW9CLENBQUksU0FBaUIsRUFBRSxTQUFrQixFQUFLOztBQUV6RSxNQUFNLE9BQU8sR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7O0FBRXpDLE1BQUk7QUFDRixRQUFNLE1BQU0sR0FBRyxTQUFTLEVBQUUsQ0FBQzs7QUFFM0IsUUFBSSxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFOzs7OztBQUt6RCxhQUFPLEFBQUMsTUFBTSxDQUFPLElBQUksQ0FBQyxVQUFDLEtBQUssRUFBSztBQUNuQyxlQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDcEIsZUFBTyxLQUFLLENBQUM7T0FDZCxFQUFFLFVBQUMsTUFBTSxFQUFLO0FBQ2IsZUFBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLFlBQVksS0FBSyxHQUFHLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3RFLGVBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUMvQixDQUFDLENBQUM7S0FDSixNQUFNO0FBQ0wsYUFBTyxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ3BCLGFBQU8sTUFBTSxDQUFDO0tBQ2Y7R0FDRixDQUFDLE9BQU8sS0FBSyxFQUFFO0FBQ2QsV0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2QixVQUFNLEtBQUssQ0FBQztHQUNiO0NBQ0Y7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNmLE9BQUssRUFBTCxLQUFLO0FBQ0wsc0JBQW9CLEVBQXBCLG9CQUFvQjtBQUNwQixlQUFhLEVBQWIsYUFBYTtBQUNiLGVBQWEsRUFBYixhQUFhO0FBQ2IsYUFBVyxFQUFYLFdBQVc7QUFDWCxhQUFXLEVBQVgsV0FBVztDQUNaLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtYW5hbHl0aWNzL2xpYi9tYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtzaW5nbGV0b259IGZyb20gJ251Y2xpZGUtY29tbW9ucyc7XG5pbXBvcnQge0FuYWx5dGljc0JhdGNoZXJ9IGZyb20gJy4vQW5hbHl0aWNzQmF0Y2hlcic7XG5pbXBvcnQge3RyYWNrIGFzIHJhd1RyYWNrfSBmcm9tICcuL3RyYWNrJztcblxuY29uc3QgQU5BTFlUSUNTX0JBVENIRVIgPSAnYW5hbHl0aWNzLWJhdGNoZXInO1xuXG5mdW5jdGlvbiBnZXRCYXRjaGVyKCk6IEFuYWx5dGljc0JhdGNoZXIge1xuICByZXR1cm4gc2luZ2xldG9uLmdldChcbiAgICBBTkFMWVRJQ1NfQkFUQ0hFUiwgKCkgPT4ge1xuICAgICAgaW52YXJpYW50KHJhd1RyYWNrKTtcbiAgICAgIHJldHVybiBuZXcgQW5hbHl0aWNzQmF0Y2hlcihyYXdUcmFjayk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlcigpOiB2b2lkIHtcbiAgZ2V0QmF0Y2hlcigpLmRpc3Bvc2UoKTtcbiAgcmV0dXJuIHNpbmdsZXRvbi5jbGVhcihBTkFMWVRJQ1NfQkFUQ0hFUik7XG59XG5cbmxldCBiYXRjaGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRCYXRjaGluZyhuZXdCYXRjaGluZzogYm9vbGVhbik6IHZvaWQge1xuICBpZiAoYmF0Y2hpbmcgIT09IG5ld0JhdGNoaW5nKSB7XG4gICAgYmF0Y2hpbmcgPSBuZXdCYXRjaGluZztcbiAgICBpZiAoIWJhdGNoaW5nKSB7XG4gICAgICByZXNldEJhdGNoZXIoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhY2soZXZlbnROYW1lOiBzdHJpbmcsIHZhbHVlcz86IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9KTogUHJvbWlzZTxtaXhlZD4ge1xuICBpbnZhcmlhbnQocmF3VHJhY2spO1xuICBpZiAoIWJhdGNoaW5nKSB7XG4gICAgcmV0dXJuIHJhd1RyYWNrKGV2ZW50TmFtZSwgdmFsdWVzIHx8IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBnZXRCYXRjaGVyKCkudHJhY2soZXZlbnROYW1lLCB2YWx1ZXMgfHwge30pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZGVjb3JhdG9yIGZhY3RvcnkgKGh0dHBzOi8vZ2l0aHViLmNvbS93eWNhdHMvamF2YXNjcmlwdC1kZWNvcmF0b3JzKSB3aG8gbWVhc3VyZXMgdGhlIGV4ZWN1dGlvblxuICogdGltZSBvZiBhbiBhc3luY2hyb25vdXMvc3luY2hyb25vdXMgZnVuY3Rpb24gd2hpY2ggYmVsb25ncyB0byBlaXRoZXIgYSBDbGFzcyBvciBhbiBPYmplY3QuXG4gKiBVc2FnZTpcbiAqXG4gKiBgYGBcbiAqIENsYXNzIFRlc3R7XG4gKiAgIEB0cmFja1RpbWluZygpXG4gKiAgIGZvbyguLi4pIHsuLi59XG4gKlxuICogICBAdHJhY2tUaW1pbmcoKVxuICogICBiYXIoLi4uKTogUHJvbWlzZSB7Li4ufVxuICogfVxuICpcbiAqIGNvbnN0IG9iaiA9IHtcbiAqICAgQHRyYWNrVGltaW5nKCdmb29FdmVudCcpXG4gKiAgIGZvbyguLi4pIHsuLi59XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIHRyYWNrZWQuIEl0J3Mgb3B0aW9uYWwgYW5kIGRlZmF1bHQgdmFsdWUgaXNcbiAqICAgIGAkY2xhc3NOYW1lLiRtZXRob2ROYW1lYCBmb3IgQ2xhc3MgbWV0aG9kIG9yIGBPYmplY3QuJG1ldGhvZE5hbWVgIGZvciBPYmplY3QgbWV0aG9kLlxuICogQHJldHVybnMgQSBkZWNvcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIHRyYWNrVGltaW5nKGV2ZW50TmFtZTogP3N0cmluZyA9IG51bGwpOiBhbnkge1xuXG4gIHJldHVybiAodGFyZ2V0OiBhbnksIG5hbWU6IHN0cmluZywgZGVzY3JpcHRvcjogYW55KSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gICAgLy8gV2UgY2FuJ3QgdXNlIGFycm93IGZ1bmN0aW9uIGhlcmUgYXMgaXQgd2lsbCBiaW5kIGB0aGlzYCB0byB0aGUgY29udGV4dCBvZiBlbmNsb3NpbmcgZnVuY3Rpb25cbiAgICAvLyB3aGljaCBpcyB0cmFja1RpbWluZywgd2hlcmVhcyB3aGF0IG5lZWRlZCBpcyBjb250ZXh0IG9mIG9yaWdpbmFsTWV0aG9kLlxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yID8gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIDogdW5kZWZpbmVkO1xuICAgICAgICBldmVudE5hbWUgPSBgJHtjb25zdHJ1Y3Rvck5hbWV9LiR7bmFtZX1gO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhY2tPcGVyYXRpb25UaW1pbmcoZXZlbnROYW1lLFxuICAgICAgICAvLyBNdXN0IHVzZSBhcnJvdyBoZXJlIHRvIGdldCBjb3JyZWN0ICd0aGlzJ1xuICAgICAgICAoKSA9PiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBPYnRhaW4gYSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcywgaWYgcG9zc2libGUuXG4gKiBJZiBgd2luZG93LnBlcmZvcm1hbmNlYCBpcyB1bmF2YWlsYWJsZSAoZS5nLiBpbiBOb2RlKSwgdXNlIHByb2Nlc3MuaHJ0aW1lLlxuICogRmFsbCBiYWNrIHRvIGBEYXRlLm5vd2Agb3RoZXJ3aXNlIOKAkyBub3RlIHRoYXQgYERhdGUubm93YCBkb2VzIG5vdCBndWFyYW50ZWUgdGltZXN0YW1wcyB0b1xuICogaW5jcmVhc2UgbW9ub3RvbmljYWxseSwgYW5kIGlzIHRodXMgc3ViamVjdCB0byBzeXN0ZW0gY2xvY2sgdXBkYXRlcy5cbiAqXG4gKiBXcmFwcGVkIGluIGEgZnVuY3Rpb24gcmF0aGVyIHRoYW4gYSBtb2R1bGUgY29uc3RhbnQgdG8gZmFjaWxpdGF0ZSB0ZXN0aW5nLlxuICovXG5jb25zdCBnZXRUaW1lc3RhbXAgPSAoKTogbnVtYmVyID0+IHtcbiAgY29uc3QgdGltaW5nRnVuY3Rpb24gPSAoZ2xvYmFsLnBlcmZvcm1hbmNlICE9IG51bGwpXG4gICAgPyAoKSA9PiBNYXRoLnJvdW5kKGdsb2JhbC5wZXJmb3JtYW5jZS5ub3coKSlcbiAgICA6IChwcm9jZXNzICE9IG51bGwgJiYgdHlwZW9mIHByb2Nlc3MuaHJ0aW1lID09PSAnZnVuY3Rpb24nKVxuICAgICAgPyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhyID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGhyWzBdICogMWU5ICsgaHJbMV0pIC8gMWU2KTtcbiAgICAgIH1cbiAgICAgIDogRGF0ZS5ub3c7XG4gIHJldHVybiB0aW1pbmdGdW5jdGlvbigpO1xufTtcblxuY29uc3QgUEVSRk9STUFOQ0VfRVZFTlQgPSAncGVyZm9ybWFuY2UnO1xuXG5jbGFzcyBUaW1pbmdUcmFja2VyIHtcbiAgX2V2ZW50TmFtZTogc3RyaW5nO1xuICBfc3RhcnRUaW1lOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZXZlbnROYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gZ2V0VGltZXN0YW1wKCk7XG4gIH1cblxuICBvbkVycm9yKGVycm9yOiBFcnJvcik6IFByb21pc2Uge1xuICAgIHJldHVybiB0aGlzLl90cmFja1RpbWluZ0V2ZW50KGVycm9yKTtcbiAgfVxuXG4gIG9uU3VjY2VzcygpOiBQcm9taXNlIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tUaW1pbmdFdmVudCgvKiBlcnJvciAqLyBudWxsKTtcbiAgfVxuXG4gIF90cmFja1RpbWluZ0V2ZW50KGV4Y2VwdGlvbjogP0Vycm9yKTogUHJvbWlzZSB7XG4gICAgcmV0dXJuIHRyYWNrKFBFUkZPUk1BTkNFX0VWRU5ULCB7XG4gICAgICBkdXJhdGlvbjogKGdldFRpbWVzdGFtcCgpIC0gdGhpcy5fc3RhcnRUaW1lKS50b1N0cmluZygpLFxuICAgICAgZXZlbnROYW1lOiB0aGlzLl9ldmVudE5hbWUsXG4gICAgICBlcnJvcjogZXhjZXB0aW9uID8gJzEnIDogJzAnLFxuICAgICAgZXhjZXB0aW9uOiBleGNlcHRpb24gPyBleGNlcHRpb24udG9TdHJpbmcoKSA6ICcnLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhY2tpbmcoZXZlbnROYW1lOiBzdHJpbmcpOiBUaW1pbmdUcmFja2VyIHtcbiAgcmV0dXJuIG5ldyBUaW1pbmdUcmFja2VyKGV2ZW50TmFtZSk7XG59XG5cbi8qKlxuICogUmVwb3J0cyBhbmFseXRpY3MgaW5jbHVkaW5nIHRpbWluZyBmb3IgYSBzaW5nbGUgb3BlcmF0aW9uLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqIGFuYWx5dGljcy50cmFja09wZXJhdGlvblRpbWluZygnbXktcGFja2FnZS1zb21lLWxvbmctb3BlcmF0aW9uJyAoKSA9PiBkb2l0KCkpO1xuICpcbiAqIFJldHVybnMgKG9yIHRocm93cykgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiB0cmFja09wZXJhdGlvblRpbWluZzxUPihldmVudE5hbWU6IHN0cmluZywgb3BlcmF0aW9uOiAoKSA9PiBUKTogVCB7XG5cbiAgY29uc3QgdHJhY2tlciA9IHN0YXJ0VHJhY2tpbmcoZXZlbnROYW1lKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG9wZXJhdGlvbigpO1xuXG4gICAgaWYgKHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpLnByb21pc2VzLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAvLyBBdG9tIHVzZXMgYSBkaWZmZXJlbnQgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiB0aGFuIE51Y2xpZGUsIHNvIHRoZSBmb2xsb3dpbmcgaXMgbm90IHRydWU6XG4gICAgICAvLyBpbnZhcmlhbnQocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSk7XG5cbiAgICAgIC8vIEZvciB0aGUgbWV0aG9kIHJldHVybmluZyBhIFByb21pc2UsIHRyYWNrIHRoZSB0aW1lIGFmdGVyIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkL3JlamVjdGVkLlxuICAgICAgcmV0dXJuIChyZXN1bHQ6IGFueSkudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgdHJhY2tlci5vblN1Y2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSwgKHJlYXNvbikgPT4ge1xuICAgICAgICB0cmFja2VyLm9uRXJyb3IocmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24gOiBuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrZXIub25TdWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0cmFja2VyLm9uRXJyb3IoZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0cmFjayxcbiAgdHJhY2tPcGVyYXRpb25UaW1pbmcsXG4gIHN0YXJ0VHJhY2tpbmcsXG4gIFRpbWluZ1RyYWNrZXIsXG4gIHRyYWNrVGltaW5nLFxuICBzZXRCYXRjaGluZyxcbn07XG4iXX0=
