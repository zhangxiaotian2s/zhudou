
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

exports.decorateSshConnectionDelegateWithTracking = decorateSshConnectionDelegateWithTracking;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var ConnectionTracker = require('./ConnectionTracker');
var SshConnection = require('ssh2').Client;
var fs = require('fs-plus');
var net = require('net');
var logger = require('nuclide-logging').getLogger();
var invariant = require('assert');

var RemoteConnection = require('./RemoteConnection');

var _require = require('nuclide-commons');

var fsPromise = _require.fsPromise;

// Sync word and regex pattern for parsing command stdout.
var SYNC_WORD = 'SYNSYN';
var STDOUT_REGEX = /SYNSYN[\s\S\n]*({.*})[\s\S\n]*SYNSYN/;
var READY_TIMEOUT = 60000;

// for simple password-based authentication

var SupportedMethods = {
  SSL_AGENT: 'SSL_AGENT',
  PASSWORD: 'PASSWORD',
  PRIVATE_KEY: 'PRIVATE_KEY'
};

/**
 * The server is asking for replies to the given prompts for
 * keyboard-interactive user authentication.
 *
 * @param name is generally what you'd use as
 *     a window title (for GUI apps).
 * @param prompts is an array of { prompt: 'Password: ',
 *     echo: false } style objects (here echo indicates whether user input
 *     should be displayed on the screen).
 * @param finish: The answers for all prompts must be provided as an
 *     array of strings and passed to finish when you are ready to continue. Note:
 *     It's possible for the server to come back and ask more questions.
 */

var SshHandshake = (function () {
  function SshHandshake(delegate, connection) {
    var _this = this;

    _classCallCheck(this, SshHandshake);

    this._delegate = delegate;
    this._connection = connection ? connection : new SshConnection();
    this._connection.on('ready', this._onConnect.bind(this));
    this._connection.on('error', function (e) {
      return _this._delegate.onError(e, _this._config);
    });
    this._connection.on('keyboard-interactive', this._onKeyboardInteractive.bind(this));
  }

  _createClass(SshHandshake, [{
    key: 'connect',
    value: _asyncToGenerator(function* (config) {
      var _this2 = this;

      this._config = config;

      this._delegate.onWillConnect(this._config);

      var existingConnection = RemoteConnection.getByHostnameAndPath(this._config.host, this._config.cwd);

      if (existingConnection) {
        this._delegate.onDidConnect(existingConnection, this._config);
        return;
      }

      var connection = yield RemoteConnection.createConnectionBySavedConfig(this._config.host, this._config.cwd);

      if (connection) {
        this._delegate.onDidConnect(connection, this._config);
        return;
      }

      var lookupPreferIpv6 = require('nuclide-commons').dnsUtils.lookupPreferIpv6;

      return lookupPreferIpv6(config.host).then(function (address) {
        if (config.authMethod === SupportedMethods.SSL_AGENT) {
          // Point to ssh-agent's socket for ssh-agent-based authentication.
          var agent = process.env['SSH_AUTH_SOCK'];
          if (!agent && /^win/.test(process.platform)) {
            // #100: On Windows, fall back to pageant.
            agent = 'pageant';
          }
          _this2._connection.connect({
            host: address,
            port: config.sshPort,
            username: config.username,
            agent: agent,
            tryKeyboard: true,
            readyTimeout: READY_TIMEOUT
          });
        } else if (config.authMethod === SupportedMethods.PASSWORD) {
          // When the user chooses password-based authentication, we specify
          // the config as follows so that it tries simple password auth and
          // failing that it falls through to the keyboard interactive path
          _this2._connection.connect({
            host: address,
            port: config.sshPort,
            username: config.username,
            password: config.password,
            tryKeyboard: true
          });
        } else if (config.authMethod === SupportedMethods.PRIVATE_KEY) {
          // We use fs-plus's normalize() function because it will expand the ~, if present.
          var expandedPath = fs.normalize(config.pathToPrivateKey);
          fsPromise.readFile(expandedPath).then(function (privateKey) {
            _this2._connection.connect({
              host: address,
              port: config.sshPort,
              username: config.username,
              privateKey: privateKey,
              tryKeyboard: true,
              readyTimeout: READY_TIMEOUT
            });
          })['catch'](function (e) {
            _this2._delegate.onError(e, _this2._config);
          });
        } else {
          throw new Error('Invalid authentication method');
        }
      })['catch'](function (e) {
        _this2._delegate.onError(e, _this2._config);
      });
    })
  }, {
    key: 'cancel',
    value: function cancel() {
      this._connection.end();
    }
  }, {
    key: '_onKeyboardInteractive',
    value: function _onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish) {
      this._delegate.onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish);
    }
  }, {
    key: '_forwardSocket',
    value: function _forwardSocket(socket) {
      this._connection.forwardOut(socket.remoteAddress, socket.remotePort, 'localhost', this._remotePort, function (err, stream) {
        if (err) {
          socket.end();
          logger.error(err);
          return;
        }

        socket.pipe(stream);
        stream.pipe(socket);
      });
    }
  }, {
    key: '_updateServerInfo',
    value: function _updateServerInfo(serverInfo) {
      invariant(serverInfo.port);
      this._remotePort = serverInfo.port;
      this._remoteHost = '' + (serverInfo.hostname || this._config.host);
      // Because the value for the Initial Directory that the user supplied may have
      // been a symlink that was resolved by the server, overwrite the original `cwd`
      // value with the resolved value.
      invariant(serverInfo.workspace);
      this._config.cwd = serverInfo.workspace;
      invariant(serverInfo.ca);
      this._certificateAuthorityCertificate = serverInfo.ca;
      invariant(serverInfo.cert);
      this._clientCertificate = serverInfo.cert;
      invariant(serverInfo.key);
      this._clientKey = serverInfo.key;
    }
  }, {
    key: '_isSecure',
    value: function _isSecure() {
      return !!(this._certificateAuthorityCertificate && this._clientCertificate && this._clientKey);
    }
  }, {
    key: '_startRemoteServer',
    value: function _startRemoteServer() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var stdOut = '';

        //TODO: escape any single quotes
        //TODO: the timeout value shall be configurable using .json file too (t6904691).
        var cmd = _this3._config.remoteServerCommand + ' --workspace=' + _this3._config.cwd + ' --common_name=' + _this3._config.host + ' -t 60';

        // This imitates a user typing:
        //   $ TERM=nuclide ssh server
        // then on the interactive prompt executing the remote server command.  If
        // that works, then nuclide should also work.
        //
        // The reason we don'y use exec here is because people like to put as the
        // last statement in their .bashrc zsh or fish.  This starts an
        // and interactive child shell that never exits if you exec.
        //
        // This is a bad idea because besides breaking us, it also breaks this:
        // $ ssh server any_cmd
        //
        // As a last resort we also set term to 'nuclide' so that if anything we
        // haven't thought of happens, the user can always add the following to
        // the top of their favorite shell startup file:
        //
        //   [ "$TERM" = "nuclide"] && return;
        _this3._connection.shell({ term: 'nuclide' }, function (err, stream) {
          if (err) {
            reject(err);
            return;
          }
          stream.on('close', function (code, signal) {
            var rejectWithError = function rejectWithError(error) {
              logger.error(error);
              var errorText = error + '\n\nstdout:' + stdOut;
              reject(new Error(errorText));
            };

            // Note: this code is probably the code from the child shell if one
            // is in use.
            if (code === 0) {
              var serverInfo = undefined;
              var match = STDOUT_REGEX.exec(stdOut);
              if (!match) {
                rejectWithError('Bad stdout from remote server: ' + stdOut);
                return;
              }
              try {
                serverInfo = JSON.parse(match[1]);
              } catch (e) {
                rejectWithError('Bad JSON reply from Nuclide server: ' + match[1]);
                return;
              }
              if (!serverInfo.workspace) {
                rejectWithError('Could not find directory: ' + _this3._config.cwd);
                return;
              }

              // Update server info that is needed for setting up client.
              _this3._updateServerInfo(serverInfo);
              resolve(undefined);
            } else {
              reject(new Error(stdOut));
            }
          }).on('data', function (data) {
            stdOut += data;
          });
          // Yes we exit twice.  This is because people who use shells like zsh
          // or fish, etc like to put zsh/fish as the last statement of their
          // .bashrc.  This means that when we exit zsh/fish, we then have to exit
          // the parent bash shell.
          //
          // The second exit is ignored when there is only one shell.
          //
          // We will still hang forever if they have a shell within a shell within
          // a shell.  But I can't bring myself to exit 3 times.
          //
          // TODO: (mikeo) There is a SHLVL environment variable set that can be
          // used to decide how many times to exit
          stream.end('echo ' + SYNC_WORD + ';' + cmd + ';echo ' + SYNC_WORD + '\nexit\nexit\n');
        });
      });
    }
  }, {
    key: '_onConnect',
    value: _asyncToGenerator(function* () {
      var _this4 = this;

      try {
        yield this._startRemoteServer();
      } catch (e) {
        this._delegate.onError(e, this._config);
        return;
      }

      var finishHandshake = _asyncToGenerator(function* (connection) {
        try {
          yield connection.initialize();
        } catch (e) {
          var _error = new Error('Failed to connect to Nuclide server on ' + _this4._config.host + ': ' + e.message);
          _this4._delegate.onError(_error, _this4._config);
        }
        _this4._delegate.onDidConnect(connection, _this4._config);
        // If we are secure then we don't need the ssh tunnel.
        if (_this4._isSecure()) {
          _this4._connection.end();
        }
      });

      // Use an ssh tunnel if server is not secure
      if (this._isSecure()) {
        invariant(this._remoteHost);
        invariant(this._remotePort);
        var _connection = new RemoteConnection({
          host: this._remoteHost,
          port: this._remotePort,
          cwd: this._config.cwd,
          certificateAuthorityCertificate: this._certificateAuthorityCertificate,
          clientCertificate: this._clientCertificate,
          clientKey: this._clientKey
        });
        finishHandshake(_connection);
      } else {
        this._forwardingServer = net.createServer(function (sock) {
          _this4._forwardSocket(sock);
        }).listen(0, 'localhost', function () {
          var localPort = _this4._getLocalPort();
          invariant(localPort);
          var connection = new RemoteConnection({
            host: 'localhost',
            port: localPort,
            cwd: _this4._config.cwd
          });
          finishHandshake(connection);
        });
      }
    })
  }, {
    key: '_getLocalPort',
    value: function _getLocalPort() {
      return this._forwardingServer ? this._forwardingServer.address().port : null;
    }
  }, {
    key: 'getConfig',
    value: function getConfig() {
      return this._config;
    }
  }]);

  return SshHandshake;
})();

exports.SshHandshake = SshHandshake;

SshHandshake.SupportedMethods = SupportedMethods;

function decorateSshConnectionDelegateWithTracking(delegate) {
  var connectionTracker = undefined;

  return {
    onKeyboardInteractive: function onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish) {
      invariant(connectionTracker);
      connectionTracker.trackPromptYubikeyInput();
      delegate.onKeyboardInteractive(name, instructions, instructionsLang, prompts, function (answers) {
        invariant(connectionTracker);
        connectionTracker.trackFinishYubikeyInput();
        finish(answers);
      });
    },
    onWillConnect: function onWillConnect(config) {
      connectionTracker = new ConnectionTracker(config);
      delegate.onWillConnect(config);
    },
    onDidConnect: function onDidConnect(connection, config) {
      invariant(connectionTracker);
      connectionTracker.trackSuccess();
      delegate.onDidConnect(connection, config);
    },
    onError: function onError(error, config) {
      invariant(connectionTracker);
      connectionTracker.trackFailure(error);
      delegate.onError(error, config);
    }
  };
}

// host nuclide server is running on
// ssh port of host nuclide server is running on
// username to authenticate as
// The path to private key
// Command to use to start server
// Path to remote directory user should start in upon connection.
// Which of the authentication methods in `SupportedMethods` to use.

/** Invoked when server requests keyboard interaction */

/** Invoked when trying to connect */

/** Invoked when connection is sucessful */

/** Invoked when connection is fails */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1jb25uZWN0aW9uL2xpYi9Tc2hIYW5kc2hha2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV1osSUFBTSxpQkFBaUIsR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUN6RCxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQzdDLElBQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM5QixJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDM0IsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDdEQsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUVwQyxJQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOztlQUNuQyxPQUFPLENBQUMsaUJBQWlCLENBQUM7O0lBQXZDLFNBQVMsWUFBVCxTQUFTOzs7QUFHaEIsSUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDO0FBQzNCLElBQU0sWUFBWSxHQUFHLHNDQUFzQyxDQUFDO0FBQzVELElBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQzs7OztBQWE1QixJQUFNLGdCQUFnQixHQUFHO0FBQ3ZCLFdBQVMsRUFBRSxXQUFXO0FBQ3RCLFVBQVEsRUFBRSxVQUFVO0FBQ3BCLGFBQVcsRUFBRSxhQUFhO0NBQzNCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpQ1csWUFBWTtBQVlaLFdBWkEsWUFBWSxDQVlYLFFBQStCLEVBQUUsVUFBMEIsRUFBRTs7OzBCQVo5RCxZQUFZOztB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QkFBaUIsQ0FBQyxDQUFDO0FBQzdCLHlCQUFpQixDQUFDLHVCQUF1QixFQUFFLENBQUM7QUFDNUMsY0FBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO09BQ2pCLENBQ0YsQ0FBQztLQUNIO0FBQ0QsaUJBQWEsRUFBRSx1QkFBQyxNQUFNLEVBQWlDO0FBQ3JELHVCQUFpQixHQUFHLElBQUksaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEQsY0FBUSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNoQztBQUNELGdCQUFZLEVBQUUsc0JBQUMsVUFBVSxFQUFvQixNQUFNLEVBQWlDO0FBQ2xGLGVBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzdCLHVCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ2pDLGNBQVEsQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQzNDO0FBQ0QsV0FBTyxFQUFFLGlCQUFDLEtBQUssRUFBUyxNQUFNLEVBQWlDO0FBQzdELGVBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzdCLHVCQUFpQixDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0QyxjQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztLQUNqQztHQUNGLENBQUM7Q0FDSCIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1yZW1vdGUtY29ubmVjdGlvbi9saWIvU3NoSGFuZHNoYWtlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgQ29ubmVjdGlvblRyYWNrZXIgPSByZXF1aXJlKCcuL0Nvbm5lY3Rpb25UcmFja2VyJyk7XG5jb25zdCBTc2hDb25uZWN0aW9uID0gcmVxdWlyZSgnc3NoMicpLkNsaWVudDtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMtcGx1cycpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcbmNvbnN0IGludmFyaWFudCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5jb25zdCBSZW1vdGVDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9SZW1vdGVDb25uZWN0aW9uJyk7XG5jb25zdCB7ZnNQcm9taXNlfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpO1xuXG4vLyBTeW5jIHdvcmQgYW5kIHJlZ2V4IHBhdHRlcm4gZm9yIHBhcnNpbmcgY29tbWFuZCBzdGRvdXQuXG5jb25zdCBTWU5DX1dPUkQgPSAnU1lOU1lOJztcbmNvbnN0IFNURE9VVF9SRUdFWCA9IC9TWU5TWU5bXFxzXFxTXFxuXSooey4qfSlbXFxzXFxTXFxuXSpTWU5TWU4vO1xuY29uc3QgUkVBRFlfVElNRU9VVCA9IDYwMDAwO1xuXG5leHBvcnQgdHlwZSBTc2hDb25uZWN0aW9uQ29uZmlndXJhdGlvbiA9IHtcbiAgaG9zdDogc3RyaW5nOyAvLyBob3N0IG51Y2xpZGUgc2VydmVyIGlzIHJ1bm5pbmcgb25cbiAgc3NoUG9ydDogbnVtYmVyOyAvLyBzc2ggcG9ydCBvZiBob3N0IG51Y2xpZGUgc2VydmVyIGlzIHJ1bm5pbmcgb25cbiAgdXNlcm5hbWU6IHN0cmluZzsgLy8gdXNlcm5hbWUgdG8gYXV0aGVudGljYXRlIGFzXG4gIHBhdGhUb1ByaXZhdGVLZXk6IHN0cmluZzsgLy8gVGhlIHBhdGggdG8gcHJpdmF0ZSBrZXlcbiAgcmVtb3RlU2VydmVyQ29tbWFuZDogc3RyaW5nOyAvLyBDb21tYW5kIHRvIHVzZSB0byBzdGFydCBzZXJ2ZXJcbiAgY3dkOiBzdHJpbmc7IC8vIFBhdGggdG8gcmVtb3RlIGRpcmVjdG9yeSB1c2VyIHNob3VsZCBzdGFydCBpbiB1cG9uIGNvbm5lY3Rpb24uXG4gIGF1dGhNZXRob2Q6IHN0cmluZzsgLy8gV2hpY2ggb2YgdGhlIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgaW4gYFN1cHBvcnRlZE1ldGhvZHNgIHRvIHVzZS5cbiAgcGFzc3dvcmQ6IHN0cmluZzsgLy8gZm9yIHNpbXBsZSBwYXNzd29yZC1iYXNlZCBhdXRoZW50aWNhdGlvblxufVxuXG5jb25zdCBTdXBwb3J0ZWRNZXRob2RzID0ge1xuICBTU0xfQUdFTlQ6ICdTU0xfQUdFTlQnLFxuICBQQVNTV09SRDogJ1BBU1NXT1JEJyxcbiAgUFJJVkFURV9LRVk6ICdQUklWQVRFX0tFWScsXG59O1xuXG4vKipcbiAqIFRoZSBzZXJ2ZXIgaXMgYXNraW5nIGZvciByZXBsaWVzIHRvIHRoZSBnaXZlbiBwcm9tcHRzIGZvclxuICoga2V5Ym9hcmQtaW50ZXJhY3RpdmUgdXNlciBhdXRoZW50aWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSBpcyBnZW5lcmFsbHkgd2hhdCB5b3UnZCB1c2UgYXNcbiAqICAgICBhIHdpbmRvdyB0aXRsZSAoZm9yIEdVSSBhcHBzKS5cbiAqIEBwYXJhbSBwcm9tcHRzIGlzIGFuIGFycmF5IG9mIHsgcHJvbXB0OiAnUGFzc3dvcmQ6ICcsXG4gKiAgICAgZWNobzogZmFsc2UgfSBzdHlsZSBvYmplY3RzIChoZXJlIGVjaG8gaW5kaWNhdGVzIHdoZXRoZXIgdXNlciBpbnB1dFxuICogICAgIHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gdGhlIHNjcmVlbikuXG4gKiBAcGFyYW0gZmluaXNoOiBUaGUgYW5zd2VycyBmb3IgYWxsIHByb21wdHMgbXVzdCBiZSBwcm92aWRlZCBhcyBhblxuICogICAgIGFycmF5IG9mIHN0cmluZ3MgYW5kIHBhc3NlZCB0byBmaW5pc2ggd2hlbiB5b3UgYXJlIHJlYWR5IHRvIGNvbnRpbnVlLiBOb3RlOlxuICogICAgIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzZXJ2ZXIgdG8gY29tZSBiYWNrIGFuZCBhc2sgbW9yZSBxdWVzdGlvbnMuXG4gKi9cbmV4cG9ydCB0eXBlIEtleWJvYXJkSW50ZXJhY3RpdmVDYWxsYmFjayA9IChcbiAgbmFtZTogc3RyaW5nLFxuICBpbnN0cnVjdGlvbnM6IHN0cmluZyxcbiAgaW5zdHJ1Y3Rpb25zTGFuZzogc3RyaW5nLFxuICBwcm9tcHRzOiBBcnJheTx7cHJvbXB0OiBzdHJpbmc7IGVjaG86IGJvb2xlYW47fT4sXG4gIGZpbmlzaDogKGFuc3dlcnM6IEFycmF5PHN0cmluZz4pID0+IHZvaWQpICA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBTc2hDb25uZWN0aW9uRGVsZWdhdGUgPSB7XG4gIC8qKiBJbnZva2VkIHdoZW4gc2VydmVyIHJlcXVlc3RzIGtleWJvYXJkIGludGVyYWN0aW9uICovXG4gIG9uS2V5Ym9hcmRJbnRlcmFjdGl2ZTogS2V5Ym9hcmRJbnRlcmFjdGl2ZUNhbGxiYWNrO1xuICAvKiogSW52b2tlZCB3aGVuIHRyeWluZyB0byBjb25uZWN0ICovXG4gIG9uV2lsbENvbm5lY3Q6IChjb25maWc6IFNzaENvbm5lY3Rpb25Db25maWd1cmF0aW9uKSA9PiB2b2lkO1xuICAvKiogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gaXMgc3VjZXNzZnVsICovXG4gIG9uRGlkQ29ubmVjdDogKGNvbm5lY3Rpb246IFJlbW90ZUNvbm5lY3Rpb24sIGNvbmZpZzogU3NoQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb24pID0+IHZvaWQ7XG4gIC8qKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiBpcyBmYWlscyAqL1xuICBvbkVycm9yOiAoZXJyb3I6IEVycm9yLCBjb25maWc6IFNzaENvbm5lY3Rpb25Db25maWd1cmF0aW9uKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgU3NoSGFuZHNoYWtlIHtcbiAgX2RlbGVnYXRlOiBTc2hDb25uZWN0aW9uRGVsZWdhdGU7XG4gIF9jb25uZWN0aW9uOiBTc2hDb25uZWN0aW9uO1xuICBfY29uZmlnOiBTc2hDb25uZWN0aW9uQ29uZmlndXJhdGlvbjtcbiAgX2ZvcndhcmRpbmdTZXJ2ZXI6IG5ldC5Tb2NrZXQ7XG4gIF9yZW1vdGVIb3N0OiA/c3RyaW5nO1xuICBfcmVtb3RlUG9ydDogP251bWJlcjtcbiAgX2NlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGU6IEJ1ZmZlcjtcbiAgX2NsaWVudENlcnRpZmljYXRlOiBCdWZmZXI7XG4gIF9jbGllbnRLZXk6IEJ1ZmZlcjtcbiAgc3RhdGljIFN1cHBvcnRlZE1ldGhvZHM6IHt9O1xuXG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlOiBTc2hDb25uZWN0aW9uRGVsZWdhdGUsIGNvbm5lY3Rpb24/OiBTc2hDb25uZWN0aW9uKSB7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbiA/IGNvbm5lY3Rpb24gOiBuZXcgU3NoQ29ubmVjdGlvbigpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oJ3JlYWR5JywgdGhpcy5fb25Db25uZWN0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oJ2Vycm9yJywgZSA9PiB0aGlzLl9kZWxlZ2F0ZS5vbkVycm9yKGUsIHRoaXMuX2NvbmZpZykpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oJ2tleWJvYXJkLWludGVyYWN0aXZlJywgdGhpcy5fb25LZXlib2FyZEludGVyYWN0aXZlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdChjb25maWc6IFNzaENvbm5lY3Rpb25Db25maWd1cmF0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuXG4gICAgdGhpcy5fZGVsZWdhdGUub25XaWxsQ29ubmVjdCh0aGlzLl9jb25maWcpO1xuXG4gICAgY29uc3QgZXhpc3RpbmdDb25uZWN0aW9uID0gUmVtb3RlQ29ubmVjdGlvblxuICAgICAgLmdldEJ5SG9zdG5hbWVBbmRQYXRoKHRoaXMuX2NvbmZpZy5ob3N0LCB0aGlzLl9jb25maWcuY3dkKTtcblxuICAgIGlmIChleGlzdGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLm9uRGlkQ29ubmVjdChleGlzdGluZ0Nvbm5lY3Rpb24sIHRoaXMuX2NvbmZpZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IFJlbW90ZUNvbm5lY3Rpb24uY3JlYXRlQ29ubmVjdGlvbkJ5U2F2ZWRDb25maWcoXG4gICAgICB0aGlzLl9jb25maWcuaG9zdCxcbiAgICAgIHRoaXMuX2NvbmZpZy5jd2QsXG4gICAgKTtcblxuICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS5vbkRpZENvbm5lY3QoY29ubmVjdGlvbiwgdGhpcy5fY29uZmlnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7bG9va3VwUHJlZmVySXB2Nn0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKS5kbnNVdGlscztcbiAgICByZXR1cm4gbG9va3VwUHJlZmVySXB2Nihjb25maWcuaG9zdCkudGhlbigoYWRkcmVzcykgPT4ge1xuICAgICAgaWYgKGNvbmZpZy5hdXRoTWV0aG9kID09PSBTdXBwb3J0ZWRNZXRob2RzLlNTTF9BR0VOVCkge1xuICAgICAgICAvLyBQb2ludCB0byBzc2gtYWdlbnQncyBzb2NrZXQgZm9yIHNzaC1hZ2VudC1iYXNlZCBhdXRoZW50aWNhdGlvbi5cbiAgICAgICAgbGV0IGFnZW50ID0gcHJvY2Vzcy5lbnZbJ1NTSF9BVVRIX1NPQ0snXTtcbiAgICAgICAgaWYgKCFhZ2VudCAmJiAvXndpbi8udGVzdChwcm9jZXNzLnBsYXRmb3JtKSkge1xuICAgICAgICAgIC8vICMxMDA6IE9uIFdpbmRvd3MsIGZhbGwgYmFjayB0byBwYWdlYW50LlxuICAgICAgICAgIGFnZW50ID0gJ3BhZ2VhbnQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uY29ubmVjdCh7XG4gICAgICAgICAgaG9zdDogYWRkcmVzcyxcbiAgICAgICAgICBwb3J0OiBjb25maWcuc3NoUG9ydCxcbiAgICAgICAgICB1c2VybmFtZTogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgICAgIGFnZW50LFxuICAgICAgICAgIHRyeUtleWJvYXJkOiB0cnVlLFxuICAgICAgICAgIHJlYWR5VGltZW91dDogUkVBRFlfVElNRU9VVCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5hdXRoTWV0aG9kID09PSBTdXBwb3J0ZWRNZXRob2RzLlBBU1NXT1JEKSB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgdXNlciBjaG9vc2VzIHBhc3N3b3JkLWJhc2VkIGF1dGhlbnRpY2F0aW9uLCB3ZSBzcGVjaWZ5XG4gICAgICAgICAgLy8gdGhlIGNvbmZpZyBhcyBmb2xsb3dzIHNvIHRoYXQgaXQgdHJpZXMgc2ltcGxlIHBhc3N3b3JkIGF1dGggYW5kXG4gICAgICAgICAgLy8gZmFpbGluZyB0aGF0IGl0IGZhbGxzIHRocm91Z2ggdG8gdGhlIGtleWJvYXJkIGludGVyYWN0aXZlIHBhdGhcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5jb25uZWN0KHtcbiAgICAgICAgICBob3N0OiBhZGRyZXNzLFxuICAgICAgICAgIHBvcnQ6IGNvbmZpZy5zc2hQb3J0LFxuICAgICAgICAgIHVzZXJuYW1lOiBjb25maWcudXNlcm5hbWUsXG4gICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgICAgICB0cnlLZXlib2FyZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5hdXRoTWV0aG9kID09PSBTdXBwb3J0ZWRNZXRob2RzLlBSSVZBVEVfS0VZKSB7XG4gICAgICAgIC8vIFdlIHVzZSBmcy1wbHVzJ3Mgbm9ybWFsaXplKCkgZnVuY3Rpb24gYmVjYXVzZSBpdCB3aWxsIGV4cGFuZCB0aGUgfiwgaWYgcHJlc2VudC5cbiAgICAgICAgY29uc3QgZXhwYW5kZWRQYXRoID0gZnMubm9ybWFsaXplKGNvbmZpZy5wYXRoVG9Qcml2YXRlS2V5KTtcbiAgICAgICAgZnNQcm9taXNlLnJlYWRGaWxlKGV4cGFuZGVkUGF0aCkudGhlbihwcml2YXRlS2V5ID0+IHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmNvbm5lY3Qoe1xuICAgICAgICAgICAgaG9zdDogYWRkcmVzcyxcbiAgICAgICAgICAgIHBvcnQ6IGNvbmZpZy5zc2hQb3J0LFxuICAgICAgICAgICAgdXNlcm5hbWU6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICB0cnlLZXlib2FyZDogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWR5VGltZW91dDogUkVBRFlfVElNRU9VVCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vbkVycm9yKGUsIHRoaXMuX2NvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCcpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS5vbkVycm9yKGUsIHRoaXMuX2NvbmZpZyk7XG4gICAgfSk7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5lbmQoKTtcbiAgfVxuXG4gIF9vbktleWJvYXJkSW50ZXJhY3RpdmUoXG4gICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICBpbnN0cnVjdGlvbnM6IHN0cmluZyxcbiAgICAgIGluc3RydWN0aW9uc0xhbmc6IHN0cmluZyxcbiAgICAgIHByb21wdHM6IEFycmF5PHtwcm9tcHQ6IHN0cmluZzsgZWNobzogYm9vbGVhbjt9PixcbiAgICAgIGZpbmlzaDogKGFuc3dlcnM6IEFycmF5PHN0cmluZz4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5vbktleWJvYXJkSW50ZXJhY3RpdmUobmFtZSwgaW5zdHJ1Y3Rpb25zLCBpbnN0cnVjdGlvbnNMYW5nLCBwcm9tcHRzLCBmaW5pc2gpO1xuICB9XG5cbiAgX2ZvcndhcmRTb2NrZXQoc29ja2V0OiBuZXQuU29ja2V0KTogdm9pZCB7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5mb3J3YXJkT3V0KFxuICAgICAgc29ja2V0LnJlbW90ZUFkZHJlc3MsXG4gICAgICBzb2NrZXQucmVtb3RlUG9ydCxcbiAgICAgICdsb2NhbGhvc3QnLFxuICAgICAgdGhpcy5fcmVtb3RlUG9ydCxcbiAgICAgIChlcnIsIHN0cmVhbSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgc29ja2V0LmVuZCgpO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvY2tldC5waXBlKHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5waXBlKHNvY2tldCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIF91cGRhdGVTZXJ2ZXJJbmZvKHNlcnZlckluZm86IHt9KSB7XG4gICAgaW52YXJpYW50KHNlcnZlckluZm8ucG9ydCk7XG4gICAgdGhpcy5fcmVtb3RlUG9ydCA9IHNlcnZlckluZm8ucG9ydDtcbiAgICB0aGlzLl9yZW1vdGVIb3N0ID0gYCR7c2VydmVySW5mby5ob3N0bmFtZSB8fCB0aGlzLl9jb25maWcuaG9zdH1gO1xuICAgIC8vIEJlY2F1c2UgdGhlIHZhbHVlIGZvciB0aGUgSW5pdGlhbCBEaXJlY3RvcnkgdGhhdCB0aGUgdXNlciBzdXBwbGllZCBtYXkgaGF2ZVxuICAgIC8vIGJlZW4gYSBzeW1saW5rIHRoYXQgd2FzIHJlc29sdmVkIGJ5IHRoZSBzZXJ2ZXIsIG92ZXJ3cml0ZSB0aGUgb3JpZ2luYWwgYGN3ZGBcbiAgICAvLyB2YWx1ZSB3aXRoIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICBpbnZhcmlhbnQoc2VydmVySW5mby53b3Jrc3BhY2UpO1xuICAgIHRoaXMuX2NvbmZpZy5jd2QgPSBzZXJ2ZXJJbmZvLndvcmtzcGFjZTtcbiAgICBpbnZhcmlhbnQoc2VydmVySW5mby5jYSk7XG4gICAgdGhpcy5fY2VydGlmaWNhdGVBdXRob3JpdHlDZXJ0aWZpY2F0ZSA9IHNlcnZlckluZm8uY2E7XG4gICAgaW52YXJpYW50KHNlcnZlckluZm8uY2VydCk7XG4gICAgdGhpcy5fY2xpZW50Q2VydGlmaWNhdGUgPSBzZXJ2ZXJJbmZvLmNlcnQ7XG4gICAgaW52YXJpYW50KHNlcnZlckluZm8ua2V5KTtcbiAgICB0aGlzLl9jbGllbnRLZXkgPSBzZXJ2ZXJJbmZvLmtleTtcbiAgfVxuXG4gIF9pc1NlY3VyZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEodGhpcy5fY2VydGlmaWNhdGVBdXRob3JpdHlDZXJ0aWZpY2F0ZVxuICAgICAgICAmJiB0aGlzLl9jbGllbnRDZXJ0aWZpY2F0ZVxuICAgICAgICAmJiB0aGlzLl9jbGllbnRLZXkpO1xuICB9XG5cbiAgX3N0YXJ0UmVtb3RlU2VydmVyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc3RkT3V0ID0gJyc7XG5cbiAgICAgIC8vVE9ETzogZXNjYXBlIGFueSBzaW5nbGUgcXVvdGVzXG4gICAgICAvL1RPRE86IHRoZSB0aW1lb3V0IHZhbHVlIHNoYWxsIGJlIGNvbmZpZ3VyYWJsZSB1c2luZyAuanNvbiBmaWxlIHRvbyAodDY5MDQ2OTEpLlxuICAgICAgY29uc3QgY21kID0gYCR7dGhpcy5fY29uZmlnLnJlbW90ZVNlcnZlckNvbW1hbmR9IC0td29ya3NwYWNlPSR7dGhpcy5fY29uZmlnLmN3ZH0gLS1jb21tb25fbmFtZT0ke3RoaXMuX2NvbmZpZy5ob3N0fSAtdCA2MGA7XG5cbiAgICAgIC8vIFRoaXMgaW1pdGF0ZXMgYSB1c2VyIHR5cGluZzpcbiAgICAgIC8vICAgJCBURVJNPW51Y2xpZGUgc3NoIHNlcnZlclxuICAgICAgLy8gdGhlbiBvbiB0aGUgaW50ZXJhY3RpdmUgcHJvbXB0IGV4ZWN1dGluZyB0aGUgcmVtb3RlIHNlcnZlciBjb21tYW5kLiAgSWZcbiAgICAgIC8vIHRoYXQgd29ya3MsIHRoZW4gbnVjbGlkZSBzaG91bGQgYWxzbyB3b3JrLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSByZWFzb24gd2UgZG9uJ3kgdXNlIGV4ZWMgaGVyZSBpcyBiZWNhdXNlIHBlb3BsZSBsaWtlIHRvIHB1dCBhcyB0aGVcbiAgICAgIC8vIGxhc3Qgc3RhdGVtZW50IGluIHRoZWlyIC5iYXNocmMgenNoIG9yIGZpc2guICBUaGlzIHN0YXJ0cyBhblxuICAgICAgLy8gYW5kIGludGVyYWN0aXZlIGNoaWxkIHNoZWxsIHRoYXQgbmV2ZXIgZXhpdHMgaWYgeW91IGV4ZWMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBhIGJhZCBpZGVhIGJlY2F1c2UgYmVzaWRlcyBicmVha2luZyB1cywgaXQgYWxzbyBicmVha3MgdGhpczpcbiAgICAgIC8vICQgc3NoIHNlcnZlciBhbnlfY21kXG4gICAgICAvL1xuICAgICAgLy8gQXMgYSBsYXN0IHJlc29ydCB3ZSBhbHNvIHNldCB0ZXJtIHRvICdudWNsaWRlJyBzbyB0aGF0IGlmIGFueXRoaW5nIHdlXG4gICAgICAvLyBoYXZlbid0IHRob3VnaHQgb2YgaGFwcGVucywgdGhlIHVzZXIgY2FuIGFsd2F5cyBhZGQgdGhlIGZvbGxvd2luZyB0b1xuICAgICAgLy8gdGhlIHRvcCBvZiB0aGVpciBmYXZvcml0ZSBzaGVsbCBzdGFydHVwIGZpbGU6XG4gICAgICAvL1xuICAgICAgLy8gICBbIFwiJFRFUk1cIiA9IFwibnVjbGlkZVwiXSAmJiByZXR1cm47XG4gICAgICB0aGlzLl9jb25uZWN0aW9uLnNoZWxsKHt0ZXJtOiAnbnVjbGlkZSd9LCAoZXJyLCBzdHJlYW0pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlamVjdFdpdGhFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGAke2Vycm9yfVxcblxcbnN0ZG91dDoke3N0ZE91dH1gO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvclRleHQpKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gTm90ZTogdGhpcyBjb2RlIGlzIHByb2JhYmx5IHRoZSBjb2RlIGZyb20gdGhlIGNoaWxkIHNoZWxsIGlmIG9uZVxuICAgICAgICAgIC8vIGlzIGluIHVzZS5cbiAgICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgICAgbGV0IHNlcnZlckluZm87XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IFNURE9VVF9SRUdFWC5leGVjKHN0ZE91dCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgIHJlamVjdFdpdGhFcnJvcihgQmFkIHN0ZG91dCBmcm9tIHJlbW90ZSBzZXJ2ZXI6ICR7c3RkT3V0fWApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzZXJ2ZXJJbmZvID0gSlNPTi5wYXJzZShtYXRjaFsxXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdFdpdGhFcnJvcihgQmFkIEpTT04gcmVwbHkgZnJvbSBOdWNsaWRlIHNlcnZlcjogJHttYXRjaFsxXX1gKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZXJ2ZXJJbmZvLndvcmtzcGFjZSkge1xuICAgICAgICAgICAgICByZWplY3RXaXRoRXJyb3IoYENvdWxkIG5vdCBmaW5kIGRpcmVjdG9yeTogJHt0aGlzLl9jb25maWcuY3dkfWApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzZXJ2ZXIgaW5mbyB0aGF0IGlzIG5lZWRlZCBmb3Igc2V0dGluZyB1cCBjbGllbnQuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXJ2ZXJJbmZvKHNlcnZlckluZm8pO1xuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHN0ZE91dCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgICBzdGRPdXQgKz0gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFllcyB3ZSBleGl0IHR3aWNlLiAgVGhpcyBpcyBiZWNhdXNlIHBlb3BsZSB3aG8gdXNlIHNoZWxscyBsaWtlIHpzaFxuICAgICAgICAvLyBvciBmaXNoLCBldGMgbGlrZSB0byBwdXQgenNoL2Zpc2ggYXMgdGhlIGxhc3Qgc3RhdGVtZW50IG9mIHRoZWlyXG4gICAgICAgIC8vIC5iYXNocmMuICBUaGlzIG1lYW5zIHRoYXQgd2hlbiB3ZSBleGl0IHpzaC9maXNoLCB3ZSB0aGVuIGhhdmUgdG8gZXhpdFxuICAgICAgICAvLyB0aGUgcGFyZW50IGJhc2ggc2hlbGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgZXhpdCBpcyBpZ25vcmVkIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgc2hlbGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHdpbGwgc3RpbGwgaGFuZyBmb3JldmVyIGlmIHRoZXkgaGF2ZSBhIHNoZWxsIHdpdGhpbiBhIHNoZWxsIHdpdGhpblxuICAgICAgICAvLyBhIHNoZWxsLiAgQnV0IEkgY2FuJ3QgYnJpbmcgbXlzZWxmIHRvIGV4aXQgMyB0aW1lcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVE9ETzogKG1pa2VvKSBUaGVyZSBpcyBhIFNITFZMIGVudmlyb25tZW50IHZhcmlhYmxlIHNldCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyB1c2VkIHRvIGRlY2lkZSBob3cgbWFueSB0aW1lcyB0byBleGl0XG4gICAgICAgIHN0cmVhbS5lbmQoYGVjaG8gJHtTWU5DX1dPUkR9OyR7Y21kfTtlY2hvICR7U1lOQ19XT1JEfVxcbmV4aXRcXG5leGl0XFxuYCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIF9vbkNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0UmVtb3RlU2VydmVyKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUub25FcnJvcihlLCB0aGlzLl9jb25maWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbmlzaEhhbmRzaGFrZSA9IGFzeW5jIChjb25uZWN0aW9uOiBSZW1vdGVDb25uZWN0aW9uKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjb25uZWN0aW9uLmluaXRpYWxpemUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb25uZWN0IHRvIE51Y2xpZGUgc2VydmVyIG9uICR7dGhpcy5fY29uZmlnLmhvc3R9OiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUub25FcnJvcihlcnJvciwgdGhpcy5fY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlbGVnYXRlLm9uRGlkQ29ubmVjdChjb25uZWN0aW9uLCB0aGlzLl9jb25maWcpO1xuICAgICAgLy8gSWYgd2UgYXJlIHNlY3VyZSB0aGVuIHdlIGRvbid0IG5lZWQgdGhlIHNzaCB0dW5uZWwuXG4gICAgICBpZiAodGhpcy5faXNTZWN1cmUoKSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmVuZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVc2UgYW4gc3NoIHR1bm5lbCBpZiBzZXJ2ZXIgaXMgbm90IHNlY3VyZVxuICAgIGlmICh0aGlzLl9pc1NlY3VyZSgpKSB7XG4gICAgICBpbnZhcmlhbnQodGhpcy5fcmVtb3RlSG9zdCk7XG4gICAgICBpbnZhcmlhbnQodGhpcy5fcmVtb3RlUG9ydCk7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IFJlbW90ZUNvbm5lY3Rpb24oe1xuICAgICAgICBob3N0OiB0aGlzLl9yZW1vdGVIb3N0LFxuICAgICAgICBwb3J0OiB0aGlzLl9yZW1vdGVQb3J0LFxuICAgICAgICBjd2Q6IHRoaXMuX2NvbmZpZy5jd2QsXG4gICAgICAgIGNlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGU6IHRoaXMuX2NlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGUsXG4gICAgICAgIGNsaWVudENlcnRpZmljYXRlOiB0aGlzLl9jbGllbnRDZXJ0aWZpY2F0ZSxcbiAgICAgICAgY2xpZW50S2V5OiB0aGlzLl9jbGllbnRLZXksXG4gICAgICB9KTtcbiAgICAgIGZpbmlzaEhhbmRzaGFrZShjb25uZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9yd2FyZGluZ1NlcnZlciA9IG5ldC5jcmVhdGVTZXJ2ZXIoc29jayA9PiB7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTb2NrZXQoc29jayk7XG4gICAgICB9KS5saXN0ZW4oMCwgJ2xvY2FsaG9zdCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbG9jYWxQb3J0ID0gdGhpcy5fZ2V0TG9jYWxQb3J0KCk7XG4gICAgICAgIGludmFyaWFudChsb2NhbFBvcnQpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IFJlbW90ZUNvbm5lY3Rpb24oe1xuICAgICAgICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgIHBvcnQ6IGxvY2FsUG9ydCxcbiAgICAgICAgICBjd2Q6IHRoaXMuX2NvbmZpZy5jd2QsXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5pc2hIYW5kc2hha2UoY29ubmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZ2V0TG9jYWxQb3J0KCk6ID9udW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9mb3J3YXJkaW5nU2VydmVyID8gdGhpcy5fZm9yd2FyZGluZ1NlcnZlci5hZGRyZXNzKCkucG9ydCA6IG51bGw7XG4gIH1cblxuICBnZXRDb25maWcoKTogU3NoQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb257XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgfVxufVxuXG5Tc2hIYW5kc2hha2UuU3VwcG9ydGVkTWV0aG9kcyA9IFN1cHBvcnRlZE1ldGhvZHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZVNzaENvbm5lY3Rpb25EZWxlZ2F0ZVdpdGhUcmFja2luZyhcbiAgZGVsZWdhdGU6IFNzaENvbm5lY3Rpb25EZWxlZ2F0ZSxcbik6IFNzaENvbm5lY3Rpb25EZWxlZ2F0ZSB7XG4gIGxldCBjb25uZWN0aW9uVHJhY2tlcjtcblxuICByZXR1cm4ge1xuICAgIG9uS2V5Ym9hcmRJbnRlcmFjdGl2ZTogKFxuICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiBzdHJpbmcsXG4gICAgICBpbnN0cnVjdGlvbnNMYW5nOiBzdHJpbmcsXG4gICAgICBwcm9tcHRzOiBBcnJheTx7cHJvbXB0OiBzdHJpbmc7IGVjaG86IGJvb2xlYW47fT4sXG4gICAgICBmaW5pc2g6IChhbnN3ZXJzOiBBcnJheTxzdHJpbmc+KSA9PiB2b2lkLFxuICAgICkgPT4ge1xuICAgICAgaW52YXJpYW50KGNvbm5lY3Rpb25UcmFja2VyKTtcbiAgICAgIGNvbm5lY3Rpb25UcmFja2VyLnRyYWNrUHJvbXB0WXViaWtleUlucHV0KCk7XG4gICAgICBkZWxlZ2F0ZS5vbktleWJvYXJkSW50ZXJhY3RpdmUoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGluc3RydWN0aW9ucyxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zTGFuZyxcbiAgICAgICAgcHJvbXB0cyxcbiAgICAgICAgKGFuc3dlcnMpID0+IHtcbiAgICAgICAgICBpbnZhcmlhbnQoY29ubmVjdGlvblRyYWNrZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb25UcmFja2VyLnRyYWNrRmluaXNoWXViaWtleUlucHV0KCk7XG4gICAgICAgICAgZmluaXNoKGFuc3dlcnMpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9LFxuICAgIG9uV2lsbENvbm5lY3Q6IChjb25maWc6IFNzaENvbm5lY3Rpb25Db25maWd1cmF0aW9uKSA9PiB7XG4gICAgICBjb25uZWN0aW9uVHJhY2tlciA9IG5ldyBDb25uZWN0aW9uVHJhY2tlcihjb25maWcpO1xuICAgICAgZGVsZWdhdGUub25XaWxsQ29ubmVjdChjb25maWcpO1xuICAgIH0sXG4gICAgb25EaWRDb25uZWN0OiAoY29ubmVjdGlvbjogUmVtb3RlQ29ubmVjdGlvbiwgY29uZmlnOiBTc2hDb25uZWN0aW9uQ29uZmlndXJhdGlvbikgPT4ge1xuICAgICAgaW52YXJpYW50KGNvbm5lY3Rpb25UcmFja2VyKTtcbiAgICAgIGNvbm5lY3Rpb25UcmFja2VyLnRyYWNrU3VjY2VzcygpO1xuICAgICAgZGVsZWdhdGUub25EaWRDb25uZWN0KGNvbm5lY3Rpb24sIGNvbmZpZyk7XG4gICAgfSxcbiAgICBvbkVycm9yOiAoZXJyb3I6IEVycm9yLCBjb25maWc6IFNzaENvbm5lY3Rpb25Db25maWd1cmF0aW9uKSA9PiB7XG4gICAgICBpbnZhcmlhbnQoY29ubmVjdGlvblRyYWNrZXIpO1xuICAgICAgY29ubmVjdGlvblRyYWNrZXIudHJhY2tGYWlsdXJlKGVycm9yKTtcbiAgICAgIGRlbGVnYXRlLm9uRXJyb3IoZXJyb3IsIGNvbmZpZyk7XG4gICAgfSxcbiAgfTtcbn1cbiJdfQ==
