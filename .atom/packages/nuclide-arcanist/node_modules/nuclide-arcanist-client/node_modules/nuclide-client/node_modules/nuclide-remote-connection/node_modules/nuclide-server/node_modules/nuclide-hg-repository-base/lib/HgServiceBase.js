var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */
/* @providesModule LocalHgServiceBase */

var _hgConstants = require('./hg-constants');

var _rx = require('rx');

var _hgBlameOutputParser = require('./hg-blame-output-parser');

var _hgDiffOutputParser = require('./hg-diff-output-parser');

var _hgRevisionExpressionHelpers = require('./hg-revision-expression-helpers');

var _hgRevisionStateHelpers = require('./hg-revision-state-helpers');

var _nuclideCommons = require('nuclide-commons');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

'use babel';

var FORK_BASE_BOOKMARK_NAME = 'remote/master';

var logger = undefined;
function getLogger() {
  if (!logger) {
    logger = require('nuclide-logging').getLogger();
  }
  return logger;
}

var HgServiceBase = (function () {
  function HgServiceBase(workingDirectory) {
    _classCallCheck(this, HgServiceBase);

    this._workingDirectory = workingDirectory;
    this._filesDidChangeObserver = new _rx.Subject();
    this._hgIgnoreFileDidChangeObserver = new _rx.Subject();
    this._hgRepoStateDidChangeObserver = new _rx.Subject();
    this._hgBookmarkDidChangeObserver = new _rx.Subject();
  }

  _createClass(HgServiceBase, [{
    key: 'dispose',
    value: _asyncToGenerator(function* () {
      this._filesDidChangeObserver.onCompleted();
      this._hgIgnoreFileDidChangeObserver.onCompleted();
      this._hgRepoStateDidChangeObserver.onCompleted();
      this._hgBookmarkDidChangeObserver.onCompleted();
    })
  }, {
    key: 'getWorkingDirectory',
    value: function getWorkingDirectory() {
      return this._workingDirectory;
    }

    /**
     * See HgService::fetchStatuses for details.
     */
  }, {
    key: 'fetchStatuses',
    value: _asyncToGenerator(function* (filePaths, options) {
      var _this = this;

      var statusMap = new Map();

      var args = ['status', '-Tjson'];
      if (options && 'hgStatusOption' in options) {
        if (options.hgStatusOption === _hgConstants.HgStatusOption.ONLY_IGNORED) {
          args.push('--ignored');
        } else if (options.hgStatusOption === _hgConstants.HgStatusOption.ALL_STATUSES) {
          args.push('--all');
        }
      }
      args = args.concat(filePaths);
      var execOptions = {
        cwd: this.getWorkingDirectory()
      };
      var output = undefined;
      try {
        output = yield this._hgAsyncExecute(args, execOptions);
      } catch (e) {
        return statusMap;
      }

      var statuses = JSON.parse(output.stdout);
      statuses.forEach(function (status) {
        statusMap.set(_this._absolutize(status.path), status.status);
      });
      return statusMap;
    })

    // Mercurial returns all paths relative to the repository's working directory.
    // This method transforms a path relative to the working direcotry into an
    // absolute path.
  }, {
    key: '_absolutize',
    value: function _absolutize(pathRelativeToWorkingDirectory) {
      return _path2['default'].join(this._workingDirectory, pathRelativeToWorkingDirectory);
    }

    /**
     * See HgService.def::observeFilesDidChange for details.
     */
  }, {
    key: 'observeFilesDidChange',
    value: function observeFilesDidChange() {
      return this._filesDidChangeObserver;
    }

    /**
     * See HgService.def::observeHgIgnoreFileDidChange for details.
     */
  }, {
    key: 'observeHgIgnoreFileDidChange',
    value: function observeHgIgnoreFileDidChange() {
      return this._hgIgnoreFileDidChangeObserver;
    }

    /**
     * See HgService.def::observeHgRepoStateDidChange for details.
     */
  }, {
    key: 'observeHgRepoStateDidChange',
    value: function observeHgRepoStateDidChange() {
      return this._hgRepoStateDidChangeObserver;
    }

    /**
     * See HgService.def::fetchDiffInfoForPaths for details.
     */
  }, {
    key: 'fetchDiffInfo',
    value: _asyncToGenerator(function* (filePaths) {
      // '--unified 0' gives us 0 lines of context around each change (we don't
      // care about the context).
      // '--noprefix' omits the a/ and b/ prefixes from filenames.
      var args = ['diff', '--unified', '0', '--noprefix'].concat(filePaths);
      var options = {
        cwd: this.getWorkingDirectory()
      };
      var output = undefined;
      try {
        output = yield this._hgAsyncExecute(args, options);
      } catch (e) {
        getLogger().error('Error when running hg diff for paths: ' + filePaths + ' \n\tError: ' + e.stderr);
        return null;
      }
      var pathToDiffInfo = (0, _hgDiffOutputParser.parseMultiFileHgDiffUnifiedOutput)(output.stdout);
      var absolutePathToDiffInfo = new Map();
      for (var _ref3 of pathToDiffInfo) {
        var _ref2 = _slicedToArray(_ref3, 2);

        var filePath = _ref2[0];
        var diffInfo = _ref2[1];

        absolutePathToDiffInfo.set(this._absolutize(filePath), diffInfo);
      }
      return absolutePathToDiffInfo;
    })

    /**
     * Calls out to asyncExecute using the 'hg' command.
     * @param options as specified by http://nodejs.org/api/child_process.html. Additional options:
     *   - NO_HGPLAIN set if the $HGPLAIN environment variable should not be used.
     *   - TTY_OUTPUT set if the command should be run as if it were attached to a tty.
     */
  }, {
    key: '_hgAsyncExecute',
    value: _asyncToGenerator(function* (args, options) {
      if (!options['NO_HGPLAIN']) {
        // Setting HGPLAIN=1 overrides any custom aliases a user has defined.
        if (options.env) {
          options.env['HGPLAIN'] = 1;
        } else {
          var assign = require('nuclide-commons').object.assign;

          var env = { 'HGPLAIN': 1 };
          assign(env, process.env);
          options.env = env;
        }
      }

      var cmd = undefined;
      if (options['TTY_OUTPUT']) {
        cmd = 'script';
        args = (0, _nuclideCommons.createArgsForScriptCommand)('hg', args);
      } else {
        cmd = 'hg';
      }
      try {
        return yield (0, _nuclideCommons.asyncExecute)(cmd, args, options);
      } catch (e) {
        getLogger().error('Error executing hg command: ' + JSON.stringify(args) + ' ' + ('options: ' + JSON.stringify(options) + ' ' + JSON.stringify(e)));
        throw e;
      }
    })
  }, {
    key: 'fetchCurrentBookmark',
    value: function fetchCurrentBookmark() {
      var _require = require('./hg-bookmark-helpers');

      var fetchCurrentBookmark = _require.fetchCurrentBookmark;

      return fetchCurrentBookmark(_path2['default'].join(this._workingDirectory, '.hg'));
    }

    /**
     * See HgService:.def:observeHgBookmarkDidChange for details.
     */
  }, {
    key: 'observeHgBookmarkDidChange',
    value: function observeHgBookmarkDidChange() {
      return this._hgBookmarkDidChangeObserver;
    }

    /**
     * Section: Repository State at Specific Revisions
     */

  }, {
    key: 'fetchFileContentAtRevision',
    value: function fetchFileContentAtRevision(filePath, revision) {
      return (0, _hgRevisionStateHelpers.fetchFileContentAtRevision)(filePath, revision, this._workingDirectory);
    }
  }, {
    key: 'fetchFilesChangedAtRevision',
    value: function fetchFilesChangedAtRevision(revision) {
      return (0, _hgRevisionStateHelpers.fetchFilesChangedAtRevision)(revision, this._workingDirectory);
    }
  }, {
    key: 'fetchRevisionInfoBetweenHeadAndBase',
    value: _asyncToGenerator(function* () {
      var commonAncestorRevision = yield (0, _hgRevisionExpressionHelpers.fetchCommonAncestorOfHeadAndRevision)(
      // TODO(most): Better way to specify the fork/base that works with `fbsource`
      // and other mercurial configurations. t8769378
      FORK_BASE_BOOKMARK_NAME, this._workingDirectory);
      if (!commonAncestorRevision) {
        return null;
      }
      var revisionsInfo = yield (0, _hgRevisionExpressionHelpers.fetchRevisionInfoBetweenRevisions)(commonAncestorRevision, (0, _hgRevisionExpressionHelpers.expressionForRevisionsBeforeHead)(0), this._workingDirectory);
      return revisionsInfo;
    })
  }, {
    key: 'getBlameAtHead',
    value: _asyncToGenerator(function* (filePath) {
      var args = ['blame', '-r', 'wdir()', '-Tjson', '--changeset', '--user', '--line-number', filePath];
      var execOptions = {
        cwd: this.getWorkingDirectory()
      };
      var output = undefined;
      try {
        output = yield this._hgAsyncExecute(args, execOptions);
      } catch (e) {
        getLogger().error('LocalHgServiceBase failed to fetch blame for file: ' + filePath + '. Error: ' + e.stderr);
        return new Map();
      }
      return (0, _hgBlameOutputParser.parseHgBlameOutput)(output.stdout);
    })

    /**
     * This implementation relies on the "phabdiff" template being available as defined in:
     * https://bitbucket.org/facebook/hg-experimental/src/fbf23b3f96bade5986121a7c57d7400585d75f54/phabdiff.py.
     */
  }, {
    key: 'getDifferentialRevisionForChangeSetId',
    value: _asyncToGenerator(function* (changeSetId) {
      var args = ['log', '-T', '{phabdiff}\n', '--limit', '1', '--rev', changeSetId];
      var execOptions = {
        cwd: this.getWorkingDirectory()
      };
      try {
        var output = yield this._hgAsyncExecute(args, execOptions);
        var stdout = output.stdout.trim();
        return stdout ? stdout : null;
      } catch (e) {
        // This should not happen: `hg log` does not error even if it does not recognize the template.
        getLogger().error('Failed when trying to get differential revision for: ' + changeSetId);
        return null;
      }
    })

    // TODO (chenshen) The return type should be `AsyncExecuteRet` inf `HgService.def`, but flow
    // doesn't allow importing `.def` file unless we merge `HgService.def` to this file.
  }, {
    key: 'getSmartlog',
    value: _asyncToGenerator(function* (ttyOutput, concise) {
      // disable the pager extension so that 'hg sl' terminates. We can't just use
      // HGPLAIN because we have not found a way to get colored output when we do.
      var args = ['--config', 'extensions.pager=!', concise ? 'sl' : 'smartlog'];
      var execOptions = {
        cwd: this.getWorkingDirectory(),
        NO_HGPLAIN: concise, // `hg sl` is likely user-defined.
        TTY_OUTPUT: ttyOutput
      };
      return yield this._hgAsyncExecute(args, execOptions);
    })
  }, {
    key: 'checkout',
    value: _asyncToGenerator(function* (revision, create) {
      var options = {
        cwd: this.getWorkingDirectory()
      };
      try {
        yield this._hgAsyncExecute(['checkout', revision], options);
      } catch (e) {
        return false;
      }
      return true;
    })
  }]);

  return HgServiceBase;
})();

module.exports = HgServiceBase;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvSGdTZXJ2aWNlQmFzZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQVk2QixnQkFBZ0I7O2tCQUNYLElBQUk7O21DQUNMLDBCQUEwQjs7a0NBQ1gseUJBQXlCOzsyQ0FLbEUsa0NBQWtDOztzQ0FJbEMsNkJBQTZCOzs4QkFDbUIsaUJBQWlCOztvQkFDdkQsTUFBTTs7OztBQTFCdkIsV0FBVyxDQUFDOztBQStCWixJQUFNLHVCQUF1QixHQUFHLGVBQWUsQ0FBQzs7QUFFaEQsSUFBSSxNQUFNLFlBQUEsQ0FBQztBQUNYLFNBQVMsU0FBUyxHQUFHO0FBQ25CLE1BQUksQ0FBQyxNQUFNLEVBQUU7QUFDWCxVQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7R0FDakQ7QUFDRCxTQUFPLE1BQU0sQ0FBQztDQUNmOztJQUVLLGFBQWE7QUFPTixXQVBQLGFBQWEsQ0FPTCxnQkFBd0IsRUFBRTswQkFQbEMsYUFBYTs7QUFRZixRQUFJLENBQUMsaUJBQWlCLEdBQUcsZ0JBQWdCLENBQUM7QUFDMUMsUUFBSSxDQUFDLHVCQUF1QixHQUFHLFFBckNmLE9BQU8sRUFxQ3FCLENBQUM7QUFDN0MsUUFBSSxDQUFDLDhCQUE4QixHQUFHLFFBdEN0QixPQUFPLEVBc0M0QixDQUFDO0FBQ3BELFFBQUksQ0FBQyw2QkFBNkIsR0FBRyxRQXZDckIsT0FBTyxFQXVDMkIsQ0FBQztBQUNuRCxRQUFJLENBQUMsNEJBQTRCLEdBQUcsUUF4Q3BCLE9BQU8sRUF3QzBCLENBQUM7R0FDbkQ7O2VBYkcsYUFBYTs7NkJBZUosYUFBa0I7QUFDN0IsVUFBSSxDQUFDLHVCQUF1QixDQUFDLFdBQVcsRUFBRSxDQUFDO0FB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LENBQUMsSUFBSSxFQUFFLENBQUM7QUFDcEMsZUFBTyxNQUFNLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQztPQUMvQixDQUFDLE9BQU8sQ0FBQyxFQUFFOztBQUVWLGlCQUFTLEVBQUUsQ0FBQyxLQUFLLDJEQUF5RCxXQUFXLENBQUcsQ0FBQztBQUN6RixlQUFPLElBQUksQ0FBQztPQUNiO0tBQ0Y7Ozs7Ozs2QkFJZ0IsV0FBQyxTQUFrQixFQUFFLE9BQWdCLEVBQW1COzs7QUFHdkUsVUFBTSxJQUFJLEdBQUcsQ0FBQyxVQUFVLEVBQUUsb0JBQW9CLEVBQUUsT0FBTyxHQUFHLElBQUksR0FBRyxVQUFVLENBQUMsQ0FBQztBQUM3RSxVQUFNLFdBQVcsR0FBRztBQUNsQixXQUFHLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFO0FBQy9CLGtCQUFVLEVBQUUsT0FBTztBQUNuQixrQkFBVSxFQUFFLFNBQVM7T0FDdEIsQ0FBQztBQUNGLGFBQU8sTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztLQUN0RDs7OzZCQUVhLFdBQUMsUUFBZ0IsRUFBRSxNQUFlLEVBQW9CO0FBQ2xFLFVBQU0sT0FBTyxHQUFHO0FBQ2QsV0FBRyxFQUFFLElBQUksQ0FBQyxtQkFBbUIsRUFBRTtPQUNoQyxDQUFDO0FBQ0YsVUFBSTtBQUNGLGNBQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztPQUM3RCxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsZUFBTyxLQUFLLENBQUM7T0FDZDtBQUNELGFBQU8sSUFBSSxDQUFDO0tBQ2I7OztTQWpRRyxhQUFhOzs7QUFxUW5CLE1BQU0sQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvSGdTZXJ2aWNlQmFzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4vKiBAcHJvdmlkZXNNb2R1bGUgTG9jYWxIZ1NlcnZpY2VCYXNlICovXG5cbmltcG9ydCB7SGdTdGF0dXNPcHRpb259IGZyb20gJy4vaGctY29uc3RhbnRzJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgU3ViamVjdH0gZnJvbSAncngnO1xuaW1wb3J0IHtwYXJzZUhnQmxhbWVPdXRwdXR9IGZyb20gJy4vaGctYmxhbWUtb3V0cHV0LXBhcnNlcic7XG5pbXBvcnQge3BhcnNlTXVsdGlGaWxlSGdEaWZmVW5pZmllZE91dHB1dH0gZnJvbSAnLi9oZy1kaWZmLW91dHB1dC1wYXJzZXInO1xuaW1wb3J0IHtcbiAgZmV0Y2hDb21tb25BbmNlc3Rvck9mSGVhZEFuZFJldmlzaW9uLFxuICBleHByZXNzaW9uRm9yUmV2aXNpb25zQmVmb3JlSGVhZCxcbiAgZmV0Y2hSZXZpc2lvbkluZm9CZXR3ZWVuUmV2aXNpb25zLFxufSBmcm9tICcuL2hnLXJldmlzaW9uLWV4cHJlc3Npb24taGVscGVycyc7XG5pbXBvcnQge1xuICBmZXRjaEZpbGVDb250ZW50QXRSZXZpc2lvbixcbiAgZmV0Y2hGaWxlc0NoYW5nZWRBdFJldmlzaW9uLFxufSBmcm9tICcuL2hnLXJldmlzaW9uLXN0YXRlLWhlbHBlcnMnO1xuaW1wb3J0IHthc3luY0V4ZWN1dGUsIGNyZWF0ZUFyZ3NGb3JTY3JpcHRDb21tYW5kfSBmcm9tICdudWNsaWRlLWNvbW1vbnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB0eXBlIHtEaWZmSW5mbywgUmV2aXNpb25GaWxlQ2hhbmdlcywgU3RhdHVzQ29kZUlkVmFsdWUsIFJldmlzaW9uSW5mb30gZnJvbSAnLi9oZy1jb25zdGFudHMnO1xuaW1wb3J0IHR5cGUge051Y2xpZGVVcml9IGZyb20gJ251Y2xpZGUtcmVtb3RlLXVyaSc7XG5cbmNvbnN0IEZPUktfQkFTRV9CT09LTUFSS19OQU1FID0gJ3JlbW90ZS9tYXN0ZXInO1xuXG5sZXQgbG9nZ2VyO1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKCkge1xuICBpZiAoIWxvZ2dlcikge1xuICAgIGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xuICB9XG4gIHJldHVybiBsb2dnZXI7XG59XG5cbmNsYXNzIEhnU2VydmljZUJhc2Uge1xuICBfd29ya2luZ0RpcmVjdG9yeTogc3RyaW5nO1xuICBfZmlsZXNEaWRDaGFuZ2VPYnNlcnZlcjogU3ViamVjdDtcbiAgX2hnSWdub3JlRmlsZURpZENoYW5nZU9ic2VydmVyOiBTdWJqZWN0O1xuICBfaGdSZXBvU3RhdGVEaWRDaGFuZ2VPYnNlcnZlcjogU3ViamVjdDtcbiAgX2hnQm9va21hcmtEaWRDaGFuZ2VPYnNlcnZlcjogU3ViamVjdDtcblxuICBjb25zdHJ1Y3Rvcih3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcpIHtcbiAgICB0aGlzLl93b3JraW5nRGlyZWN0b3J5ID0gd29ya2luZ0RpcmVjdG9yeTtcbiAgICB0aGlzLl9maWxlc0RpZENoYW5nZU9ic2VydmVyID0gbmV3IFN1YmplY3QoKTtcbiAgICB0aGlzLl9oZ0lnbm9yZUZpbGVEaWRDaGFuZ2VPYnNlcnZlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5faGdSZXBvU3RhdGVEaWRDaGFuZ2VPYnNlcnZlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5faGdCb29rbWFya0RpZENoYW5nZU9ic2VydmVyID0gbmV3IFN1YmplY3QoKTtcbiAgfVxuXG4gIGFzeW5jIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fZmlsZXNEaWRDaGFuZ2VPYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgIHRoaXMuX2hnSWdub3JlRmlsZURpZENoYW5nZU9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgdGhpcy5faGdSZXBvU3RhdGVEaWRDaGFuZ2VPYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgIHRoaXMuX2hnQm9va21hcmtEaWRDaGFuZ2VPYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICB9XG5cbiAgZ2V0V29ya2luZ0RpcmVjdG9yeSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93b3JraW5nRGlyZWN0b3J5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBIZ1NlcnZpY2U6OmZldGNoU3RhdHVzZXMgZm9yIGRldGFpbHMuXG4gICAqL1xuICBhc3luYyBmZXRjaFN0YXR1c2VzKFxuICAgIGZpbGVQYXRoczogQXJyYXk8c3RyaW5nPixcbiAgICBvcHRpb25zOiA/YW55XG4gICk6IFByb21pc2U8TWFwPHN0cmluZywgU3RhdHVzQ29kZUlkVmFsdWU+PiB7XG4gICAgY29uc3Qgc3RhdHVzTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgbGV0IGFyZ3MgPSBbJ3N0YXR1cycsICctVGpzb24nXTtcbiAgICBpZiAob3B0aW9ucyAmJiAoJ2hnU3RhdHVzT3B0aW9uJyBpbiBvcHRpb25zKSkge1xuICAgICAgaWYgKG9wdGlvbnMuaGdTdGF0dXNPcHRpb24gPT09IEhnU3RhdHVzT3B0aW9uLk9OTFlfSUdOT1JFRCkge1xuICAgICAgICBhcmdzLnB1c2goJy0taWdub3JlZCcpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmhnU3RhdHVzT3B0aW9uID09PSBIZ1N0YXR1c09wdGlvbi5BTExfU1RBVFVTRVMpIHtcbiAgICAgICAgYXJncy5wdXNoKCctLWFsbCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBhcmdzID0gYXJncy5jb25jYXQoZmlsZVBhdGhzKTtcbiAgICBjb25zdCBleGVjT3B0aW9ucyA9IHtcbiAgICAgIGN3ZDogdGhpcy5nZXRXb3JraW5nRGlyZWN0b3J5KCksXG4gICAgfTtcbiAgICBsZXQgb3V0cHV0O1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQgPSBhd2FpdCB0aGlzLl9oZ0FzeW5jRXhlY3V0ZShhcmdzLCBleGVjT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHN0YXR1c01hcDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0dXNlcyA9IEpTT04ucGFyc2Uob3V0cHV0LnN0ZG91dCk7XG4gICAgc3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzKSA9PiB7XG4gICAgICBzdGF0dXNNYXAuc2V0KHRoaXMuX2Fic29sdXRpemUoc3RhdHVzLnBhdGgpLCBzdGF0dXMuc3RhdHVzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdHVzTWFwO1xuICB9XG5cbiAgLy8gTWVyY3VyaWFsIHJldHVybnMgYWxsIHBhdGhzIHJlbGF0aXZlIHRvIHRoZSByZXBvc2l0b3J5J3Mgd29ya2luZyBkaXJlY3RvcnkuXG4gIC8vIFRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYSBwYXRoIHJlbGF0aXZlIHRvIHRoZSB3b3JraW5nIGRpcmVjb3RyeSBpbnRvIGFuXG4gIC8vIGFic29sdXRlIHBhdGguXG4gIF9hYnNvbHV0aXplKHBhdGhSZWxhdGl2ZVRvV29ya2luZ0RpcmVjdG9yeTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMuX3dvcmtpbmdEaXJlY3RvcnksIHBhdGhSZWxhdGl2ZVRvV29ya2luZ0RpcmVjdG9yeSk7XG4gIH1cblxuICAvKipcbiAgICogU2VlIEhnU2VydmljZS5kZWY6Om9ic2VydmVGaWxlc0RpZENoYW5nZSBmb3IgZGV0YWlscy5cbiAgICovXG4gIG9ic2VydmVGaWxlc0RpZENoYW5nZSgpOiBPYnNlcnZhYmxlPEFycmF5PE51Y2xpZGVVcmk+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVzRGlkQ2hhbmdlT2JzZXJ2ZXI7XG4gIH1cblxuICAvKipcbiAgICogU2VlIEhnU2VydmljZS5kZWY6Om9ic2VydmVIZ0lnbm9yZUZpbGVEaWRDaGFuZ2UgZm9yIGRldGFpbHMuXG4gICAqL1xuICBvYnNlcnZlSGdJZ25vcmVGaWxlRGlkQ2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9oZ0lnbm9yZUZpbGVEaWRDaGFuZ2VPYnNlcnZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgSGdTZXJ2aWNlLmRlZjo6b2JzZXJ2ZUhnUmVwb1N0YXRlRGlkQ2hhbmdlIGZvciBkZXRhaWxzLlxuICAgKi9cbiAgb2JzZXJ2ZUhnUmVwb1N0YXRlRGlkQ2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9oZ1JlcG9TdGF0ZURpZENoYW5nZU9ic2VydmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBIZ1NlcnZpY2UuZGVmOjpmZXRjaERpZmZJbmZvRm9yUGF0aHMgZm9yIGRldGFpbHMuXG4gICAqL1xuICBhc3luYyBmZXRjaERpZmZJbmZvKFxuICAgIGZpbGVQYXRoczogQXJyYXk8TnVjbGlkZVVyaT4sXG4gICk6IFByb21pc2U8P01hcDxOdWNsaWRlVXJpLCBEaWZmSW5mbz4+XG4gIHtcbiAgICAvLyAnLS11bmlmaWVkIDAnIGdpdmVzIHVzIDAgbGluZXMgb2YgY29udGV4dCBhcm91bmQgZWFjaCBjaGFuZ2UgKHdlIGRvbid0XG4gICAgLy8gY2FyZSBhYm91dCB0aGUgY29udGV4dCkuXG4gICAgLy8gJy0tbm9wcmVmaXgnIG9taXRzIHRoZSBhLyBhbmQgYi8gcHJlZml4ZXMgZnJvbSBmaWxlbmFtZXMuXG4gICAgY29uc3QgYXJncyA9IFsnZGlmZicsICctLXVuaWZpZWQnLCAnMCcsICctLW5vcHJlZml4J10uY29uY2F0KGZpbGVQYXRocyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGN3ZDogdGhpcy5nZXRXb3JraW5nRGlyZWN0b3J5KCksXG4gICAgfTtcbiAgICBsZXQgb3V0cHV0O1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQgPSBhd2FpdCB0aGlzLl9oZ0FzeW5jRXhlY3V0ZShhcmdzLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBnZXRMb2dnZXIoKS5lcnJvcihcbiAgICAgICAgICBgRXJyb3Igd2hlbiBydW5uaW5nIGhnIGRpZmYgZm9yIHBhdGhzOiAke2ZpbGVQYXRoc30gXFxuXFx0RXJyb3I6ICR7ZS5zdGRlcnJ9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGF0aFRvRGlmZkluZm8gPSBwYXJzZU11bHRpRmlsZUhnRGlmZlVuaWZpZWRPdXRwdXQob3V0cHV0LnN0ZG91dCk7XG4gICAgY29uc3QgYWJzb2x1dGVQYXRoVG9EaWZmSW5mbyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtmaWxlUGF0aCwgZGlmZkluZm9dIG9mIHBhdGhUb0RpZmZJbmZvKSB7XG4gICAgICBhYnNvbHV0ZVBhdGhUb0RpZmZJbmZvLnNldCh0aGlzLl9hYnNvbHV0aXplKGZpbGVQYXRoKSwgZGlmZkluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gYWJzb2x1dGVQYXRoVG9EaWZmSW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBvdXQgdG8gYXN5bmNFeGVjdXRlIHVzaW5nIHRoZSAnaGcnIGNvbW1hbmQuXG4gICAqIEBwYXJhbSBvcHRpb25zIGFzIHNwZWNpZmllZCBieSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvY2hpbGRfcHJvY2Vzcy5odG1sLiBBZGRpdGlvbmFsIG9wdGlvbnM6XG4gICAqICAgLSBOT19IR1BMQUlOIHNldCBpZiB0aGUgJEhHUExBSU4gZW52aXJvbm1lbnQgdmFyaWFibGUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKiAgIC0gVFRZX09VVFBVVCBzZXQgaWYgdGhlIGNvbW1hbmQgc2hvdWxkIGJlIHJ1biBhcyBpZiBpdCB3ZXJlIGF0dGFjaGVkIHRvIGEgdHR5LlxuICAgKi9cbiAgYXN5bmMgX2hnQXN5bmNFeGVjdXRlKGFyZ3M6IEFycmF5PHN0cmluZz4sIG9wdGlvbnM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFvcHRpb25zWydOT19IR1BMQUlOJ10pIHtcbiAgICAgIC8vIFNldHRpbmcgSEdQTEFJTj0xIG92ZXJyaWRlcyBhbnkgY3VzdG9tIGFsaWFzZXMgYSB1c2VyIGhhcyBkZWZpbmVkLlxuICAgICAgaWYgKG9wdGlvbnMuZW52KSB7XG4gICAgICAgIG9wdGlvbnMuZW52WydIR1BMQUlOJ10gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qge2Fzc2lnbn0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKS5vYmplY3Q7XG4gICAgICAgIGNvbnN0IGVudiA9IHsnSEdQTEFJTic6IDF9O1xuICAgICAgICBhc3NpZ24oZW52LCBwcm9jZXNzLmVudik7XG4gICAgICAgIG9wdGlvbnMuZW52ID0gZW52O1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjbWQ7XG4gICAgaWYgKG9wdGlvbnNbJ1RUWV9PVVRQVVQnXSkge1xuICAgICAgY21kID0gJ3NjcmlwdCc7XG4gICAgICBhcmdzID0gY3JlYXRlQXJnc0ZvclNjcmlwdENvbW1hbmQoJ2hnJywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNtZCA9ICdoZyc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXN5bmNFeGVjdXRlKGNtZCwgYXJncywgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZ2V0TG9nZ2VyKCkuZXJyb3IoYEVycm9yIGV4ZWN1dGluZyBoZyBjb21tYW5kOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfSBgICtcbiAgICAgICAgICBgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX0gJHtKU09OLnN0cmluZ2lmeShlKX1gKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgZmV0Y2hDdXJyZW50Qm9va21hcmsoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB7ZmV0Y2hDdXJyZW50Qm9va21hcmt9ID0gcmVxdWlyZSgnLi9oZy1ib29rbWFyay1oZWxwZXJzJyk7XG4gICAgcmV0dXJuIGZldGNoQ3VycmVudEJvb2ttYXJrKHBhdGguam9pbih0aGlzLl93b3JraW5nRGlyZWN0b3J5LCAnLmhnJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBIZ1NlcnZpY2U6LmRlZjpvYnNlcnZlSGdCb29rbWFya0RpZENoYW5nZSBmb3IgZGV0YWlscy5cbiAgICovXG4gIG9ic2VydmVIZ0Jvb2ttYXJrRGlkQ2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9oZ0Jvb2ttYXJrRGlkQ2hhbmdlT2JzZXJ2ZXI7XG4gIH1cblxuICAvKipcbiAgICogU2VjdGlvbjogUmVwb3NpdG9yeSBTdGF0ZSBhdCBTcGVjaWZpYyBSZXZpc2lvbnNcbiAgICovXG5cbiAgZmV0Y2hGaWxlQ29udGVudEF0UmV2aXNpb24oZmlsZVBhdGg6IE51Y2xpZGVVcmksIHJldmlzaW9uOiA/c3RyaW5nKTogUHJvbWlzZTw/c3RyaW5nPiB7XG4gICAgcmV0dXJuIGZldGNoRmlsZUNvbnRlbnRBdFJldmlzaW9uKGZpbGVQYXRoLCByZXZpc2lvbiwgdGhpcy5fd29ya2luZ0RpcmVjdG9yeSk7XG4gIH1cblxuICBmZXRjaEZpbGVzQ2hhbmdlZEF0UmV2aXNpb24ocmV2aXNpb246IHN0cmluZyk6IFByb21pc2U8P1JldmlzaW9uRmlsZUNoYW5nZXM+IHtcbiAgICByZXR1cm4gZmV0Y2hGaWxlc0NoYW5nZWRBdFJldmlzaW9uKHJldmlzaW9uLCB0aGlzLl93b3JraW5nRGlyZWN0b3J5KTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoUmV2aXNpb25JbmZvQmV0d2VlbkhlYWRBbmRCYXNlKCk6IFByb21pc2U8P0FycmF5PFJldmlzaW9uSW5mbz4+IHtcbiAgICBjb25zdCBjb21tb25BbmNlc3RvclJldmlzaW9uID0gYXdhaXQgZmV0Y2hDb21tb25BbmNlc3Rvck9mSGVhZEFuZFJldmlzaW9uKFxuICAgICAgLy8gVE9ETyhtb3N0KTogQmV0dGVyIHdheSB0byBzcGVjaWZ5IHRoZSBmb3JrL2Jhc2UgdGhhdCB3b3JrcyB3aXRoIGBmYnNvdXJjZWBcbiAgICAgIC8vIGFuZCBvdGhlciBtZXJjdXJpYWwgY29uZmlndXJhdGlvbnMuIHQ4NzY5Mzc4XG4gICAgICBGT1JLX0JBU0VfQk9PS01BUktfTkFNRSxcbiAgICAgIHRoaXMuX3dvcmtpbmdEaXJlY3RvcnksXG4gICAgKTtcbiAgICBpZiAoIWNvbW1vbkFuY2VzdG9yUmV2aXNpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXZpc2lvbnNJbmZvID0gYXdhaXQgZmV0Y2hSZXZpc2lvbkluZm9CZXR3ZWVuUmV2aXNpb25zKFxuICAgICAgY29tbW9uQW5jZXN0b3JSZXZpc2lvbixcbiAgICAgIGV4cHJlc3Npb25Gb3JSZXZpc2lvbnNCZWZvcmVIZWFkKDApLFxuICAgICAgdGhpcy5fd29ya2luZ0RpcmVjdG9yeSxcbiAgICApO1xuICAgIHJldHVybiByZXZpc2lvbnNJbmZvO1xuICB9XG5cbiAgYXN5bmMgZ2V0QmxhbWVBdEhlYWQoZmlsZVBhdGg6IE51Y2xpZGVVcmkpOiBQcm9taXNlPE1hcDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgICBjb25zdCBhcmdzID1cbiAgICAgIFsnYmxhbWUnLCAnLXInLCAnd2RpcigpJywgJy1UanNvbicsICctLWNoYW5nZXNldCcsICctLXVzZXInLCAnLS1saW5lLW51bWJlcicsIGZpbGVQYXRoXTtcbiAgICBjb25zdCBleGVjT3B0aW9ucyA9IHtcbiAgICAgIGN3ZDogdGhpcy5nZXRXb3JraW5nRGlyZWN0b3J5KCksXG4gICAgfTtcbiAgICBsZXQgb3V0cHV0O1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQgPSBhd2FpdCB0aGlzLl9oZ0FzeW5jRXhlY3V0ZShhcmdzLCBleGVjT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZ2V0TG9nZ2VyKCkuZXJyb3IoXG4gICAgICAgICAgYExvY2FsSGdTZXJ2aWNlQmFzZSBmYWlsZWQgdG8gZmV0Y2ggYmxhbWUgZm9yIGZpbGU6ICR7ZmlsZVBhdGh9LiBFcnJvcjogJHtlLnN0ZGVycn1gKTtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUhnQmxhbWVPdXRwdXQob3V0cHV0LnN0ZG91dCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiByZWxpZXMgb24gdGhlIFwicGhhYmRpZmZcIiB0ZW1wbGF0ZSBiZWluZyBhdmFpbGFibGUgYXMgZGVmaW5lZCBpbjpcbiAgICogaHR0cHM6Ly9iaXRidWNrZXQub3JnL2ZhY2Vib29rL2hnLWV4cGVyaW1lbnRhbC9zcmMvZmJmMjNiM2Y5NmJhZGU1OTg2MTIxYTdjNTdkNzQwMDU4NWQ3NWY1NC9waGFiZGlmZi5weS5cbiAgICovXG4gIGFzeW5jIGdldERpZmZlcmVudGlhbFJldmlzaW9uRm9yQ2hhbmdlU2V0SWQoY2hhbmdlU2V0SWQ6IHN0cmluZyk6IFByb21pc2U8P3N0cmluZz4ge1xuICAgIGNvbnN0IGFyZ3MgPSBbJ2xvZycsICctVCcsICd7cGhhYmRpZmZ9XFxuJywgJy0tbGltaXQnLCAnMScsICctLXJldicsIGNoYW5nZVNldElkXTtcbiAgICBjb25zdCBleGVjT3B0aW9ucyA9IHtcbiAgICAgIGN3ZDogdGhpcy5nZXRXb3JraW5nRGlyZWN0b3J5KCksXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5faGdBc3luY0V4ZWN1dGUoYXJncywgZXhlY09wdGlvbnMpO1xuICAgICAgY29uc3Qgc3Rkb3V0ID0gb3V0cHV0LnN0ZG91dC50cmltKCk7XG4gICAgICByZXR1cm4gc3Rkb3V0ID8gc3Rkb3V0IDogbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOiBgaGcgbG9nYCBkb2VzIG5vdCBlcnJvciBldmVuIGlmIGl0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgdGVtcGxhdGUuXG4gICAgICBnZXRMb2dnZXIoKS5lcnJvcihgRmFpbGVkIHdoZW4gdHJ5aW5nIHRvIGdldCBkaWZmZXJlbnRpYWwgcmV2aXNpb24gZm9yOiAke2NoYW5nZVNldElkfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETyAoY2hlbnNoZW4pIFRoZSByZXR1cm4gdHlwZSBzaG91bGQgYmUgYEFzeW5jRXhlY3V0ZVJldGAgaW5mIGBIZ1NlcnZpY2UuZGVmYCwgYnV0IGZsb3dcbiAgLy8gZG9lc24ndCBhbGxvdyBpbXBvcnRpbmcgYC5kZWZgIGZpbGUgdW5sZXNzIHdlIG1lcmdlIGBIZ1NlcnZpY2UuZGVmYCB0byB0aGlzIGZpbGUuXG4gIGFzeW5jIGdldFNtYXJ0bG9nKHR0eU91dHB1dDogYm9vbGVhbiwgY29uY2lzZTogYm9vbGVhbik6IFByb21pc2U8T2JqZWN0PiB7XG4gICAgLy8gZGlzYWJsZSB0aGUgcGFnZXIgZXh0ZW5zaW9uIHNvIHRoYXQgJ2hnIHNsJyB0ZXJtaW5hdGVzLiBXZSBjYW4ndCBqdXN0IHVzZVxuICAgIC8vIEhHUExBSU4gYmVjYXVzZSB3ZSBoYXZlIG5vdCBmb3VuZCBhIHdheSB0byBnZXQgY29sb3JlZCBvdXRwdXQgd2hlbiB3ZSBkby5cbiAgICBjb25zdCBhcmdzID0gWyctLWNvbmZpZycsICdleHRlbnNpb25zLnBhZ2VyPSEnLCBjb25jaXNlID8gJ3NsJyA6ICdzbWFydGxvZyddO1xuICAgIGNvbnN0IGV4ZWNPcHRpb25zID0ge1xuICAgICAgY3dkOiB0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnkoKSxcbiAgICAgIE5PX0hHUExBSU46IGNvbmNpc2UsIC8vIGBoZyBzbGAgaXMgbGlrZWx5IHVzZXItZGVmaW5lZC5cbiAgICAgIFRUWV9PVVRQVVQ6IHR0eU91dHB1dCxcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9oZ0FzeW5jRXhlY3V0ZShhcmdzLCBleGVjT3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBjaGVja291dChyZXZpc2lvbjogc3RyaW5nLCBjcmVhdGU6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY3dkOiB0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnkoKSxcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9oZ0FzeW5jRXhlY3V0ZShbJ2NoZWNrb3V0JywgcmV2aXNpb25dLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIZ1NlcnZpY2VCYXNlO1xuIl19
