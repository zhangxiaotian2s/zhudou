function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _remoteServiceTransformer = require('./remote-service-transformer');

var _remoteServiceTransformer2 = _interopRequireDefault(_remoteServiceTransformer);

var _classPrefix = require('./class-prefix');

'use babel';

var babel = require('babel-core');
var fs = require('fs');
var mkdirp = require('mkdirp');
var path = require('path');
var parseServiceApiSync = require('./service-parser');

var TRANSPILED_FILE_FOLDER = path.join(__dirname, '../gen/');
var BABEL_HEADER = "'use babel';";

var transpiledFilePathsForDecorator = new Set();
var transpiledFilePathsForRemote = new Set();

function transpile(sourceFilePath, destFilePath, isDecorator) {
  var sourceCode = fs.readFileSync(sourceFilePath, 'utf8');

  // While transpiling Flow import, babel might insert some code at the top of file so that the
  // generated code won't start with `'use babel';` and failed to load into Atom accordingly.
  // To solve this problem, we remove the babel header before transpiling and add it back
  // to the generated code.
  if (!sourceCode.startsWith(BABEL_HEADER)) {
    throw new Error('Service source code should start with "\'use babel\';"');
  }

  sourceCode = sourceCode.substring(BABEL_HEADER.length);

  var code = babel.transform(sourceCode, {
    blacklist: ['es6.arrowFunctions', 'es6.classes', 'strict'],
    optional: ['es7.classProperties'],
    plugins: [(0, _remoteServiceTransformer2['default'])(sourceFilePath, isDecorator)]
  }).code;

  // Append `'use 6to5';` at beginning of code so it will be transpiled by babel.
  // Also append a newline at the end of code to make eslint happy.
  code = BABEL_HEADER + '\n' + code + '\n';

  mkdirp.sync(TRANSPILED_FILE_FOLDER);
  fs.writeFileSync(destFilePath, code);
}

/**
 * Generate and load remote implementation for service defined in serviceDefinitionFilePath.
 * Caution:
 *  1. Service definition class should have unique name.
 *  2. We put this function at main.js and it will try to resolve the path from current
 *     module's parent, which should be the caller module. If anyone move this function into its
 *     own file and require it from main.js, `module.parent` should be changed to
 *     `module.parent.parent` as there is another level of requirement.
 */
function requireRemoteServiceSync(serviceDefinitionFilePath, serviceName, isDecorator) {
  // Resolve serviceDefinitionFilePath based on the caller's module, and fallback to
  // this file's module in case module.parent doesn't exist (we are using repl).
  // Note that `require('module')._resolveFilename(path, module)` is equivelent to
  // `require.resolve(path)` under the context of given module.
  // $FlowFixMe
  var resolvedServiceDefinitionFilePath = require('module')._resolveFilename(serviceDefinitionFilePath, module.parent ? module.parent : module);

  var transpiledRemoteServiceFilePath = path.join(TRANSPILED_FILE_FOLDER, (0, _classPrefix.getClassPrefix)(isDecorator) + path.basename(resolvedServiceDefinitionFilePath));

  var transpiledFilePaths = isDecorator ? transpiledFilePathsForDecorator : transpiledFilePathsForRemote;
  if (!transpiledFilePaths.has(resolvedServiceDefinitionFilePath)) {
    transpile(resolvedServiceDefinitionFilePath, transpiledRemoteServiceFilePath, isDecorator);
    transpiledFilePaths.add(resolvedServiceDefinitionFilePath);
  }

  var serviceModule = require(transpiledRemoteServiceFilePath);
  return serviceModule[serviceName] || serviceModule;
}

module.exports = {
  parseServiceApiSync: parseServiceApiSync,
  requireRemoteServiceSync: requireRemoteServiceSync,
  transpile: transpile
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXIvbGliL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozt3Q0FVcUMsOEJBQThCOzs7OzJCQUN0QyxnQkFBZ0I7O0FBWDdDLFdBQVcsQ0FBQzs7QUFhWixJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDcEMsSUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pCLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNqQyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0IsSUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7QUFFeEQsSUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMvRCxJQUFNLFlBQVksR0FBRyxjQUFjLENBQUM7O0FBRXBDLElBQU0sK0JBQStCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNsRCxJQUFNLDRCQUE0QixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7O0FBRS9DLFNBQVMsU0FBUyxDQUFDLGNBQXNCLEVBQUUsWUFBb0IsRUFBRSxXQUFvQixFQUFRO0FBQzNGLE1BQUksVUFBVSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7QUFNekQsTUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUU7QUFDeEMsVUFBTSxJQUFJLEtBQUssMERBQXdELENBQUM7R0FDekU7O0FBRUQsWUFBVSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV2RCxNQUFJLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtBQUNyQyxhQUFTLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDO0FBQzFELFlBQVEsRUFBRSxDQUFDLHFCQUFxQixDQUFDO0FBQ2pDLFdBQU8sRUFBRSxDQUFDLDJDQUF5QixjQUFjLEVBQUUsV0FBVyxDQUFDLENBQUM7R0FDakUsQ0FBQyxDQUFDLElBQUksQ0FBQzs7OztBQUlSLE1BQUksR0FBRyxZQUFZLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7O0FBRXpDLFFBQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUNwQyxJQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztDQUN0Qzs7Ozs7Ozs7Ozs7QUFXRCxTQUFTLHdCQUF3QixDQUMvQix5QkFBaUMsRUFDakMsV0FBbUIsRUFDbkIsV0FBb0IsRUFDZjs7Ozs7O0FBTUwsTUFBTSxpQ0FBaUMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsZ0JBQWdCLENBQ3hFLHlCQUF5QixFQUN6QixNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUM7O0FBRTVDLE1BQU0sK0JBQStCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FDN0Msc0JBQXNCLEVBQ3RCLGlCQWxFRSxjQUFjLEVBa0VELFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsaUNBQWlDLENBQUMsQ0FBQyxDQUFDOztBQUVwRixNQUFNLG1CQUFtQixHQUFHLFdBQVcsR0FDbkMsK0JBQStCLEdBQy9CLDRCQUE0QixDQUFDO0FBQ2pDLE1BQUksQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsaUNBQWlDLENBQUMsRUFBRTtBQUMvRCxhQUFTLENBQUMsaUNBQWlDLEVBQUUsK0JBQStCLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDM0YsdUJBQW1CLENBQUMsR0FBRyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7R0FDNUQ7O0FBRUQsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLCtCQUErQixDQUFDLENBQUM7QUFDL0QsU0FBTyxhQUFhLENBQUMsV0FBVyxDQUFDLElBQUksYUFBYSxDQUFDO0NBQ3BEOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDZixxQkFBbUIsRUFBbkIsbUJBQW1CO0FBQ25CLDBCQUF3QixFQUF4Qix3QkFBd0I7QUFDeEIsV0FBUyxFQUFULFNBQVM7Q0FDVixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXIvbGliL21haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IGNyZWF0ZVNlcnZpY2VUcmFuc2Zvcm1lciBmcm9tICcuL3JlbW90ZS1zZXJ2aWNlLXRyYW5zZm9ybWVyJztcbmltcG9ydCB7Z2V0Q2xhc3NQcmVmaXh9IGZyb20gJy4vY2xhc3MtcHJlZml4JztcblxuY29uc3QgYmFiZWwgPSByZXF1aXJlKCdiYWJlbC1jb3JlJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBwYXJzZVNlcnZpY2VBcGlTeW5jID0gcmVxdWlyZSgnLi9zZXJ2aWNlLXBhcnNlcicpO1xuXG5jb25zdCBUUkFOU1BJTEVEX0ZJTEVfRk9MREVSID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2dlbi8nKTtcbmNvbnN0IEJBQkVMX0hFQURFUiA9IFwiJ3VzZSBiYWJlbCc7XCI7XG5cbmNvbnN0IHRyYW5zcGlsZWRGaWxlUGF0aHNGb3JEZWNvcmF0b3IgPSBuZXcgU2V0KCk7XG5jb25zdCB0cmFuc3BpbGVkRmlsZVBhdGhzRm9yUmVtb3RlID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiB0cmFuc3BpbGUoc291cmNlRmlsZVBhdGg6IHN0cmluZywgZGVzdEZpbGVQYXRoOiBzdHJpbmcsIGlzRGVjb3JhdG9yOiBib29sZWFuKTogdm9pZCB7XG4gIGxldCBzb3VyY2VDb2RlID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZUZpbGVQYXRoLCAndXRmOCcpO1xuXG4gIC8vIFdoaWxlIHRyYW5zcGlsaW5nIEZsb3cgaW1wb3J0LCBiYWJlbCBtaWdodCBpbnNlcnQgc29tZSBjb2RlIGF0IHRoZSB0b3Agb2YgZmlsZSBzbyB0aGF0IHRoZVxuICAvLyBnZW5lcmF0ZWQgY29kZSB3b24ndCBzdGFydCB3aXRoIGAndXNlIGJhYmVsJztgIGFuZCBmYWlsZWQgdG8gbG9hZCBpbnRvIEF0b20gYWNjb3JkaW5nbHkuXG4gIC8vIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgd2UgcmVtb3ZlIHRoZSBiYWJlbCBoZWFkZXIgYmVmb3JlIHRyYW5zcGlsaW5nIGFuZCBhZGQgaXQgYmFja1xuICAvLyB0byB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gIGlmICghc291cmNlQ29kZS5zdGFydHNXaXRoKEJBQkVMX0hFQURFUikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZpY2Ugc291cmNlIGNvZGUgc2hvdWxkIHN0YXJ0IHdpdGggXCIndXNlIGJhYmVsJztcImApO1xuICB9XG5cbiAgc291cmNlQ29kZSA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKEJBQkVMX0hFQURFUi5sZW5ndGgpO1xuXG4gIGxldCBjb2RlID0gYmFiZWwudHJhbnNmb3JtKHNvdXJjZUNvZGUsIHtcbiAgICBibGFja2xpc3Q6IFsnZXM2LmFycm93RnVuY3Rpb25zJywgJ2VzNi5jbGFzc2VzJywgJ3N0cmljdCddLFxuICAgIG9wdGlvbmFsOiBbJ2VzNy5jbGFzc1Byb3BlcnRpZXMnXSxcbiAgICBwbHVnaW5zOiBbY3JlYXRlU2VydmljZVRyYW5zZm9ybWVyKHNvdXJjZUZpbGVQYXRoLCBpc0RlY29yYXRvcildLFxuICB9KS5jb2RlO1xuXG4gIC8vIEFwcGVuZCBgJ3VzZSA2dG81JztgIGF0IGJlZ2lubmluZyBvZiBjb2RlIHNvIGl0IHdpbGwgYmUgdHJhbnNwaWxlZCBieSBiYWJlbC5cbiAgLy8gQWxzbyBhcHBlbmQgYSBuZXdsaW5lIGF0IHRoZSBlbmQgb2YgY29kZSB0byBtYWtlIGVzbGludCBoYXBweS5cbiAgY29kZSA9IEJBQkVMX0hFQURFUiArICdcXG4nICsgY29kZSArICdcXG4nO1xuXG4gIG1rZGlycC5zeW5jKFRSQU5TUElMRURfRklMRV9GT0xERVIpO1xuICBmcy53cml0ZUZpbGVTeW5jKGRlc3RGaWxlUGF0aCwgY29kZSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYW5kIGxvYWQgcmVtb3RlIGltcGxlbWVudGF0aW9uIGZvciBzZXJ2aWNlIGRlZmluZWQgaW4gc2VydmljZURlZmluaXRpb25GaWxlUGF0aC5cbiAqIENhdXRpb246XG4gKiAgMS4gU2VydmljZSBkZWZpbml0aW9uIGNsYXNzIHNob3VsZCBoYXZlIHVuaXF1ZSBuYW1lLlxuICogIDIuIFdlIHB1dCB0aGlzIGZ1bmN0aW9uIGF0IG1haW4uanMgYW5kIGl0IHdpbGwgdHJ5IHRvIHJlc29sdmUgdGhlIHBhdGggZnJvbSBjdXJyZW50XG4gKiAgICAgbW9kdWxlJ3MgcGFyZW50LCB3aGljaCBzaG91bGQgYmUgdGhlIGNhbGxlciBtb2R1bGUuIElmIGFueW9uZSBtb3ZlIHRoaXMgZnVuY3Rpb24gaW50byBpdHNcbiAqICAgICBvd24gZmlsZSBhbmQgcmVxdWlyZSBpdCBmcm9tIG1haW4uanMsIGBtb2R1bGUucGFyZW50YCBzaG91bGQgYmUgY2hhbmdlZCB0b1xuICogICAgIGBtb2R1bGUucGFyZW50LnBhcmVudGAgYXMgdGhlcmUgaXMgYW5vdGhlciBsZXZlbCBvZiByZXF1aXJlbWVudC5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVJlbW90ZVNlcnZpY2VTeW5jKFxuICBzZXJ2aWNlRGVmaW5pdGlvbkZpbGVQYXRoOiBzdHJpbmcsXG4gIHNlcnZpY2VOYW1lOiBzdHJpbmcsXG4gIGlzRGVjb3JhdG9yOiBib29sZWFuLFxuKTogYW55IHtcbiAgLy8gUmVzb2x2ZSBzZXJ2aWNlRGVmaW5pdGlvbkZpbGVQYXRoIGJhc2VkIG9uIHRoZSBjYWxsZXIncyBtb2R1bGUsIGFuZCBmYWxsYmFjayB0b1xuICAvLyB0aGlzIGZpbGUncyBtb2R1bGUgaW4gY2FzZSBtb2R1bGUucGFyZW50IGRvZXNuJ3QgZXhpc3QgKHdlIGFyZSB1c2luZyByZXBsKS5cbiAgLy8gTm90ZSB0aGF0IGByZXF1aXJlKCdtb2R1bGUnKS5fcmVzb2x2ZUZpbGVuYW1lKHBhdGgsIG1vZHVsZSlgIGlzIGVxdWl2ZWxlbnQgdG9cbiAgLy8gYHJlcXVpcmUucmVzb2x2ZShwYXRoKWAgdW5kZXIgdGhlIGNvbnRleHQgb2YgZ2l2ZW4gbW9kdWxlLlxuICAvLyAkRmxvd0ZpeE1lXG4gIGNvbnN0IHJlc29sdmVkU2VydmljZURlZmluaXRpb25GaWxlUGF0aCA9IHJlcXVpcmUoJ21vZHVsZScpLl9yZXNvbHZlRmlsZW5hbWUoXG4gICAgICBzZXJ2aWNlRGVmaW5pdGlvbkZpbGVQYXRoLFxuICAgICAgbW9kdWxlLnBhcmVudCA/IG1vZHVsZS5wYXJlbnQgOiBtb2R1bGUpO1xuXG4gIGNvbnN0IHRyYW5zcGlsZWRSZW1vdGVTZXJ2aWNlRmlsZVBhdGggPSBwYXRoLmpvaW4oXG4gICAgICBUUkFOU1BJTEVEX0ZJTEVfRk9MREVSLFxuICAgICAgZ2V0Q2xhc3NQcmVmaXgoaXNEZWNvcmF0b3IpICsgcGF0aC5iYXNlbmFtZShyZXNvbHZlZFNlcnZpY2VEZWZpbml0aW9uRmlsZVBhdGgpKTtcblxuICBjb25zdCB0cmFuc3BpbGVkRmlsZVBhdGhzID0gaXNEZWNvcmF0b3JcbiAgICA/IHRyYW5zcGlsZWRGaWxlUGF0aHNGb3JEZWNvcmF0b3JcbiAgICA6IHRyYW5zcGlsZWRGaWxlUGF0aHNGb3JSZW1vdGU7XG4gIGlmICghdHJhbnNwaWxlZEZpbGVQYXRocy5oYXMocmVzb2x2ZWRTZXJ2aWNlRGVmaW5pdGlvbkZpbGVQYXRoKSkge1xuICAgIHRyYW5zcGlsZShyZXNvbHZlZFNlcnZpY2VEZWZpbml0aW9uRmlsZVBhdGgsIHRyYW5zcGlsZWRSZW1vdGVTZXJ2aWNlRmlsZVBhdGgsIGlzRGVjb3JhdG9yKTtcbiAgICB0cmFuc3BpbGVkRmlsZVBhdGhzLmFkZChyZXNvbHZlZFNlcnZpY2VEZWZpbml0aW9uRmlsZVBhdGgpO1xuICB9XG5cbiAgY29uc3Qgc2VydmljZU1vZHVsZSA9IHJlcXVpcmUodHJhbnNwaWxlZFJlbW90ZVNlcnZpY2VGaWxlUGF0aCk7XG4gIHJldHVybiBzZXJ2aWNlTW9kdWxlW3NlcnZpY2VOYW1lXSB8fCBzZXJ2aWNlTW9kdWxlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VTZXJ2aWNlQXBpU3luYyxcbiAgcmVxdWlyZVJlbW90ZVNlcnZpY2VTeW5jLFxuICB0cmFuc3BpbGUsXG59O1xuIl19
