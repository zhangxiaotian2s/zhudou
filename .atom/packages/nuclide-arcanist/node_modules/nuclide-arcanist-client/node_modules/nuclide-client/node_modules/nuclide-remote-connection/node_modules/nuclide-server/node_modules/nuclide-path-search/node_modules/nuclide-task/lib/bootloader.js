Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

exports.createTask = createTask;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _events = require('events');

'use babel';

/**
 * Task creates and manages communication with another Node process. In addition
 * to executing ordinary .js files, the other Node process can also run .js files
 * under the Babel transpiler, so long as they have the `'use babel'` pragma
 * used in Atom.
 */

var _Task = (function () {
  function _Task() {
    var _this = this;

    _classCallCheck(this, _Task);

    this._id = 0;
    this._emitter = new _events.EventEmitter();
    var options = { silent: true }; // Needed so stdout/stderr are available.
    var child = this._child = require('child_process').fork(require('path').join(__dirname, '/bootstrap.js'), options);
    /*eslint-disable no-console*/
    var log = function log(buffer) {
      return console.log('TASK(' + child.pid + '): ' + buffer);
    };
    /*eslint-enable no-console*/
    child.stdout.on('data', log);
    child.stderr.on('data', log);
    // The Flow error on the following line is due to a bug in Flow:
    // https://github.com/facebook/flow/issues/428.
    child.on('message', function (response) {
      var id = response['id'];
      _this._emitter.emit(id, response);
    });
    child.on('error', log);
    child.send({
      action: 'bootstrap',
      transpiler: require.resolve('nuclide-node-transpiler')
    });

    var onExitCallback = function onExitCallback() {
      return child.kill();
    };
    process.on('exit', onExitCallback);
    child.on('exit', function () {
      process.removeListener('exit', onExitCallback);
    });
  }

  /**
   * Invokes a remote method that is specified as an export of a .js file.
   *
   * The absolute path to the .js file must be specified via the `file`
   * property. In practice, `require.resolve()` is helpful in producing this
   * path.
   *
   * If the .js file exports an object with multiple properties (rather than a
   * single function), the name of the property (that should correspond to a
   * function to invoke) must be specified via the `method` property.
   *
   * Any arguments to pass to the function must be specified via the `args`
   * property as an Array. (This property can be omitted if there are no args.)
   *
   * Note that both the args for the remote method, as well as the return type
   * of the remote method, must be JSON-serializable. (The return type of the
   * remote method can also be a Promise that resolves to a JSON-serializable
   * object.)
   *
   * @return Promise that resolves with the result of invoking the remote
   *     method. If an error is thrown, a rejected Promise will be returned
   *     instead.
   */

  _createClass(_Task, [{
    key: 'invokeRemoteMethod',
    value: function invokeRemoteMethod(params) {
      var _this2 = this;

      var requestId = (++this._id).toString(16);
      var request = {
        id: requestId,
        action: 'request',
        file: params.file,
        method: params.method,
        args: params.args
      };

      return new Promise(function (resolve, reject) {
        // Ensure the response listener is set up before the request is sent.
        _this2._emitter.once(requestId, function (response) {
          var err = response['error'];
          if (!err) {
            resolve(response['result']);
          } else {
            // Need to synthesize an Error object from its JSON representation.
            var error = new Error();
            error.message = err.message;
            error.stack = err.stack;
            reject(error);
          }
        });
        _this2._child.send(request);
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      if (this._child.connected) {
        this._child.kill();
      }
      this._emitter.removeAllListeners();
    }
  }]);

  return _Task;
})();

function createTask() {
  return new _Task();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXRhc2svbGliL2Jvb3Rsb2FkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQVcyQixRQUFROztBQVhuQyxXQUFXLENBQUM7Ozs7Ozs7OztJQXlCTixLQUFLO0FBS0UsV0FMUCxLQUFLLEdBS0s7OzswQkFMVixLQUFLOztBQU1QLFFBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ2IsUUFBSSxDQUFDLFFBQVEsR0FBRyxZQXJCWixZQUFZLEVBcUJrQixDQUFDO0FBQ25DLFFBQU0sT0FBTyxHQUFHLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQyxDQUFDO0FBQy9CLFFBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUMvQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsZUFBZSxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRXJFLFFBQU0sR0FBRyxHQUFHLFNBQU4sR0FBRyxDQUFHLE1BQU07YUFBSSxPQUFPLENBQUMsR0FBRyxXQUFTLEtBQUssQ0FBQyxHQUFHLFdBQU0sTUFBTSxDQUFHO0tBQUEsQ0FBQzs7QUFFbkUsU0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLFNBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQzs7O0FBRzdCLFNBQUssQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQUEsUUFBUSxFQUFJO0FBQzlCLFVBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQixZQUFLLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ2xDLENBQUMsQ0FBQztBQUNILFNBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLFNBQUssQ0FBQyxJQUFJLENBQUM7QUFDVCxZQUFNLEVBQUUsV0FBVztBQUNuQixnQkFBVSxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMseUJBQXlCLENBQUM7S0FDdkQsQ0FBQyxDQUFDOztBQUVILFFBQU0sY0FBYyxHQUFHLFNBQWpCLGNBQWM7YUFBUyxLQUFLLENBQUMsSUFBSSxFQUFFO0tBQUEsQ0FBQztBQUMxQyxXQUFPLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztBQUNuQyxTQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxZQUFNO0FBQ3JCLGFBQU8sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0tBQ2hELENBQUMsQ0FBQztHQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWpDRyxLQUFLOztXQTBEUyw0QkFBQyxNQUFnQyxFQUFnQjs7O0FBQ2pFLFVBQU0sU0FBUyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFBLENBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzVDLFVBQU0sT0FBTyxHQUFHO0FBQ2QsVUFBRSxFQUFFLFNBQVM7QUFDYixjQUFNLEVBQUUsU0FBUztBQUNqQixZQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7QUFDakIsY0FBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO0FBQ3JCLFlBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtPQUNsQixDQUFDOztBQUVGLGFBQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLOztBQUV0QyxlQUFLLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQUEsUUFBUSxFQUFJO0FBQ3hDLGNBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM5QixjQUFJLENBQUMsR0FBRyxFQUFFO0FBQ1IsbUJBQU8sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztXQUM3QixNQUFNOztBQUVMLGdCQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0FBQzFCLGlCQUFLLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUM7QUFDNUIsaUJBQUssQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQztBQUN4QixrQkFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1dBQ2Y7U0FDRixDQUFDLENBQUM7QUFDSCxlQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDM0IsQ0FBQyxDQUFDO0tBQ0o7OztXQUVNLG1CQUFHO0FBQ1IsVUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRTtBQUN6QixZQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO09BQ3BCO0FBQ0QsVUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0tBQ3BDOzs7U0EzRkcsS0FBSzs7O0FBZ0dKLFNBQVMsVUFBVSxHQUFTO0FBQ2pDLFNBQU8sSUFBSSxLQUFLLEVBQUUsQ0FBQztDQUNwQiIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS10YXNrL2xpYi9ib290bG9hZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ2V2ZW50cyc7XG5cbmV4cG9ydCB0eXBlIEludm9rZVJlbW90ZU1ldGhvZFBhcmFtcyA9IHtcbiAgZmlsZTogc3RyaW5nO1xuICBtZXRob2Q6ID9zdHJpbmc7XG4gIGFyZ3M6ID9BcnJheTxhbnk+O1xufTtcblxuLyoqXG4gKiBUYXNrIGNyZWF0ZXMgYW5kIG1hbmFnZXMgY29tbXVuaWNhdGlvbiB3aXRoIGFub3RoZXIgTm9kZSBwcm9jZXNzLiBJbiBhZGRpdGlvblxuICogdG8gZXhlY3V0aW5nIG9yZGluYXJ5IC5qcyBmaWxlcywgdGhlIG90aGVyIE5vZGUgcHJvY2VzcyBjYW4gYWxzbyBydW4gLmpzIGZpbGVzXG4gKiB1bmRlciB0aGUgQmFiZWwgdHJhbnNwaWxlciwgc28gbG9uZyBhcyB0aGV5IGhhdmUgdGhlIGAndXNlIGJhYmVsJ2AgcHJhZ21hXG4gKiB1c2VkIGluIEF0b20uXG4gKi9cbmNsYXNzIF9UYXNrIHtcbiAgX2lkOiBudW1iZXI7XG4gIF9lbWl0dGVyOiBFdmVudEVtaXR0ZXI7XG4gIF9jaGlsZDogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faWQgPSAwO1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtzaWxlbnQ6IHRydWV9OyAvLyBOZWVkZWQgc28gc3Rkb3V0L3N0ZGVyciBhcmUgYXZhaWxhYmxlLlxuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGQgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICAgLmZvcmsocmVxdWlyZSgncGF0aCcpLmpvaW4oX19kaXJuYW1lLCAnL2Jvb3RzdHJhcC5qcycpLCBvcHRpb25zKTtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUqL1xuICAgIGNvbnN0IGxvZyA9IGJ1ZmZlciA9PiBjb25zb2xlLmxvZyhgVEFTSygke2NoaWxkLnBpZH0pOiAke2J1ZmZlcn1gKTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tY29uc29sZSovXG4gICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgbG9nKTtcbiAgICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBsb2cpO1xuICAgIC8vIFRoZSBGbG93IGVycm9yIG9uIHRoZSBmb2xsb3dpbmcgbGluZSBpcyBkdWUgdG8gYSBidWcgaW4gRmxvdzpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDI4LlxuICAgIGNoaWxkLm9uKCdtZXNzYWdlJywgcmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgaWQgPSByZXNwb25zZVsnaWQnXTtcbiAgICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChpZCwgcmVzcG9uc2UpO1xuICAgIH0pO1xuICAgIGNoaWxkLm9uKCdlcnJvcicsIGxvZyk7XG4gICAgY2hpbGQuc2VuZCh7XG4gICAgICBhY3Rpb246ICdib290c3RyYXAnLFxuICAgICAgdHJhbnNwaWxlcjogcmVxdWlyZS5yZXNvbHZlKCdudWNsaWRlLW5vZGUtdHJhbnNwaWxlcicpLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25FeGl0Q2FsbGJhY2sgPSAoKSA9PiBjaGlsZC5raWxsKCk7XG4gICAgcHJvY2Vzcy5vbignZXhpdCcsIG9uRXhpdENhbGxiYWNrKTtcbiAgICBjaGlsZC5vbignZXhpdCcsICgpID0+IHtcbiAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbkV4aXRDYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyBhIHJlbW90ZSBtZXRob2QgdGhhdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwb3J0IG9mIGEgLmpzIGZpbGUuXG4gICAqXG4gICAqIFRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSAuanMgZmlsZSBtdXN0IGJlIHNwZWNpZmllZCB2aWEgdGhlIGBmaWxlYFxuICAgKiBwcm9wZXJ0eS4gSW4gcHJhY3RpY2UsIGByZXF1aXJlLnJlc29sdmUoKWAgaXMgaGVscGZ1bCBpbiBwcm9kdWNpbmcgdGhpc1xuICAgKiBwYXRoLlxuICAgKlxuICAgKiBJZiB0aGUgLmpzIGZpbGUgZXhwb3J0cyBhbiBvYmplY3Qgd2l0aCBtdWx0aXBsZSBwcm9wZXJ0aWVzIChyYXRoZXIgdGhhbiBhXG4gICAqIHNpbmdsZSBmdW5jdGlvbiksIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAodGhhdCBzaG91bGQgY29ycmVzcG9uZCB0byBhXG4gICAqIGZ1bmN0aW9uIHRvIGludm9rZSkgbXVzdCBiZSBzcGVjaWZpZWQgdmlhIHRoZSBgbWV0aG9kYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQW55IGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCB2aWEgdGhlIGBhcmdzYFxuICAgKiBwcm9wZXJ0eSBhcyBhbiBBcnJheS4gKFRoaXMgcHJvcGVydHkgY2FuIGJlIG9taXR0ZWQgaWYgdGhlcmUgYXJlIG5vIGFyZ3MuKVxuICAgKlxuICAgKiBOb3RlIHRoYXQgYm90aCB0aGUgYXJncyBmb3IgdGhlIHJlbW90ZSBtZXRob2QsIGFzIHdlbGwgYXMgdGhlIHJldHVybiB0eXBlXG4gICAqIG9mIHRoZSByZW1vdGUgbWV0aG9kLCBtdXN0IGJlIEpTT04tc2VyaWFsaXphYmxlLiAoVGhlIHJldHVybiB0eXBlIG9mIHRoZVxuICAgKiByZW1vdGUgbWV0aG9kIGNhbiBhbHNvIGJlIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgSlNPTi1zZXJpYWxpemFibGVcbiAgICogb2JqZWN0LilcbiAgICpcbiAgICogQHJldHVybiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSByZW1vdGVcbiAgICogICAgIG1ldGhvZC4gSWYgYW4gZXJyb3IgaXMgdGhyb3duLCBhIHJlamVjdGVkIFByb21pc2Ugd2lsbCBiZSByZXR1cm5lZFxuICAgKiAgICAgaW5zdGVhZC5cbiAgICovXG4gIGludm9rZVJlbW90ZU1ldGhvZChwYXJhbXM6IEludm9rZVJlbW90ZU1ldGhvZFBhcmFtcyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gKCsrdGhpcy5faWQpLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgaWQ6IHJlcXVlc3RJZCxcbiAgICAgIGFjdGlvbjogJ3JlcXVlc3QnLFxuICAgICAgZmlsZTogcGFyYW1zLmZpbGUsXG4gICAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG4gICAgICBhcmdzOiBwYXJhbXMuYXJncyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIEVuc3VyZSB0aGUgcmVzcG9uc2UgbGlzdGVuZXIgaXMgc2V0IHVwIGJlZm9yZSB0aGUgcmVxdWVzdCBpcyBzZW50LlxuICAgICAgdGhpcy5fZW1pdHRlci5vbmNlKHJlcXVlc3RJZCwgcmVzcG9uc2UgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSByZXNwb25zZVsnZXJyb3InXTtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlWydyZXN1bHQnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTmVlZCB0byBzeW50aGVzaXplIGFuIEVycm9yIG9iamVjdCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgIGVycm9yLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2hpbGQuc2VuZChyZXF1ZXN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NoaWxkLmNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fY2hpbGQua2lsbCgpO1xuICAgIH1cbiAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFRhc2sgPSBfVGFzaztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhc2soKTogVGFzayB7XG4gIHJldHVybiBuZXcgX1Rhc2soKTtcbn1cbiJdfQ==
