var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _nuclideServiceParser = require('nuclide-service-parser');

var _nuclideServerLibServiceframework = require('nuclide-server/lib/serviceframework');

var _nuclideServerLibServiceframework2 = _interopRequireDefault(_nuclideServerLibServiceframework);

var _ServiceLogger = require('./ServiceLogger');

var _ServiceLogger2 = _interopRequireDefault(_ServiceLogger);

'use babel';

var logger = require('nuclide-logging').getLogger();

var _require = require('nuclide-server/lib/config');

var loadConfigsOfServiceWithServiceFramework = _require.loadConfigsOfServiceWithServiceFramework;

var _require2 = require('nuclide-server/lib/service-manager');

var optionsToString = _require2.optionsToString;

var RemoteConnection = require('./RemoteConnection');

var _require3 = require('nuclide-remote-uri');

var isRemote = _require3.isRemote;
var getHostname = _require3.getHostname;

var serviceConfigs = loadConfigsOfServiceWithServiceFramework();
var newServices = _nuclideServerLibServiceframework2['default'].loadServicesConfig();

// A cache stores services in form of '$serviceName@$host:$options' => $serviceObject. A special
// case would be the local service, where the $host will be empty string.
var cachedServices = new Map();

RemoteConnection.onDidCloseRemoteConnection(function (connection) {
  for (var cacheEntry of cachedServices) {
    var _cacheEntry = _slicedToArray(cacheEntry, 2);

    var cacheKey = _cacheEntry[0];
    var serviceInstance = _cacheEntry[1];

    if (serviceInstance._connection === connection) {
      cachedServices['delete'](cacheKey);
    }
  }
});

/**
 * Get a remote v3 service by service name and remote connection.
 */
function getRemoteServiceByRemoteConnection(serviceName, connection) {
  var _newServices$filter = newServices.filter(function (config) {
    return config.name === serviceName;
  });

  var _newServices$filter2 = _slicedToArray(_newServices$filter, 1);

  var serviceConfig = _newServices$filter2[0];

  if (serviceConfig) {
    return (0, _nuclideServiceParser.getProxy)(serviceConfig.name, serviceConfig.definition, connection.getClient());
  } else {
    logger.error('Service %s undefined.', serviceName);
    return null;
  }
}

/**
 * Create or get a cached service with given serviceOptions.
 * @param nuclideUri It could either be either a local path or a remote path in form of
 *    `nuclide:$host:$port/$path`. The function will use the $host from remote path to
 *    create a remote service with given serviceOptions or create a local service if the
 *    uri is local path.
 */
function getServiceByNuclideUri(serviceName) {
  var nuclideUri = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var serviceOptions = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var hostname = nuclideUri && isRemote(nuclideUri) ? getHostname(nuclideUri) : null;
  return getService(serviceName, hostname, serviceOptions);
}

/**
 * Create or get a cached service with given serviceOptions. If hostname is null or empty string,
 * it returns a local service, otherwise a remote service will be returned. For the same host
 * serviceOptions, the same service instance will be returned.
 */
function getService(serviceName, hostname, serviceOptions) {
  /** First, try to find a 3.0 service */

  var _newServices$filter3 = newServices.filter(function (config) {
    return config.name === serviceName;
  });

  var _newServices$filter32 = _slicedToArray(_newServices$filter3, 1);

  var serviceConfig = _newServices$filter32[0];

  if (serviceConfig) {
    if (hostname) {
      var remoteConnection = RemoteConnection.getByHostnameAndPath(hostname, null);
      return (0, _nuclideServiceParser.getProxy)(serviceConfig.name, serviceConfig.definition, remoteConnection.getClient());
    } else {
      return require(serviceConfig.implementation);
    }
  }

  /** Then try to find a legacy service */

  var _serviceConfigs$filter = serviceConfigs.filter(function (config) {
    return config.name === serviceName;
  });

  var _serviceConfigs$filter2 = _slicedToArray(_serviceConfigs$filter, 1);

  serviceConfig = _serviceConfigs$filter2[0];

  if (!serviceConfig) {
    logger.error('Service %s undefined.', serviceName);
    return null;
  }

  var cacheKey = serviceName + '@' + (hostname ? hostname : '') + ':' + optionsToString(serviceOptions);

  if (cachedServices.has(cacheKey)) {
    return cachedServices.get(cacheKey);
  }

  serviceOptions = serviceOptions || {};

  var serviceInstance = undefined;
  if (hostname) {
    serviceInstance = createRemoteService(serviceConfig, hostname, serviceOptions);
  } else {
    serviceInstance = createLocalService(serviceConfig, serviceOptions);
  }
  cachedServices.set(cacheKey, serviceInstance);

  return serviceInstance;
}

function createRemoteService(serviceConfig, hostname, serviceOptions) {
  var _require4 = require('nuclide-service-transformer');

  var requireRemoteServiceSync = _require4.requireRemoteServiceSync;

  var remoteServiceClass = requireRemoteServiceSync(serviceConfig.definition, serviceConfig.name,
  /* isDecorator */false);
  var remoteConnection = RemoteConnection.getByHostnameAndPath(hostname, null);
  return new remoteServiceClass(remoteConnection, serviceOptions);
}

function createLocalService(serviceConfig, serviceOptions) {
  var serviceClass = require(serviceConfig.implementation);
  var serviceImplementation = new serviceClass(serviceOptions);

  var _require5 = require('nuclide-service-transformer');

  var requireRemoteServiceSync = _require5.requireRemoteServiceSync;

  var decorator = requireRemoteServiceSync(serviceConfig.definition, serviceConfig.name,
  /* isDecorator */true);
  return new decorator(serviceImplementation, getServiceLogger());
}

var serviceLogger = undefined;
function getServiceLogger() {
  if (!serviceLogger) {
    serviceLogger = new _ServiceLogger2['default']();
    serviceLogger.onNewItem(function (item) {
      // TODO(t8579744): Log these to a separate file. Note that whatever file is used should also
      // be included in bug reports.
      logger.debug('Service call:', item.service, item.method, item.isLocal, item.argInfo);
    });
  }
  return serviceLogger;
}

module.exports = {
  getService: getService,
  getServiceByNuclideUri: getServiceByNuclideUri,
  getServiceLogger: getServiceLogger,
  getRemoteServiceByRemoteConnection: getRemoteServiceByRemoteConnection
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1jb25uZWN0aW9uL2xpYi9zZXJ2aWNlLW1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O29DQWtCdUIsd0JBQXdCOztnREFDbEIscUNBQXFDOzs7OzZCQUN4QyxpQkFBaUI7Ozs7QUFwQjNDLFdBQVcsQ0FBQzs7QUFZWixJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7ZUFDSCxPQUFPLENBQUMsMkJBQTJCLENBQUM7O0lBQWhGLHdDQUF3QyxZQUF4Qyx3Q0FBd0M7O2dCQUNyQixPQUFPLENBQUMsb0NBQW9DLENBQUM7O0lBQWhFLGVBQWUsYUFBZixlQUFlOztBQUN0QixJQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOztnQkFDdkIsT0FBTyxDQUFDLG9CQUFvQixDQUFDOztJQUF0RCxRQUFRLGFBQVIsUUFBUTtJQUFFLFdBQVcsYUFBWCxXQUFXOztBQU01QixJQUFNLGNBQWMsR0FBRyx3Q0FBd0MsRUFBRSxDQUFDO0FBQ2xFLElBQU0sV0FBVyxHQUFHLDhDQUFpQixrQkFBa0IsRUFBRSxDQUFDOzs7O0FBSTFELElBQU0sY0FBZ0MsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDOztBQUVuRCxnQkFBZ0IsQ0FBQywwQkFBMEIsQ0FBQyxVQUFDLFVBQVUsRUFBdUI7QUFDNUUsT0FBSyxJQUFNLFVBQVUsSUFBSSxjQUFjLEVBQUU7cUNBQ0gsVUFBVTs7UUFBdkMsUUFBUTtRQUFFLGVBQWU7O0FBQ2hDLFFBQUksZUFBZSxDQUFDLFdBQVcsS0FBSyxVQUFVLEVBQUU7QUFDOUMsb0JBQWMsVUFBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ2pDO0dBQ0Y7Q0FDRixDQUFDLENBQUM7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QUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3RGLENBQUMsQ0FBQztHQUNKO0FBQ0QsU0FBTyxhQUFhLENBQUM7Q0FDdEI7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNmLFlBQVUsRUFBVixVQUFVO0FBQ1Ysd0JBQXNCLEVBQXRCLHNCQUFzQjtBQUN0QixrQkFBZ0IsRUFBaEIsZ0JBQWdCO0FBQ2hCLG9DQUFrQyxFQUFsQyxrQ0FBa0M7Q0FDbkMsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1yZW1vdGUtY29ubmVjdGlvbi9saWIvc2VydmljZS1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCB0eXBlIEl0ZW0gZnJvbSAnLi9TZXJ2aWNlTG9nZ2VyJztcblxuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnbnVjbGlkZS1sb2dnaW5nJykuZ2V0TG9nZ2VyKCk7XG5jb25zdCB7bG9hZENvbmZpZ3NPZlNlcnZpY2VXaXRoU2VydmljZUZyYW1ld29ya30gPSByZXF1aXJlKCdudWNsaWRlLXNlcnZlci9saWIvY29uZmlnJyk7XG5jb25zdCB7b3B0aW9uc1RvU3RyaW5nfSA9IHJlcXVpcmUoJ251Y2xpZGUtc2VydmVyL2xpYi9zZXJ2aWNlLW1hbmFnZXInKTtcbmNvbnN0IFJlbW90ZUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL1JlbW90ZUNvbm5lY3Rpb24nKTtcbmNvbnN0IHtpc1JlbW90ZSwgZ2V0SG9zdG5hbWV9ID0gcmVxdWlyZSgnbnVjbGlkZS1yZW1vdGUtdXJpJyk7XG5cbmltcG9ydCB7Z2V0UHJveHl9IGZyb20gJ251Y2xpZGUtc2VydmljZS1wYXJzZXInO1xuaW1wb3J0IFNlcnZpY2VGcmFtZXdvcmsgZnJvbSAnbnVjbGlkZS1zZXJ2ZXIvbGliL3NlcnZpY2VmcmFtZXdvcmsnO1xuaW1wb3J0IFNlcnZpY2VMb2dnZXIgZnJvbSAnLi9TZXJ2aWNlTG9nZ2VyJztcblxuY29uc3Qgc2VydmljZUNvbmZpZ3MgPSBsb2FkQ29uZmlnc09mU2VydmljZVdpdGhTZXJ2aWNlRnJhbWV3b3JrKCk7XG5jb25zdCBuZXdTZXJ2aWNlcyA9IFNlcnZpY2VGcmFtZXdvcmsubG9hZFNlcnZpY2VzQ29uZmlnKCk7XG5cbi8vIEEgY2FjaGUgc3RvcmVzIHNlcnZpY2VzIGluIGZvcm0gb2YgJyRzZXJ2aWNlTmFtZUAkaG9zdDokb3B0aW9ucycgPT4gJHNlcnZpY2VPYmplY3QuIEEgc3BlY2lhbFxuLy8gY2FzZSB3b3VsZCBiZSB0aGUgbG9jYWwgc2VydmljZSwgd2hlcmUgdGhlICRob3N0IHdpbGwgYmUgZW1wdHkgc3RyaW5nLlxuY29uc3QgY2FjaGVkU2VydmljZXM6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwKCk7XG5cblJlbW90ZUNvbm5lY3Rpb24ub25EaWRDbG9zZVJlbW90ZUNvbm5lY3Rpb24oKGNvbm5lY3Rpb246IFJlbW90ZUNvbm5lY3Rpb24pID0+IHtcbiAgZm9yIChjb25zdCBjYWNoZUVudHJ5IG9mIGNhY2hlZFNlcnZpY2VzKSB7XG4gICAgY29uc3QgW2NhY2hlS2V5LCBzZXJ2aWNlSW5zdGFuY2VdID0gY2FjaGVFbnRyeTtcbiAgICBpZiAoc2VydmljZUluc3RhbmNlLl9jb25uZWN0aW9uID09PSBjb25uZWN0aW9uKSB7XG4gICAgICBjYWNoZWRTZXJ2aWNlcy5kZWxldGUoY2FjaGVLZXkpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IGEgcmVtb3RlIHYzIHNlcnZpY2UgYnkgc2VydmljZSBuYW1lIGFuZCByZW1vdGUgY29ubmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVtb3RlU2VydmljZUJ5UmVtb3RlQ29ubmVjdGlvbihcbiAgc2VydmljZU5hbWU6IHN0cmluZyxcbiAgY29ubmVjdGlvbjogUmVtb3RlQ29ubmVjdGlvbixcbik6ID9hbnkge1xuICBjb25zdCBbc2VydmljZUNvbmZpZ10gPSBuZXdTZXJ2aWNlcy5maWx0ZXIoY29uZmlnID0+IGNvbmZpZy5uYW1lID09PSBzZXJ2aWNlTmFtZSk7XG4gIGlmIChzZXJ2aWNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGdldFByb3h5KHNlcnZpY2VDb25maWcubmFtZSwgc2VydmljZUNvbmZpZy5kZWZpbml0aW9uLCBjb25uZWN0aW9uLmdldENsaWVudCgpKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIuZXJyb3IoJ1NlcnZpY2UgJXMgdW5kZWZpbmVkLicsIHNlcnZpY2VOYW1lKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBvciBnZXQgYSBjYWNoZWQgc2VydmljZSB3aXRoIGdpdmVuIHNlcnZpY2VPcHRpb25zLlxuICogQHBhcmFtIG51Y2xpZGVVcmkgSXQgY291bGQgZWl0aGVyIGJlIGVpdGhlciBhIGxvY2FsIHBhdGggb3IgYSByZW1vdGUgcGF0aCBpbiBmb3JtIG9mXG4gKiAgICBgbnVjbGlkZTokaG9zdDokcG9ydC8kcGF0aGAuIFRoZSBmdW5jdGlvbiB3aWxsIHVzZSB0aGUgJGhvc3QgZnJvbSByZW1vdGUgcGF0aCB0b1xuICogICAgY3JlYXRlIGEgcmVtb3RlIHNlcnZpY2Ugd2l0aCBnaXZlbiBzZXJ2aWNlT3B0aW9ucyBvciBjcmVhdGUgYSBsb2NhbCBzZXJ2aWNlIGlmIHRoZVxuICogICAgdXJpIGlzIGxvY2FsIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGdldFNlcnZpY2VCeU51Y2xpZGVVcmkoXG4gIHNlcnZpY2VOYW1lOiBzdHJpbmcsXG4gIG51Y2xpZGVVcmk6ID9OdWNsaWRlVXJpID0gbnVsbCxcbiAgc2VydmljZU9wdGlvbnM6ID9hbnkgPSBudWxsXG4pOiA/YW55IHtcbiAgY29uc3QgaG9zdG5hbWUgPSAobnVjbGlkZVVyaSAmJiBpc1JlbW90ZShudWNsaWRlVXJpKSkgP1xuICAgIGdldEhvc3RuYW1lKG51Y2xpZGVVcmkpIDpcbiAgICBudWxsO1xuICByZXR1cm4gZ2V0U2VydmljZShzZXJ2aWNlTmFtZSwgaG9zdG5hbWUsIHNlcnZpY2VPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgb3IgZ2V0IGEgY2FjaGVkIHNlcnZpY2Ugd2l0aCBnaXZlbiBzZXJ2aWNlT3B0aW9ucy4gSWYgaG9zdG5hbWUgaXMgbnVsbCBvciBlbXB0eSBzdHJpbmcsXG4gKiBpdCByZXR1cm5zIGEgbG9jYWwgc2VydmljZSwgb3RoZXJ3aXNlIGEgcmVtb3RlIHNlcnZpY2Ugd2lsbCBiZSByZXR1cm5lZC4gRm9yIHRoZSBzYW1lIGhvc3RcbiAqIHNlcnZpY2VPcHRpb25zLCB0aGUgc2FtZSBzZXJ2aWNlIGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFNlcnZpY2Uoc2VydmljZU5hbWU6IHN0cmluZywgaG9zdG5hbWU6ID9zdHJpbmcsIHNlcnZpY2VPcHRpb25zOiA/YW55KTogP2FueSB7XG4gIC8qKiBGaXJzdCwgdHJ5IHRvIGZpbmQgYSAzLjAgc2VydmljZSAqL1xuICBsZXQgW3NlcnZpY2VDb25maWddID0gbmV3U2VydmljZXMuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcubmFtZSA9PT0gc2VydmljZU5hbWUpO1xuICBpZiAoc2VydmljZUNvbmZpZykge1xuICAgIGlmIChob3N0bmFtZSkge1xuICAgICAgY29uc3QgcmVtb3RlQ29ubmVjdGlvbiA9IFJlbW90ZUNvbm5lY3Rpb24uZ2V0QnlIb3N0bmFtZUFuZFBhdGgoaG9zdG5hbWUsIG51bGwpO1xuICAgICAgcmV0dXJuIGdldFByb3h5KHNlcnZpY2VDb25maWcubmFtZSwgc2VydmljZUNvbmZpZy5kZWZpbml0aW9uLCByZW1vdGVDb25uZWN0aW9uLmdldENsaWVudCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoc2VydmljZUNvbmZpZy5pbXBsZW1lbnRhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZW4gdHJ5IHRvIGZpbmQgYSBsZWdhY3kgc2VydmljZSAqL1xuICBbc2VydmljZUNvbmZpZ10gPSBzZXJ2aWNlQ29uZmlncy5maWx0ZXIoY29uZmlnID0+IGNvbmZpZy5uYW1lID09PSBzZXJ2aWNlTmFtZSk7XG4gIGlmICghc2VydmljZUNvbmZpZykge1xuICAgIGxvZ2dlci5lcnJvcignU2VydmljZSAlcyB1bmRlZmluZWQuJywgc2VydmljZU5hbWUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgY2FjaGVLZXkgPSBzZXJ2aWNlTmFtZSArICdAJyArIChob3N0bmFtZSA/IGhvc3RuYW1lIDogJycpICsgJzonICsgb3B0aW9uc1RvU3RyaW5nKHNlcnZpY2VPcHRpb25zKTtcblxuICBpZiAoY2FjaGVkU2VydmljZXMuaGFzKGNhY2hlS2V5KSkge1xuICAgIHJldHVybiBjYWNoZWRTZXJ2aWNlcy5nZXQoY2FjaGVLZXkpO1xuICB9XG5cbiAgc2VydmljZU9wdGlvbnMgPSBzZXJ2aWNlT3B0aW9ucyB8fCB7fTtcblxuICBsZXQgc2VydmljZUluc3RhbmNlO1xuICBpZiAoaG9zdG5hbWUpIHtcbiAgICBzZXJ2aWNlSW5zdGFuY2UgPSBjcmVhdGVSZW1vdGVTZXJ2aWNlKHNlcnZpY2VDb25maWcsIGhvc3RuYW1lLCBzZXJ2aWNlT3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VydmljZUluc3RhbmNlID0gY3JlYXRlTG9jYWxTZXJ2aWNlKHNlcnZpY2VDb25maWcsIHNlcnZpY2VPcHRpb25zKTtcbiAgfVxuICBjYWNoZWRTZXJ2aWNlcy5zZXQoY2FjaGVLZXksIHNlcnZpY2VJbnN0YW5jZSk7XG5cbiAgcmV0dXJuIHNlcnZpY2VJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlU2VydmljZShzZXJ2aWNlQ29uZmlnOiBTZXJ2aWNlQ29uZmlnLCBob3N0bmFtZTogc3RyaW5nLCBzZXJ2aWNlT3B0aW9uczogYW55KTogYW55IHtcbiAgY29uc3Qge3JlcXVpcmVSZW1vdGVTZXJ2aWNlU3luY30gPSByZXF1aXJlKCdudWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXInKTtcbiAgY29uc3QgcmVtb3RlU2VydmljZUNsYXNzID0gcmVxdWlyZVJlbW90ZVNlcnZpY2VTeW5jKFxuICAgIHNlcnZpY2VDb25maWcuZGVmaW5pdGlvbixcbiAgICBzZXJ2aWNlQ29uZmlnLm5hbWUsXG4gICAgLyogaXNEZWNvcmF0b3IgKi8gZmFsc2UpO1xuICBjb25zdCByZW1vdGVDb25uZWN0aW9uID0gUmVtb3RlQ29ubmVjdGlvbi5nZXRCeUhvc3RuYW1lQW5kUGF0aChob3N0bmFtZSwgbnVsbCk7XG4gIHJldHVybiBuZXcgcmVtb3RlU2VydmljZUNsYXNzKHJlbW90ZUNvbm5lY3Rpb24sIHNlcnZpY2VPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxTZXJ2aWNlKHNlcnZpY2VDb25maWc6IFNlcnZpY2VDb25maWcsIHNlcnZpY2VPcHRpb25zOiBhbnkpOiBhbnkge1xuICBjb25zdCBzZXJ2aWNlQ2xhc3MgPSByZXF1aXJlKHNlcnZpY2VDb25maWcuaW1wbGVtZW50YXRpb24pO1xuICBjb25zdCBzZXJ2aWNlSW1wbGVtZW50YXRpb24gPSBuZXcgc2VydmljZUNsYXNzKHNlcnZpY2VPcHRpb25zKTtcbiAgY29uc3Qge3JlcXVpcmVSZW1vdGVTZXJ2aWNlU3luY30gPSByZXF1aXJlKCdudWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXInKTtcbiAgY29uc3QgZGVjb3JhdG9yID0gcmVxdWlyZVJlbW90ZVNlcnZpY2VTeW5jKFxuICAgIHNlcnZpY2VDb25maWcuZGVmaW5pdGlvbixcbiAgICBzZXJ2aWNlQ29uZmlnLm5hbWUsXG4gICAgLyogaXNEZWNvcmF0b3IgKi8gdHJ1ZSxcbiAgKTtcbiAgcmV0dXJuIG5ldyBkZWNvcmF0b3Ioc2VydmljZUltcGxlbWVudGF0aW9uLCBnZXRTZXJ2aWNlTG9nZ2VyKCkpO1xufVxuXG5sZXQgc2VydmljZUxvZ2dlcjogP1NlcnZpY2VMb2dnZXI7XG5mdW5jdGlvbiBnZXRTZXJ2aWNlTG9nZ2VyKCk6IFNlcnZpY2VMb2dnZXIge1xuICBpZiAoIXNlcnZpY2VMb2dnZXIpIHtcbiAgICBzZXJ2aWNlTG9nZ2VyID0gbmV3IFNlcnZpY2VMb2dnZXIoKTtcbiAgICBzZXJ2aWNlTG9nZ2VyLm9uTmV3SXRlbSgoaXRlbTogSXRlbSkgPT4ge1xuICAgICAgLy8gVE9ETyh0ODU3OTc0NCk6IExvZyB0aGVzZSB0byBhIHNlcGFyYXRlIGZpbGUuIE5vdGUgdGhhdCB3aGF0ZXZlciBmaWxlIGlzIHVzZWQgc2hvdWxkIGFsc29cbiAgICAgIC8vIGJlIGluY2x1ZGVkIGluIGJ1ZyByZXBvcnRzLlxuICAgICAgbG9nZ2VyLmRlYnVnKCdTZXJ2aWNlIGNhbGw6JywgaXRlbS5zZXJ2aWNlLCBpdGVtLm1ldGhvZCwgaXRlbS5pc0xvY2FsLCBpdGVtLmFyZ0luZm8pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZXJ2aWNlTG9nZ2VyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0U2VydmljZSxcbiAgZ2V0U2VydmljZUJ5TnVjbGlkZVVyaSxcbiAgZ2V0U2VydmljZUxvZ2dlcixcbiAgZ2V0UmVtb3RlU2VydmljZUJ5UmVtb3RlQ29ubmVjdGlvbixcbn07XG4iXX0=
