var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _atom = require('atom');

var _nuclideLogging = require('nuclide-logging');

var _nuclideRemoteUri = require('nuclide-remote-uri');

var _nuclideRemoteUri2 = _interopRequireDefault(_nuclideRemoteUri);

'use babel';

var logger = (0, _nuclideLogging.getLogger)();

var MARKER_PROPERTY_FOR_REMOTE_DIRECTORY = '__nuclide_remote_directory__';

/* Mostly implements https://atom.io/docs/api/latest/Directory */

var RemoteDirectory = (function () {
  _createClass(RemoteDirectory, null, [{
    key: 'isRemoteDirectory',
    value: function isRemoteDirectory(directory) {
      return directory[MARKER_PROPERTY_FOR_REMOTE_DIRECTORY] === true;
    }
  }]);

  /**
   * @param uri should be of the form "nuclide://example.com:9090/path/to/directory".
   */

  function RemoteDirectory(remote, uri, options) {
    _classCallCheck(this, RemoteDirectory);

    Object.defineProperty(this, MARKER_PROPERTY_FOR_REMOTE_DIRECTORY, { value: true });
    this._remote = remote;
    this._uri = uri;
    this._emitter = new _atom.Emitter();
    this._subscriptionCount = 0;

    var _remoteUri$parse = _nuclideRemoteUri2['default'].parse(uri);

    var directoryPath = _remoteUri$parse.path;
    var protocol = _remoteUri$parse.protocol;
    var host = _remoteUri$parse.host;

    (0, _assert2['default'])(protocol);
    (0, _assert2['default'])(host);
    /** In the example, this would be "nuclide://example.com:9090". */
    this._host = protocol + '//' + host;
    /** In the example, this would be "/path/to/directory". */
    this._localPath = directoryPath;
    // A workaround before Atom 2.0: see ::getHgRepoInfo of main.js.
    this._hgRepositoryDescription = options ? options.hgRepositoryDescription : null;
  }

  _createClass(RemoteDirectory, [{
    key: 'onDidChange',
    value: function onDidChange(callback) {
      this._willAddSubscription();
      return this._trackUnsubscription(this._emitter.on('did-change', callback));
    }
  }, {
    key: '_willAddSubscription',
    value: function _willAddSubscription() {
      this._subscriptionCount++;
      try {
        this._subscribeToNativeChangeEvents();
      } catch (err) {
        logger.error('Failed to subscribe RemoteDirectory:', this._localPath, err);
      }
    }
  }, {
    key: '_subscribeToNativeChangeEvents',
    value: function _subscribeToNativeChangeEvents() {
      var _this = this;

      if (this._watchSubscription) {
        return;
      }

      var _getService2 = this._getService('FileWatcherService');

      var watchDirectory = _getService2.watchDirectory;

      var watchStream = watchDirectory(this._uri);
      this._watchSubscription = watchStream.subscribe(function (watchUpdate) {
        logger.debug('watchDirectory update:', watchUpdate);
        if (watchUpdate.type === 'change') {
          return _this._handleNativeChangeEvent();
        }
      }, function (error) {
        logger.error('Failed to subscribe RemoteDirectory:', _this._uri, error);
      }, function () {
        // Nothing needs to be done if the root directory watch has ended.
        logger.debug('watchDirectory ended: ' + _this._uri);
      });
    }
  }, {
    key: '_handleNativeChangeEvent',
    value: function _handleNativeChangeEvent() {
      this._emitter.emit('did-change');
    }
  }, {
    key: '_trackUnsubscription',
    value: function _trackUnsubscription(subscription) {
      var _this2 = this;

      return new _atom.Disposable(function () {
        subscription.dispose();
        _this2._didRemoveSubscription();
      });
    }
  }, {
    key: '_didRemoveSubscription',
    value: function _didRemoveSubscription() {
      this._subscriptionCount--;
      if (this._subscriptionCount === 0) {
        return this._unsubscribeFromNativeChangeEvents();
      }
    }
  }, {
    key: '_unsubscribeFromNativeChangeEvents',
    value: function _unsubscribeFromNativeChangeEvents() {
      if (this._watchSubscription) {
        this._watchSubscription.dispose();
        this._watchSubscription = null;
      }
    }
  }, {
    key: 'isFile',
    value: function isFile() {
      return false;
    }
  }, {
    key: 'isDirectory',
    value: function isDirectory() {
      return true;
    }
  }, {
    key: 'isRoot',
    value: function isRoot() {
      return this._isRoot(this._localPath);
    }
  }, {
    key: 'existsSync',
    value: function existsSync() {
      return false;
    }
  }, {
    key: '_isRoot',
    value: function _isRoot(filePath) {
      filePath = _path2['default'].normalize(filePath);
      var parts = _path2['default'].parse(filePath);
      return parts.root === filePath;
    }
  }, {
    key: 'getPath',
    value: function getPath() {
      return this._uri;
    }
  }, {
    key: 'getLocalPath',
    value: function getLocalPath() {
      return this._localPath;
    }
  }, {
    key: 'getHost',
    value: function getHost() {
      return this._host;
    }
  }, {
    key: 'getRealPathSync',
    value: function getRealPathSync() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getBaseName',
    value: function getBaseName() {
      return _path2['default'].basename(this._localPath);
    }
  }, {
    key: 'relativize',
    value: function relativize(uri) {
      if (!uri) {
        return uri;
      }
      // Note: host of uri must match this._host.
      var subpath = _nuclideRemoteUri2['default'].parse(uri).path;
      return _path2['default'].relative(this._localPath, subpath);
    }
  }, {
    key: 'getParent',
    value: function getParent() {
      if (this.isRoot()) {
        return this;
      } else {
        var uri = this._host + _path2['default'].normalize(_path2['default'].join(this._localPath, '..'));
        return this._remote.createDirectory(uri);
      }
    }
  }, {
    key: 'getFile',
    value: function getFile(filename) {
      var uri = this._host + _path2['default'].join(this._localPath, filename);
      return this._remote.createFile(uri);
    }
  }, {
    key: 'getSubdirectory',
    value: function getSubdirectory(dirname) {
      var uri = this._host + _path2['default'].join(this._localPath, dirname);
      return this._remote.createDirectory(uri);
    }
  }, {
    key: 'create',
    value: _asyncToGenerator(function* () {
      var created = yield this._getFileSystemService().mkdirp(this._localPath);
      if (this._subscriptionCount > 0) {
        this._subscribeToNativeChangeEvents();
      }
      return created;
    })
  }, {
    key: 'delete',
    value: _asyncToGenerator(function* () {
      yield this._getFileSystemService().rmdir(this._localPath);
      this._unsubscribeFromNativeChangeEvents();
    })

    /**
     * Renames this directory to the given absolute path.
     */
  }, {
    key: 'rename',
    value: _asyncToGenerator(function* (newPath) {
      yield this._getFileSystemService().rename(this._localPath, newPath);

      // Unsubscribe from the old `this._localPath`. This must be done before
      // setting the new `this._localPath`.
      this._unsubscribeFromNativeChangeEvents();

      var _remoteUri$parse2 = _nuclideRemoteUri2['default'].parse(this._uri);

      var protocol = _remoteUri$parse2.protocol;
      var host = _remoteUri$parse2.host;

      this._localPath = newPath;
      (0, _assert2['default'])(protocol);
      (0, _assert2['default'])(host);
      this._uri = protocol + '//' + host + this._localPath;

      // Subscribe to changes for the new `this._localPath`. This must be done
      // after setting the new `this._localPath`.
      if (this._subscriptionCount > 0) {
        this._subscribeToNativeChangeEvents();
      }
    })
  }, {
    key: 'getEntriesSync',
    value: function getEntriesSync() {
      throw new Error('not implemented');
    }

    /*
     * Calls `callback` with either an Array of entries or an Error if there was a problem fetching
     * those entries.
     *
     * Note: Although this function is `async`, it never rejects. Check whether the `error` argument
     * passed to `callback` is `null` to determine if there was an error.
     */
  }, {
    key: 'getEntries',
    value: _asyncToGenerator(function* (callback) {
      var _this3 = this;

      var entries = undefined;
      try {
        entries = yield this._getFileSystemService().readdir(this._localPath);
      } catch (e) {
        callback(e, null);
        return;
      }

      var directories = [];
      var files = [];
      entries.sort(function (a, b) {
        return a.file.toLowerCase().localeCompare(b.file.toLowerCase());
      }).forEach(function (entry) {
        var uri = _this3._host + _path2['default'].join(_this3._localPath, entry.file);
        if (entry.stats.isFile()) {
          files.push(_this3._remote.createFile(uri));
        } else {
          directories.push(_this3._remote.createDirectory(uri));
        }
      });
      callback(null, directories.concat(files));
    })
  }, {
    key: 'contains',
    value: function contains(pathToCheck) {
      // Ideally, the type of pathToCheck would be `string` rather than `?string`;
      // however, as shown by https://github.com/atom/git-diff/pull/53,
      // `editor.getPath()` unexpectedly returns `?string` rather than `string`,
      // and its return value is often used with this method, so it is important
      // to tolerate null as an input.
      if (pathToCheck) {
        return pathToCheck.startsWith(this.getPath());
      } else {
        return false;
      }
    }
  }, {
    key: 'off',
    value: function off() {}
    // This method is part of the EmitterMixin used by Atom's local Directory, but not documented
    // as part of the API - https://atom.io/docs/api/latest/Directory,
    // However, it appears to be called in project.coffee by Atom.

    // A workaround before Atom 2.0: see ::getHgRepoInfo of main.js.

  }, {
    key: 'getHgRepositoryDescription',
    value: function getHgRepositoryDescription() {
      return this._hgRepositoryDescription;
    }
  }, {
    key: '_getFileSystemService',
    value: function _getFileSystemService() {
      return this._getService('FileSystemService');
    }
  }, {
    key: '_getService',
    value: function _getService(serviceName) {
      return this._remote.getService(serviceName);
    }
  }]);

  return RemoteDirectory;
})();

module.exports = RemoteDirectory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1jb25uZWN0aW9uL2xpYi9SZW1vdGVEaXJlY3RvcnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztzQkFlc0IsUUFBUTs7OztvQkFDYixNQUFNOzs7O29CQUNXLE1BQU07OzhCQUNoQixpQkFBaUI7O2dDQUNuQixvQkFBb0I7Ozs7QUFuQjFDLFdBQVcsQ0FBQzs7QUFxQlosSUFBTSxNQUFNLEdBQUcsb0JBSFAsU0FBUyxHQUdTLENBQUM7O0FBRTNCLElBQU0sb0NBQW9DLEdBQUcsOEJBQThCLENBQUM7Ozs7SUFHdEUsZUFBZTtlQUFmLGVBQWU7O1dBQ0ssMkJBQUMsU0FBMkMsRUFBVztBQUM3RSxhQUFPLFNBQVMsQ0FBQyxvQ0FBb0MsQ0FBQyxLQUFLLElBQUksQ0FBQztLQUNqRTs7Ozs7OztBQWVVLFdBbEJQLGVBQWUsQ0FrQlAsTUFBd0IsRUFBRSxHQUFXLEVBQUUsT0FBYSxFQUFFOzBCQWxCOUQsZUFBZTs7QUFtQmpCLFVBQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLG9DQUFvQyxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7QUFDakYsUUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdEIsUUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7QUFDaEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxVQS9CQSxPQUFPLEVBK0JNLENBQUM7QUFDOUIsUUFBSSxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQzs7MkJBQ2tCLDhCQUFVLEtBQUssQ0FBQyxHQUFHLENBQUM7O1FBQXJELGFBQWEsb0JBQW5CLElBQUk7UUFBaUIsUUFBUSxvQkFBUixRQUFRO1FBQUUsSUFBSSxvQkFBSixJQUFJOztBQUMxQyw2QkFBVSxRQUFRLENB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QUFDLE9BQUssVUFBVSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoRSxZQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEVBQUU7QUFDeEIsZUFBSyxDQUFDLElBQUksQ0FBQyxPQUFLLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUMxQyxNQUFNO0FBQ0wscUJBQVcsQ0FBQyxJQUFJLENBQUMsT0FBSyxPQUFPLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDckQ7T0FDRixDQUFDLENBQUM7QUFDSCxjQUFRLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUMzQzs7O1dBRU8sa0JBQUMsV0FBb0IsRUFBVzs7Ozs7O0FBTXRDLFVBQUksV0FBVyxFQUFFO0FBQ2YsZUFBTyxXQUFXLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO09BQy9DLE1BQU07QUFDTCxlQUFPLEtBQUssQ0FBQztPQUNkO0tBQ0Y7OztXQUVFLGVBQUcsRUFJTDs7Ozs7O0FBQUE7OztXQUd5QixzQ0FBRztBQUMzQixhQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztLQUN0Qzs7O1dBRW9CLGlDQUFzQjtBQUN6QyxhQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsbUJBQW1CLENBQUMsQ0FBQztLQUM5Qzs7O1dBRVUscUJBQUMsV0FBbUIsRUFBTztBQUNwQyxhQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQzdDOzs7U0ExUUcsZUFBZTs7O0FBNlFyQixNQUFNLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1yZW1vdGUtY29ubmVjdGlvbi9saWIvUmVtb3RlRGlyZWN0b3J5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpbGVTeXN0ZW1TZXJ2aWNlfSBmcm9tICdudWNsaWRlLXNlcnZlci9saWIvc2VydmljZXMvRmlsZVN5c3RlbVNlcnZpY2VUeXBlJztcbmltcG9ydCB0eXBlIFJlbW90ZUNvbm5lY3Rpb24gZnJvbSAnLi9SZW1vdGVDb25uZWN0aW9uJztcbmltcG9ydCB0eXBlIFJlbW90ZUZpbGUgZnJvbSAnLi9SZW1vdGVGaWxlJztcblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge0Rpc3Bvc2FibGUsIEVtaXR0ZXJ9IGZyb20gJ2F0b20nO1xuaW1wb3J0IHtnZXRMb2dnZXJ9IGZyb20gJ251Y2xpZGUtbG9nZ2luZyc7XG5pbXBvcnQgcmVtb3RlVXJpIGZyb20gJ251Y2xpZGUtcmVtb3RlLXVyaSc7XG5cbmNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcigpO1xuXG5jb25zdCBNQVJLRVJfUFJPUEVSVFlfRk9SX1JFTU9URV9ESVJFQ1RPUlkgPSAnX19udWNsaWRlX3JlbW90ZV9kaXJlY3RvcnlfXyc7XG5cbi8qIE1vc3RseSBpbXBsZW1lbnRzIGh0dHBzOi8vYXRvbS5pby9kb2NzL2FwaS9sYXRlc3QvRGlyZWN0b3J5ICovXG5jbGFzcyBSZW1vdGVEaXJlY3Rvcnkge1xuICBzdGF0aWMgaXNSZW1vdGVEaXJlY3RvcnkoZGlyZWN0b3J5OiBhdG9tJERpcmVjdG9yeSB8IFJlbW90ZURpcmVjdG9yeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkaXJlY3RvcnlbTUFSS0VSX1BST1BFUlRZX0ZPUl9SRU1PVEVfRElSRUNUT1JZXSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIF93YXRjaFN1YnNjcmlwdGlvbjogP2F0b20kRGlzcG9zYWJsZTtcbiAgX3JlbW90ZTogUmVtb3RlQ29ubmVjdGlvbjtcbiAgX3VyaTogc3RyaW5nO1xuICBfZW1pdHRlcjogYXRvbSRFbWl0dGVyO1xuICBfc3Vic2NyaXB0aW9uQ291bnQ6IG51bWJlcjtcbiAgX2hvc3Q6IHN0cmluZztcbiAgX2xvY2FsUGF0aDogc3RyaW5nO1xuICBfaGdSZXBvc2l0b3J5RGVzY3JpcHRpb246ID9zdHJpbmc7XG4gIF93YXRjaFN1YnNjcmlwdGlvbjogT2JzZXJ2YWJsZTtcblxuICAvKipcbiAgICogQHBhcmFtIHVyaSBzaG91bGQgYmUgb2YgdGhlIGZvcm0gXCJudWNsaWRlOi8vZXhhbXBsZS5jb206OTA5MC9wYXRoL3RvL2RpcmVjdG9yeVwiLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVtb3RlOiBSZW1vdGVDb25uZWN0aW9uLCB1cmk6IHN0cmluZywgb3B0aW9uczogP2FueSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBNQVJLRVJfUFJPUEVSVFlfRk9SX1JFTU9URV9ESVJFQ1RPUlksIHt2YWx1ZTogdHJ1ZX0pO1xuICAgIHRoaXMuX3JlbW90ZSA9IHJlbW90ZTtcbiAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ291bnQgPSAwO1xuICAgIGNvbnN0IHtwYXRoOiBkaXJlY3RvcnlQYXRoLCBwcm90b2NvbCwgaG9zdH0gPSByZW1vdGVVcmkucGFyc2UodXJpKTtcbiAgICBpbnZhcmlhbnQocHJvdG9jb2wpO1xuICAgIGludmFyaWFudChob3N0KTtcbiAgICAvKiogSW4gdGhlIGV4YW1wbGUsIHRoaXMgd291bGQgYmUgXCJudWNsaWRlOi8vZXhhbXBsZS5jb206OTA5MFwiLiAqL1xuICAgIHRoaXMuX2hvc3QgPSBwcm90b2NvbCArICcvLycgKyBob3N0O1xuICAgIC8qKiBJbiB0aGUgZXhhbXBsZSwgdGhpcyB3b3VsZCBiZSBcIi9wYXRoL3RvL2RpcmVjdG9yeVwiLiAqL1xuICAgIHRoaXMuX2xvY2FsUGF0aCA9IGRpcmVjdG9yeVBhdGg7XG4gICAgLy8gQSB3b3JrYXJvdW5kIGJlZm9yZSBBdG9tIDIuMDogc2VlIDo6Z2V0SGdSZXBvSW5mbyBvZiBtYWluLmpzLlxuICAgIHRoaXMuX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uID0gb3B0aW9ucyA/IG9wdGlvbnMuaGdSZXBvc2l0b3J5RGVzY3JpcHRpb24gOiBudWxsO1xuICB9XG5cbiAgb25EaWRDaGFuZ2UoY2FsbGJhY2s6ICgpID0+IGFueSk6IGF0b20kRGlzcG9zYWJsZSB7XG4gICAgdGhpcy5fd2lsbEFkZFN1YnNjcmlwdGlvbigpO1xuICAgIHJldHVybiB0aGlzLl90cmFja1Vuc3Vic2NyaXB0aW9uKHRoaXMuX2VtaXR0ZXIub24oJ2RpZC1jaGFuZ2UnLCBjYWxsYmFjaykpO1xuICB9XG5cbiAgX3dpbGxBZGRTdWJzY3JpcHRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ291bnQrKztcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9OYXRpdmVDaGFuZ2VFdmVudHMoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHN1YnNjcmliZSBSZW1vdGVEaXJlY3Rvcnk6JywgdGhpcy5fbG9jYWxQYXRoLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIF9zdWJzY3JpYmVUb05hdGl2ZUNoYW5nZUV2ZW50cygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fd2F0Y2hTdWJzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge3dhdGNoRGlyZWN0b3J5fSA9IHRoaXMuX2dldFNlcnZpY2UoJ0ZpbGVXYXRjaGVyU2VydmljZScpO1xuICAgIGNvbnN0IHdhdGNoU3RyZWFtID0gd2F0Y2hEaXJlY3RvcnkodGhpcy5fdXJpKTtcbiAgICB0aGlzLl93YXRjaFN1YnNjcmlwdGlvbiA9IHdhdGNoU3RyZWFtLnN1YnNjcmliZSh3YXRjaFVwZGF0ZSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoYHdhdGNoRGlyZWN0b3J5IHVwZGF0ZTpgLCB3YXRjaFVwZGF0ZSk7XG4gICAgICBpZiAod2F0Y2hVcGRhdGUudHlwZSA9PT0gJ2NoYW5nZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU5hdGl2ZUNoYW5nZUV2ZW50KCk7XG4gICAgICB9XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc3Vic2NyaWJlIFJlbW90ZURpcmVjdG9yeTonLCB0aGlzLl91cmksIGVycm9yKTtcbiAgICB9LCAoKSA9PiB7XG4gICAgICAvLyBOb3RoaW5nIG5lZWRzIHRvIGJlIGRvbmUgaWYgdGhlIHJvb3QgZGlyZWN0b3J5IHdhdGNoIGhhcyBlbmRlZC5cbiAgICAgIGxvZ2dlci5kZWJ1Zyhgd2F0Y2hEaXJlY3RvcnkgZW5kZWQ6ICR7dGhpcy5fdXJpfWApO1xuICAgIH0pO1xuICB9XG5cbiAgX2hhbmRsZU5hdGl2ZUNoYW5nZUV2ZW50KCk6IHZvaWQge1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdCgnZGlkLWNoYW5nZScpO1xuICB9XG5cbiAgX3RyYWNrVW5zdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBhdG9tJERpc3Bvc2FibGUpOiBhdG9tJERpc3Bvc2FibGUge1xuICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fZGlkUmVtb3ZlU3Vic2NyaXB0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICBfZGlkUmVtb3ZlU3Vic2NyaXB0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNvdW50LS07XG4gICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbkNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdW5zdWJzY3JpYmVGcm9tTmF0aXZlQ2hhbmdlRXZlbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgX3Vuc3Vic2NyaWJlRnJvbU5hdGl2ZUNoYW5nZUV2ZW50cygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fd2F0Y2hTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3dhdGNoU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX3dhdGNoU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpc0ZpbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNEaXJlY3RvcnkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc1Jvb3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUm9vdCh0aGlzLl9sb2NhbFBhdGgpO1xuICB9XG5cbiAgZXhpc3RzU3luYygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfaXNSb290KGZpbGVQYXRoKTogYm9vbGVhbiB7XG4gICAgZmlsZVBhdGggPSBwYXRoLm5vcm1hbGl6ZShmaWxlUGF0aCk7XG4gICAgY29uc3QgcGFydHMgPSBwYXRoLnBhcnNlKGZpbGVQYXRoKTtcbiAgICByZXR1cm4gcGFydHMucm9vdCA9PT0gZmlsZVBhdGg7XG4gIH1cblxuICBnZXRQYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgfVxuXG4gIGdldExvY2FsUGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbFBhdGg7XG4gIH1cblxuICBnZXRIb3N0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2hvc3Q7XG4gIH1cblxuICBnZXRSZWFsUGF0aFN5bmMoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgZ2V0QmFzZU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5iYXNlbmFtZSh0aGlzLl9sb2NhbFBhdGgpO1xuICB9XG5cbiAgcmVsYXRpdml6ZSh1cmk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgIHJldHVybiB1cmk7XG4gICAgfVxuICAgIC8vIE5vdGU6IGhvc3Qgb2YgdXJpIG11c3QgbWF0Y2ggdGhpcy5faG9zdC5cbiAgICBjb25zdCBzdWJwYXRoID0gcmVtb3RlVXJpLnBhcnNlKHVyaSkucGF0aDtcbiAgICByZXR1cm4gcGF0aC5yZWxhdGl2ZSh0aGlzLl9sb2NhbFBhdGgsIHN1YnBhdGgpO1xuICB9XG5cbiAgZ2V0UGFyZW50KCk6IFJlbW90ZURpcmVjdG9yeSB7XG4gICAgaWYgKHRoaXMuaXNSb290KCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cmkgPSB0aGlzLl9ob3N0ICsgcGF0aC5ub3JtYWxpemUocGF0aC5qb2luKHRoaXMuX2xvY2FsUGF0aCwgJy4uJykpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZS5jcmVhdGVEaXJlY3RvcnkodXJpKTtcbiAgICB9XG4gIH1cblxuICBnZXRGaWxlKGZpbGVuYW1lOiBzdHJpbmcpOiBSZW1vdGVGaWxlIHtcbiAgICBjb25zdCB1cmkgPSB0aGlzLl9ob3N0ICsgcGF0aC5qb2luKHRoaXMuX2xvY2FsUGF0aCwgZmlsZW5hbWUpO1xuICAgIHJldHVybiB0aGlzLl9yZW1vdGUuY3JlYXRlRmlsZSh1cmkpO1xuICB9XG5cbiAgZ2V0U3ViZGlyZWN0b3J5KGRpcm5hbWU6IHN0cmluZyk6IFJlbW90ZURpcmVjdG9yeSB7XG4gICAgY29uc3QgdXJpID0gdGhpcy5faG9zdCArIHBhdGguam9pbih0aGlzLl9sb2NhbFBhdGgsIGRpcm5hbWUpO1xuICAgIHJldHVybiB0aGlzLl9yZW1vdGUuY3JlYXRlRGlyZWN0b3J5KHVyaSk7XG4gIH1cblxuICBhc3luYyBjcmVhdGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHRoaXMuX2dldEZpbGVTeXN0ZW1TZXJ2aWNlKCkubWtkaXJwKHRoaXMuX2xvY2FsUGF0aCk7XG4gICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbkNvdW50ID4gMCkge1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9OYXRpdmVDaGFuZ2VFdmVudHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBhc3luYyBkZWxldGUoKTogUHJvbWlzZSB7XG4gICAgYXdhaXQgdGhpcy5fZ2V0RmlsZVN5c3RlbVNlcnZpY2UoKS5ybWRpcih0aGlzLl9sb2NhbFBhdGgpO1xuICAgIHRoaXMuX3Vuc3Vic2NyaWJlRnJvbU5hdGl2ZUNoYW5nZUV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZXMgdGhpcyBkaXJlY3RvcnkgdG8gdGhlIGdpdmVuIGFic29sdXRlIHBhdGguXG4gICAqL1xuICBhc3luYyByZW5hbWUobmV3UGF0aDogc3RyaW5nKTogUHJvbWlzZSB7XG4gICAgYXdhaXQgdGhpcy5fZ2V0RmlsZVN5c3RlbVNlcnZpY2UoKS5yZW5hbWUodGhpcy5fbG9jYWxQYXRoLCBuZXdQYXRoKTtcblxuICAgIC8vIFVuc3Vic2NyaWJlIGZyb20gdGhlIG9sZCBgdGhpcy5fbG9jYWxQYXRoYC4gVGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlXG4gICAgLy8gc2V0dGluZyB0aGUgbmV3IGB0aGlzLl9sb2NhbFBhdGhgLlxuICAgIHRoaXMuX3Vuc3Vic2NyaWJlRnJvbU5hdGl2ZUNoYW5nZUV2ZW50cygpO1xuXG4gICAgY29uc3Qge3Byb3RvY29sLCBob3N0fSA9IHJlbW90ZVVyaS5wYXJzZSh0aGlzLl91cmkpO1xuICAgIHRoaXMuX2xvY2FsUGF0aCA9IG5ld1BhdGg7XG4gICAgaW52YXJpYW50KHByb3RvY29sKTtcbiAgICBpbnZhcmlhbnQoaG9zdCk7XG4gICAgdGhpcy5fdXJpID0gcHJvdG9jb2wgKyAnLy8nICsgaG9zdCArIHRoaXMuX2xvY2FsUGF0aDtcblxuICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGZvciB0aGUgbmV3IGB0aGlzLl9sb2NhbFBhdGhgLiBUaGlzIG11c3QgYmUgZG9uZVxuICAgIC8vIGFmdGVyIHNldHRpbmcgdGhlIG5ldyBgdGhpcy5fbG9jYWxQYXRoYC5cbiAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uQ291bnQgPiAwKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb05hdGl2ZUNoYW5nZUV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIGdldEVudHJpZXNTeW5jKCk6IEFycmF5PFJlbW90ZUZpbGUgfCBSZW1vdGVEaXJlY3Rvcnk+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLypcbiAgICogQ2FsbHMgYGNhbGxiYWNrYCB3aXRoIGVpdGhlciBhbiBBcnJheSBvZiBlbnRyaWVzIG9yIGFuIEVycm9yIGlmIHRoZXJlIHdhcyBhIHByb2JsZW0gZmV0Y2hpbmdcbiAgICogdGhvc2UgZW50cmllcy5cbiAgICpcbiAgICogTm90ZTogQWx0aG91Z2ggdGhpcyBmdW5jdGlvbiBpcyBgYXN5bmNgLCBpdCBuZXZlciByZWplY3RzLiBDaGVjayB3aGV0aGVyIHRoZSBgZXJyb3JgIGFyZ3VtZW50XG4gICAqIHBhc3NlZCB0byBgY2FsbGJhY2tgIGlzIGBudWxsYCB0byBkZXRlcm1pbmUgaWYgdGhlcmUgd2FzIGFuIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgZ2V0RW50cmllcyhcbiAgICBjYWxsYmFjazogKGVycm9yOiA/RXJyb3IsIGVudHJpZXM6ID9BcnJheTxSZW1vdGVGaWxlIHwgUmVtb3RlRGlyZWN0b3J5PikgPT4gYW55LFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgZW50cmllcztcbiAgICB0cnkge1xuICAgICAgZW50cmllcyA9IGF3YWl0IHRoaXMuX2dldEZpbGVTeXN0ZW1TZXJ2aWNlKCkucmVhZGRpcih0aGlzLl9sb2NhbFBhdGgpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0b3JpZXMgPSBbXTtcbiAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgIGVudHJpZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIGEuZmlsZS50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoYi5maWxlLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0pLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCB1cmkgPSB0aGlzLl9ob3N0ICsgcGF0aC5qb2luKHRoaXMuX2xvY2FsUGF0aCwgZW50cnkuZmlsZSk7XG4gICAgICBpZiAoZW50cnkuc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgZmlsZXMucHVzaCh0aGlzLl9yZW1vdGUuY3JlYXRlRmlsZSh1cmkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdG9yaWVzLnB1c2godGhpcy5fcmVtb3RlLmNyZWF0ZURpcmVjdG9yeSh1cmkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjYWxsYmFjayhudWxsLCBkaXJlY3Rvcmllcy5jb25jYXQoZmlsZXMpKTtcbiAgfVxuXG4gIGNvbnRhaW5zKHBhdGhUb0NoZWNrOiA/c3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gSWRlYWxseSwgdGhlIHR5cGUgb2YgcGF0aFRvQ2hlY2sgd291bGQgYmUgYHN0cmluZ2AgcmF0aGVyIHRoYW4gYD9zdHJpbmdgO1xuICAgIC8vIGhvd2V2ZXIsIGFzIHNob3duIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9tL2dpdC1kaWZmL3B1bGwvNTMsXG4gICAgLy8gYGVkaXRvci5nZXRQYXRoKClgIHVuZXhwZWN0ZWRseSByZXR1cm5zIGA/c3RyaW5nYCByYXRoZXIgdGhhbiBgc3RyaW5nYCxcbiAgICAvLyBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyBvZnRlbiB1c2VkIHdpdGggdGhpcyBtZXRob2QsIHNvIGl0IGlzIGltcG9ydGFudFxuICAgIC8vIHRvIHRvbGVyYXRlIG51bGwgYXMgYW4gaW5wdXQuXG4gICAgaWYgKHBhdGhUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gcGF0aFRvQ2hlY2suc3RhcnRzV2l0aCh0aGlzLmdldFBhdGgoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBvZmYoKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgRW1pdHRlck1peGluIHVzZWQgYnkgQXRvbSdzIGxvY2FsIERpcmVjdG9yeSwgYnV0IG5vdCBkb2N1bWVudGVkXG4gICAgLy8gYXMgcGFydCBvZiB0aGUgQVBJIC0gaHR0cHM6Ly9hdG9tLmlvL2RvY3MvYXBpL2xhdGVzdC9EaXJlY3RvcnksXG4gICAgLy8gSG93ZXZlciwgaXQgYXBwZWFycyB0byBiZSBjYWxsZWQgaW4gcHJvamVjdC5jb2ZmZWUgYnkgQXRvbS5cbiAgfVxuXG4gIC8vIEEgd29ya2Fyb3VuZCBiZWZvcmUgQXRvbSAyLjA6IHNlZSA6OmdldEhnUmVwb0luZm8gb2YgbWFpbi5qcy5cbiAgZ2V0SGdSZXBvc2l0b3J5RGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uO1xuICB9XG5cbiAgX2dldEZpbGVTeXN0ZW1TZXJ2aWNlKCk6IEZpbGVTeXN0ZW1TZXJ2aWNlIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2VydmljZSgnRmlsZVN5c3RlbVNlcnZpY2UnKTtcbiAgfVxuXG4gIF9nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lOiBzdHJpbmcpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9yZW1vdGUuZ2V0U2VydmljZShzZXJ2aWNlTmFtZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVEaXJlY3Rvcnk7XG4iXX0=
