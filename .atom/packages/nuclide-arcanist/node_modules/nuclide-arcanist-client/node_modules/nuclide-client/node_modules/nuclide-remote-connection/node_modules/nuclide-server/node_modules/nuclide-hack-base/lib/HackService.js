Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var getDiagnostics = _asyncToGenerator(function* (file, currentContents) {
  var hhResult = yield _nuclideCommons.promises.retryLimit(function () {
    return (0, _HackHelpers.callHHClient)(
    /*args*/[],
    /*errorStream*/true,
    /*outputJson*/true,
    /*processInput*/null,
    /*file*/file);
  }, function (result) {
    return result != null;
  }, HH_CLIENT_MAX_TRIES, HH_DIAGNOSTICS_DELAY_MS);
  if (!hhResult) {
    return null;
  }
  var hackRoot = hhResult.hackRoot;
  var result = hhResult.result;

  var messages = result.errors;

  // Use a consistent null 'falsy' value for the empty string, undefined, etc.
  messages.forEach(function (error) {
    error.message.forEach(function (component) {
      component.path = component.path || null;
    });
  });

  return {
    hackRoot: hackRoot,
    messages: messages
  };
});

exports.getDiagnostics = getDiagnostics;

var getCompletions = _asyncToGenerator(function* (file, markedContents) {
  var hhResult = yield (0, _HackHelpers.callHHClient)(
  /*args*/['--auto-complete'],
  /*errorStream*/false,
  /*outputJson*/true,
  /*processInput*/markedContents,
  /*file*/file);
  if (!hhResult) {
    return null;
  }
  var hackRoot = hhResult.hackRoot;
  var result = hhResult.result;

  var completions = result;
  return {
    hackRoot: hackRoot,
    completions: completions
  };
}

/**
 * Gets the hh_client definition of the query with a given symbol type.
 */
);

exports.getCompletions = getCompletions;

var getDefinition = _asyncToGenerator(function* (file, query, symbolType) {
  var searchTypes = (0, _HackHelpers.symbolTypeToSearchTypes)(symbolType);
  var searchResponse = yield (0, _HackHelpers.getSearchResults)(file, query, searchTypes);
  return selectDefinitionSearchResults(searchResponse, query);
});

exports.getDefinition = getDefinition;

var getIdentifierDefinition = _asyncToGenerator(function* (file, contents, line, column) {
  var hhResult = yield (0, _HackHelpers.callHHClient)(
  // The `indetify-function` result is text, but passing --json option
  // will eliminate any hh status messages that's irrelevant.
  /*args*/['--json', '--identify-function', line + ':' + column],
  /*errorStream*/false,
  /*outputJson*/false,
  /*processInput*/contents,
  /*cwd*/file);
  if (!hhResult) {
    return null;
  }
  var identifier = (hhResult.result || '').trim();
  if (!identifier) {
    return null;
  }
  var searchResponse = yield (0, _HackHelpers.getSearchResults)(file, identifier);
  return selectDefinitionSearchResults(searchResponse, identifier);
}

/**
 * Fetches the dependencies needed by the hack worker to cache
 * for faster hack features response times.
 * Returns a map of file paths to file contents.
 */
);

exports.getIdentifierDefinition = getIdentifierDefinition;

var getDependencies = _asyncToGenerator(function* (filePath, dependenciesInfo) {
  var dependencies = new Map();
  var dependencyPaths = new Set();
  var hackRoot = '';
  // hh_server currently is single threaded and processes one request at a time.
  // Hence, we fetch the dependencies one-by-one, without Promise.all for the hack search
  // to unblock user-requested hack language features and failry treat other usages of hh_client.
  /* eslint-disable babel/no-await-in-loop */

  var _loop = function* (dependency) {
    var dependencyName = dependency.name;
    var dependencyType = dependency.type;

    if (dependencyName.startsWith('\\')) {
      dependencyName = dependencyName.substring(1);
    }
    var filter = undefined;
    if (dependencyType === 'class') {
      filter = [_nuclideHackCommonLibConstants.SearchResultType.CLASS, _nuclideHackCommonLibConstants.SearchResultType.ABSTRACT_CLASS, _nuclideHackCommonLibConstants.SearchResultType.TRAIT, _nuclideHackCommonLibConstants.SearchResultType.TYPEDEF, _nuclideHackCommonLibConstants.SearchResultType.INTERFACE];
    } else {
      filter = [_nuclideHackCommonLibConstants.SearchResultType.FUNCTION];
    }

    var searchResponse = yield (0, _HackHelpers.getSearchResults)(filePath, dependencyName, filter);
    if (searchResponse == null) {
      return 'continue';
    }
    (0, _assert2['default'])(searchResponse);
    var searchResults = searchResponse.result;

    hackRoot = searchResponse.hackRoot;
    yield Promise.all(searchResults.map(_asyncToGenerator(function* (location) {
      var name = location.name;
      var path = location.path;

      if (name !== dependencyName || dependencyPaths.has(path)) {
        return;
      }
      dependencyPaths.add(path);
      var contents = yield _nuclideCommons.fsPromise.readFile(path, 'utf8');
      if (!contents.startsWith('<?hh')) {
        return;
      }
      // This turns anything we're adding into decl mode, so that it uses less memory.
      // Ideally, hh_server should do this, and strip the method/function bodies.
      if (contents.startsWith(HH_NEWLINE)) {
        contents = '<?hh // decl\n' + contents.substring(HH_NEWLINE.length);
      } else if (contents.startsWith(HH_STRICT_NEWLINE)) {
        contents = '<?hh // decl\n' + contents.substring(HH_STRICT_NEWLINE.length);
      }
      dependencies.set(path, contents);
    })));
  };

  for (var dependency of dependenciesInfo) {
    var _ret = yield* _loop(dependency);

    if (_ret === 'continue') continue;
  }
  /* eslint-enable babel/no-await-in-loop */
  return {
    hackRoot: hackRoot,
    dependencies: dependencies
  };
});

exports.getDependencies = getDependencies;

var getReferences = _asyncToGenerator(function* (filePath, symbolName, symbolType) {
  var cmd = '--find-refs';
  if (symbolType === _nuclideHackCommonLibConstants.SymbolType.CLASS) {
    cmd = '--find-class-refs';
  }
  var hhResult = yield (0, _HackHelpers.callHHClient)(
  /*args*/[cmd, symbolName],
  /*errorStream*/false,
  /*outputJson*/true,
  /*processInput*/null,
  /*file*/filePath);
  if (!hhResult) {
    return null;
  }
  var hackRoot = hhResult.hackRoot;
  var result = hhResult.result;

  var references = result;
  return {
    hackRoot: hackRoot,
    references: references
  };
});

exports.getReferences = getReferences;
exports.getHackEnvironmentDetails = getHackEnvironmentDetails;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

var _nuclideCommons = require('nuclide-commons');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _nuclideHackCommonLibConstants = require('nuclide-hack-common/lib/constants');

var _HackHelpers = require('./HackHelpers');

'use babel';

var HH_NEWLINE = '<?hh\n';
var HH_STRICT_NEWLINE = '<?hh // strict\n';
var HH_DIAGNOSTICS_DELAY_MS = 600;
var HH_CLIENT_MAX_TRIES = 10;

function getHackEnvironmentDetails(localFile) {
  return (0, _HackHelpers.getHackExecOptions)(localFile);
}

function selectDefinitionSearchResults(searchReposnse, query) {
  if (!searchReposnse) {
    return null;
  }
  var searchResults = searchReposnse.result;
  var hackRoot = searchReposnse.hackRoot;

  var matchingResults = searchResults.filter(function (result) {
    // If the request had a :: in it, it's a full name, so we should compare to
    // the name of the result in that format.
    var fullName = result.name;
    if (query.indexOf('::') !== -1 && result.scope) {
      fullName = result.scope + '::' + fullName;
    }
    return fullName === query;
  });
  return {
    hackRoot: hackRoot,
    definitions: matchingResults
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhhY2stYmFzZS9saWIvSGFja1NlcnZpY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBdUNzQixjQUFjLHFCQUE3QixXQUNMLElBQWdCLEVBQ2hCLGVBQXdCLEVBQ1M7QUFDakMsTUFBTSxRQUFRLEdBQUcsTUFBTSxnQkFuQk4sUUFBUSxDQW1CTyxVQUFVLENBQ3hDO1dBQU0saUJBaEJSLFlBQVk7WUFpQkMsRUFBRTttQkFDSyxJQUFJO2tCQUNMLElBQUk7b0JBQ0YsSUFBSTtZQUNaLElBQUksQ0FDZDtHQUFBLEVBQ0QsVUFBQSxNQUFNO1dBQUksTUFBTSxJQUFJLElBQUk7R0FBQSxFQUN4QixtQkFBbUIsRUFDbkIsdUJBQXVCLENBQ3hCLENBQUM7QUFDRixNQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2IsV0FBTyxJQUFJLENBQUM7R0FDYjtNQUNNLFFBQVEsR0FBWSxRQUFRLENBQTVCLFFBQVE7TUFBRSxNQUFNLEdBQUksUUFBUSxDQUFsQixNQUFNOztBQUN2QixNQUFNLFFBQVEsR0FBRyxBQUNkLE1BQU0sQ0FDUCxNQUFNLENBQUM7OztBQUdULFVBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQSxLQUFLLEVBQUk7QUFDeEIsU0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQSxTQUFTLEVBQUk7QUFDakMsZUFBUyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztLQUN6QyxDQUFDLENBQUM7R0FDSixDQUFDLENBQUM7O0FBRUgsU0FBTztBQUNMLFlBQVEsRUFBUixRQUFRO0FBQ1IsWUFBUSxFQUFSLFFBQVE7R0FDVCxDQUFDO0NBQ0g7Ozs7SUFFcUIsY0FBYyxxQkFBN0IsV0FDTCxJQUFnQixFQUNoQixjQUFzQixFQUNXO0FBQ2pDLE1BQU0sUUFBUSxHQUFHLE1BQU0saUJBcER2QixZQUFZO1VBcURELENBQUMsaUJBQWlCLENBQUM7aUJBQ1osS0FBSztnQkFDTixJQUFJO2tCQUNGLGNBQWM7VUFDdEIsSUFBSSxDQUNkLENBQUM7QUFDRixNQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2IsV0FBTyxJQUFJLENBQUM7R0FDYjtNQUNNLFFBQVEsR0FBWSxRQUFRLENBQTVCLFFBQVE7TUFBRSxNQUFNLEdBQUksUUFBUSxDQUFsQixNQUFNOztBQUN2QixNQUFNLFdBQVcsR0FBSyxNQUFNLEFBQStCLENBQUM7QUFDNUQsU0FBTztBQUNMLFlBQVEsRUFBUixRQUFRO0FBQ1IsZUFBVyxFQUFYLFdBQVc7R0FDWixDQUFDO0NBQ0g7Ozs7Ozs7OztJQUtxQixhQUFhLHFCQUE1QixXQUNMLElBQWdCLEVBQ2hCLEtBQWEsRUFDYixVQUEyQixFQUNLO0FBQ2hDLE1BQU0sV0FBVyxHQUFHLGlCQTdFcEIsdUJBQXVCLEVBNkVxQixVQUFVLENBQUMsQ0FBQztBQUN4RCxNQUFNLGNBQWMsR0FBRyxNQUFNLGlCQTdFN0IsZ0JBQWdCLEVBNkU4QixJQUFJLEVBQUUsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3hFLFNBQU8sNkJBQTZCLENBQUMsY0FBYyxFQUFFLEtBQUssQ0FBQyxDQUFDO0NBQzdEOzs7O0lBRXFCLHVCQUF1QixxQkFBdEMsV0FDTCxJQUFnQixFQUNoQixRQUFnQixFQUNoQixJQUFZLEVBQ1osTUFBYyxFQUNrQjtBQUNoQyxNQUFNLFFBQVEsR0FBRyxNQUFNLGlCQXpGdkIsWUFBWTs7O1VBNEZELENBQUMsUUFBUSxFQUFFLHFCQUFxQixFQUFLLElBQUksU0FBSSxNQUFNLENBQUc7aUJBQy9DLEtBQUs7Z0JBQ04sS0FBSztrQkFDSCxRQUFRO1NBQ2pCLElBQUksQ0FDYixDQUFDO0FBQ0YsTUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNiLFdBQU8sSUFBSSxDQUFDO0dBQ2I7QUFDRCxNQUFNLFVBQVUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFBLENBQUUsSUFBSSxFQUFFLENBQUM7QUFDbEQsTUFBSSxDQUFDLFVBQVUsRUFBRTtBQUNmLFdBQU8sSUFBSSxDQUFDO0dBQ2I7QUFDRCxNQUFNLGNBQWMsR0FBRyxNQUFNLGlCQXZHN0IsZ0JBQWdCLEVBdUc4QixJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDaEUsU0FBTyw2QkFBNkIsQ0FBQyxjQUFjLEVBQUUsVUFBVSxDQUFDLENBQUM7Q0FDbEU7Ozs7Ozs7Ozs7O0lBT3FCLGVBQWUscUJBQTlCLFdBQ0wsUUFBb0IsRUFDcEIsZ0JBQXFELEVBSXBEO0FBQ0QsTUFBTSxZQUFZLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUMvQixNQUFNLGVBQWUsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2xDLE1BQUksUUFBUSxHQUFHLEVBQUUsQ0FBQzs7Ozs7O3lCQUtQLFVBQVU7UUFDUixjQUFjLEdBQTBCLFVBQVUsQ0FBeEQsSUFBSTtRQUF3QixjQUFjLEdBQUksVUFBVSxDQUFsQyxJQUFJOztBQUMvQixRQUFJLGNBQWMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDbkMsb0JBQWMsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzlDO0FBQ0QsUUFBSSxNQUFNLFlBQUEsQ0FBQztBQUNYLFFBQUksY0FBYyxLQUFLLE9BQU8sRUFBRTtBQUM5QixZQUFNLEdBQUcsQ0FDUCwrQkExSVksZ0JBQWdCLENBMElYLEtBQUssRUFDdEIsK0JBM0lZLGdCQUFnQixDQTJJWCxjQUFjLEVBQy9CLCtCQTVJWSxnQkFBZ0IsQ0E0SVgsS0FBSyxFQUN0QiwrQkE3SVksZ0JBQWdCLENBNklYLE9BQU8sRUFDeEIsK0JBOUlZLGdCQUFnQixDQThJWCxTQUFTLENBQzNCLENBQUM7S0FDSCxNQUFNO0FBQ0wsWUFBTSxHQUFHLENBQUMsK0JBakpJLGdCQUFnQixDQWlKSCxRQUFRLENBQUMsQ0FBQztLQUN0Qzs7QUFFRCxRQUFNLGNBQWMsR0FBRyxNQUFNLGlCQWhKL0IsZ0JBQWdCLEVBZ0pnQyxRQUFRLEVBQUUsY0FBYyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ2hGLFFBQUksY0FBYyxJQUFJLElBQUksRUFBRTtBQUMxQix3QkFBUztLQUNWO0FBQ0QsNkJBQVUsY0FBYyxDQUFDLENBQUM7UUFDWCxhQUFhLEdBQUksY0FBYyxDQUF2QyxNQUFNOztBQUNiLFlBQVEsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDO0FBQ25DLFVBQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxtQkFBQyxXQUFPLFFBQVEsRUFBSztVQUMvQyxJQUFJLEdBQVUsUUFBUSxDQUF0QixJQUFJO1VBQUUsSUFBSSxHQUFJLFFBQVEsQ0FBaEIsSUFBSTs7QUFDakIsVUFBSSxJQUFJLEtBQUssY0FBYyxJQUFJLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDeEQsZUFBTztPQUNSO0FBQ0QscUJBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUIsVUFBSSxRQUFRLEdBQUcsTUFBTSxnQkFuS25CLFNBQVMsQ0FtS29CLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDdEQsVUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDaEMsZUFBTztPQUNSOzs7QUFHRCxVQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUU7QUFDbkMsZ0JBQVEsR0FBRyxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUNyRSxNQUFNLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO0FBQ2pELGdCQUFRLEdBQUcsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUM1RTtBQUNELGtCQUFZLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztLQUNsQyxFQUFDLENBQUMsQ0FBQzs7O0FBM0NOLE9BQUssSUFBTSxVQUFVLElBQUksZ0JBQWdCLEVBQUU7NEJBQWhDLFVBQVU7OzZCQW9CakIsU0FBUztHQXdCWjs7QUFFRCxTQUFPO0FBQ0wsWUFBUSxFQUFSLFFBQVE7QUFDUixnQkFBWSxFQUFaLFlBQVk7R0FDYixDQUFDO0NBQ0g7Ozs7SUFFcUIsYUFBYSxxQkFBNUIsV0FDTCxRQUFvQixFQUNwQixVQUFrQixFQUNsQixVQUE0QixFQUNJO0FBQ2hDLE1BQUksR0FBRyxHQUFHLGFBQWEsQ0FBQztBQUN4QixNQUFJLFVBQVUsS0FBSywrQkE1TGIsVUFBVSxDQTRMYyxLQUFLLEVBQUU7QUFDbkMsT0FBRyxHQUFHLG1CQUFtQixDQUFDO0dBQzNCO0FBQ0QsTUFBTSxRQUFRLEdBQUcsTUFBTSxpQkE3THZCLFlBQVk7VUE4TEQsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDO2lCQUNWLEtBQUs7Z0JBQ04sSUFBSTtrQkFDRixJQUFJO1VBQ1osUUFBUSxDQUNsQixDQUFDO0FBQ0YsTUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNiLFdBQU8sSUFBSSxDQUFDO0dBQ2I7TUFDTSxRQUFRLEdBQVksUUFBUSxDQUE1QixRQUFRO01BQUUsTUFBTSxHQUFJLFFBQVEsQ0FBbEIsTUFBTTs7QUFDdkIsTUFBTSxVQUFVLEdBQUssTUFBTSxBQUE2QixDQUFDO0FBQ3pELFNBQU87QUFDTCxZQUFRLEVBQVIsUUFBUTtBQUNSLGNBQVUsRUFBVixVQUFVO0dBQ1gsQ0FBQztDQUNIOzs7Ozs7Ozs7OEJBak5pQyxpQkFBaUI7O3NCQUM3QixRQUFROzs7OzZDQUNhLG1DQUFtQzs7MkJBTXZFLGVBQWU7O0FBaEN0QixXQUFXLENBQUM7O0FBa0NaLElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQztBQUM1QixJQUFNLGlCQUFpQixHQUFHLGtCQUFrQixDQUFDO0FBQzdDLElBQU0sdUJBQXVCLEdBQUcsR0FBRyxDQUFDO0FBQ3BDLElBQU0sbUJBQW1CLEdBQUcsRUFBRSxDQUFDOztBQXNNeEIsU0FBUyx5QkFBeUIsQ0FDdkMsU0FBaUIsRUFDa0M7QUFDbkQsU0FBTyxpQkEvTVAsa0JBQWtCLEVBK01RLFNBQVMsQ0FBQyxDQUFDO0NBQ3RDOztBQUVELFNBQVMsNkJBQTZCLENBQ3BDLGNBQWlDLEVBQ2pDLEtBQWEsRUFDVTtBQUN2QixNQUFJLENBQUMsY0FBYyxFQUFFO0FBQ25CLFdBQU8sSUFBSSxDQUFDO0dBQ2I7TUFDYyxhQUFhLEdBQWMsY0FBYyxDQUFqRCxNQUFNO01BQWlCLFFBQVEsR0FBSSxjQUFjLENBQTFCLFFBQVE7O0FBQ3RDLE1BQU0sZUFBZSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsVUFBQSxNQUFNLEVBQUk7OztBQUdyRCxRQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQzNCLFFBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO0FBQzlDLGNBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxRQUFRLENBQUM7S0FDM0M7QUFDRCxXQUFPLFFBQVEsS0FBSyxLQUFLLENBQUM7R0FDM0IsQ0FBQyxDQUFDO0FBQ0gsU0FBTztBQUNMLFlBQVEsRUFBUixRQUFRO0FBQ1IsZUFBVyxFQUFFLGVBQWU7R0FDN0IsQ0FBQztDQUNIIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhhY2stYmFzZS9saWIvSGFja1NlcnZpY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIEhhY2tEaWFnbm9zdGljc1Jlc3VsdCxcbiAgSGFja0RpYWdub3N0aWMsXG4gIEhhY2tDb21wbGV0aW9uc1Jlc3VsdCxcbiAgSGFja0NvbXBsZXRpb24sXG4gIEhhY2tEZWZpbml0aW9uUmVzdWx0LFxuICBIYWNrU2VhcmNoUmVzdWx0LFxuICBIYWNrUmVmZXJlbmNlLFxuICBIYWNrUmVmZXJlbmNlc1Jlc3VsdCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7U3ltYm9sVHlwZVZhbHVlfSBmcm9tICdudWNsaWRlLWhhY2stY29tbW9uL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IHR5cGUge051Y2xpZGVVcml9IGZyb20gJ251Y2xpZGUtcmVtb3RlLXVyaSc7XG5cbmltcG9ydCB7ZnNQcm9taXNlLCBwcm9taXNlc30gZnJvbSAnbnVjbGlkZS1jb21tb25zJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7U3ltYm9sVHlwZSwgU2VhcmNoUmVzdWx0VHlwZX0gZnJvbSAnbnVjbGlkZS1oYWNrLWNvbW1vbi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIGNhbGxISENsaWVudCxcbiAgc3ltYm9sVHlwZVRvU2VhcmNoVHlwZXMsXG4gIGdldFNlYXJjaFJlc3VsdHMsXG4gIGdldEhhY2tFeGVjT3B0aW9ucyxcbn0gZnJvbSAnLi9IYWNrSGVscGVycyc7XG5cbmNvbnN0IEhIX05FV0xJTkUgPSAnPD9oaFxcbic7XG5jb25zdCBISF9TVFJJQ1RfTkVXTElORSA9ICc8P2hoIC8vIHN0cmljdFxcbic7XG5jb25zdCBISF9ESUFHTk9TVElDU19ERUxBWV9NUyA9IDYwMDtcbmNvbnN0IEhIX0NMSUVOVF9NQVhfVFJJRVMgPSAxMDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERpYWdub3N0aWNzKFxuICBmaWxlOiBOdWNsaWRlVXJpLFxuICBjdXJyZW50Q29udGVudHM/OiBzdHJpbmdcbik6IFByb21pc2U8P0hhY2tEaWFnbm9zdGljc1Jlc3VsdD4ge1xuICBjb25zdCBoaFJlc3VsdCA9IGF3YWl0IHByb21pc2VzLnJldHJ5TGltaXQoXG4gICAgKCkgPT4gY2FsbEhIQ2xpZW50KFxuICAgICAgLyphcmdzKi8gW10sXG4gICAgICAvKmVycm9yU3RyZWFtKi8gdHJ1ZSxcbiAgICAgIC8qb3V0cHV0SnNvbiovIHRydWUsXG4gICAgICAvKnByb2Nlc3NJbnB1dCovIG51bGwsXG4gICAgICAvKmZpbGUqLyBmaWxlLFxuICAgICksXG4gICAgcmVzdWx0ID0+IHJlc3VsdCAhPSBudWxsLFxuICAgIEhIX0NMSUVOVF9NQVhfVFJJRVMsXG4gICAgSEhfRElBR05PU1RJQ1NfREVMQVlfTVMsXG4gICk7XG4gIGlmICghaGhSZXN1bHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7aGFja1Jvb3QsIHJlc3VsdH0gPSBoaFJlc3VsdDtcbiAgY29uc3QgbWVzc2FnZXMgPSAoXG4gICAgKHJlc3VsdDogYW55KToge2Vycm9yczogQXJyYXk8e21lc3NhZ2U6IEhhY2tEaWFnbm9zdGljfT59XG4gICkuZXJyb3JzO1xuXG4gIC8vIFVzZSBhIGNvbnNpc3RlbnQgbnVsbCAnZmFsc3knIHZhbHVlIGZvciB0aGUgZW1wdHkgc3RyaW5nLCB1bmRlZmluZWQsIGV0Yy5cbiAgbWVzc2FnZXMuZm9yRWFjaChlcnJvciA9PiB7XG4gICAgZXJyb3IubWVzc2FnZS5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICBjb21wb25lbnQucGF0aCA9IGNvbXBvbmVudC5wYXRoIHx8IG51bGw7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgaGFja1Jvb3QsXG4gICAgbWVzc2FnZXMsXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21wbGV0aW9ucyhcbiAgZmlsZTogTnVjbGlkZVVyaSxcbiAgbWFya2VkQ29udGVudHM6IHN0cmluZ1xuKTogUHJvbWlzZTw/SGFja0NvbXBsZXRpb25zUmVzdWx0PiB7XG4gIGNvbnN0IGhoUmVzdWx0ID0gYXdhaXQgY2FsbEhIQ2xpZW50KFxuICAgIC8qYXJncyovIFsnLS1hdXRvLWNvbXBsZXRlJ10sXG4gICAgLyplcnJvclN0cmVhbSovIGZhbHNlLFxuICAgIC8qb3V0cHV0SnNvbiovIHRydWUsXG4gICAgLypwcm9jZXNzSW5wdXQqLyBtYXJrZWRDb250ZW50cyxcbiAgICAvKmZpbGUqLyBmaWxlLFxuICApO1xuICBpZiAoIWhoUmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge2hhY2tSb290LCByZXN1bHR9ID0gaGhSZXN1bHQ7XG4gIGNvbnN0IGNvbXBsZXRpb25zID0gKChyZXN1bHQgOiBhbnkpOiBBcnJheTxIYWNrQ29tcGxldGlvbj4pO1xuICByZXR1cm4ge1xuICAgIGhhY2tSb290LFxuICAgIGNvbXBsZXRpb25zLFxuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhoX2NsaWVudCBkZWZpbml0aW9uIG9mIHRoZSBxdWVyeSB3aXRoIGEgZ2l2ZW4gc3ltYm9sIHR5cGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWZpbml0aW9uKFxuICBmaWxlOiBOdWNsaWRlVXJpLFxuICBxdWVyeTogc3RyaW5nLFxuICBzeW1ib2xUeXBlOiBTeW1ib2xUeXBlVmFsdWUsXG4pOiBQcm9taXNlPD9IYWNrRGVmaW5pdGlvblJlc3VsdD4ge1xuICBjb25zdCBzZWFyY2hUeXBlcyA9IHN5bWJvbFR5cGVUb1NlYXJjaFR5cGVzKHN5bWJvbFR5cGUpO1xuICBjb25zdCBzZWFyY2hSZXNwb25zZSA9IGF3YWl0IGdldFNlYXJjaFJlc3VsdHMoZmlsZSwgcXVlcnksIHNlYXJjaFR5cGVzKTtcbiAgcmV0dXJuIHNlbGVjdERlZmluaXRpb25TZWFyY2hSZXN1bHRzKHNlYXJjaFJlc3BvbnNlLCBxdWVyeSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRJZGVudGlmaWVyRGVmaW5pdGlvbihcbiAgZmlsZTogTnVjbGlkZVVyaSxcbiAgY29udGVudHM6IHN0cmluZyxcbiAgbGluZTogbnVtYmVyLFxuICBjb2x1bW46IG51bWJlcixcbik6IFByb21pc2U8P0hhY2tEZWZpbml0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IGhoUmVzdWx0ID0gYXdhaXQgY2FsbEhIQ2xpZW50KFxuICAgIC8vIFRoZSBgaW5kZXRpZnktZnVuY3Rpb25gIHJlc3VsdCBpcyB0ZXh0LCBidXQgcGFzc2luZyAtLWpzb24gb3B0aW9uXG4gICAgLy8gd2lsbCBlbGltaW5hdGUgYW55IGhoIHN0YXR1cyBtZXNzYWdlcyB0aGF0J3MgaXJyZWxldmFudC5cbiAgICAvKmFyZ3MqLyBbJy0tanNvbicsICctLWlkZW50aWZ5LWZ1bmN0aW9uJywgYCR7bGluZX06JHtjb2x1bW59YF0sXG4gICAgLyplcnJvclN0cmVhbSovIGZhbHNlLFxuICAgIC8qb3V0cHV0SnNvbiovIGZhbHNlLFxuICAgIC8qcHJvY2Vzc0lucHV0Ki8gY29udGVudHMsXG4gICAgLypjd2QqLyBmaWxlLFxuICApO1xuICBpZiAoIWhoUmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaWRlbnRpZmllciA9IChoaFJlc3VsdC5yZXN1bHQgfHwgJycpLnRyaW0oKTtcbiAgaWYgKCFpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VhcmNoUmVzcG9uc2UgPSBhd2FpdCBnZXRTZWFyY2hSZXN1bHRzKGZpbGUsIGlkZW50aWZpZXIpO1xuICByZXR1cm4gc2VsZWN0RGVmaW5pdGlvblNlYXJjaFJlc3VsdHMoc2VhcmNoUmVzcG9uc2UsIGlkZW50aWZpZXIpO1xufVxuXG4vKipcbiAqIEZldGNoZXMgdGhlIGRlcGVuZGVuY2llcyBuZWVkZWQgYnkgdGhlIGhhY2sgd29ya2VyIHRvIGNhY2hlXG4gKiBmb3IgZmFzdGVyIGhhY2sgZmVhdHVyZXMgcmVzcG9uc2UgdGltZXMuXG4gKiBSZXR1cm5zIGEgbWFwIG9mIGZpbGUgcGF0aHMgdG8gZmlsZSBjb250ZW50cy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhcbiAgZmlsZVBhdGg6IE51Y2xpZGVVcmksXG4gIGRlcGVuZGVuY2llc0luZm86IEFycmF5PHtuYW1lOiBzdHJpbmc7IHR5cGU6IHN0cmluZ30+LFxuKTogUHJvbWlzZTw/e1xuICBoYWNrUm9vdDogTnVjbGlkZVVyaTtcbiAgZGVwZW5kZW5jaWVzOiBNYXA8c3RyaW5nLCBzdHJpbmc+O1xufT4ge1xuICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGRlcGVuZGVuY3lQYXRocyA9IG5ldyBTZXQoKTtcbiAgbGV0IGhhY2tSb290ID0gJyc7XG4gIC8vIGhoX3NlcnZlciBjdXJyZW50bHkgaXMgc2luZ2xlIHRocmVhZGVkIGFuZCBwcm9jZXNzZXMgb25lIHJlcXVlc3QgYXQgYSB0aW1lLlxuICAvLyBIZW5jZSwgd2UgZmV0Y2ggdGhlIGRlcGVuZGVuY2llcyBvbmUtYnktb25lLCB3aXRob3V0IFByb21pc2UuYWxsIGZvciB0aGUgaGFjayBzZWFyY2hcbiAgLy8gdG8gdW5ibG9jayB1c2VyLXJlcXVlc3RlZCBoYWNrIGxhbmd1YWdlIGZlYXR1cmVzIGFuZCBmYWlscnkgdHJlYXQgb3RoZXIgdXNhZ2VzIG9mIGhoX2NsaWVudC5cbiAgLyogZXNsaW50LWRpc2FibGUgYmFiZWwvbm8tYXdhaXQtaW4tbG9vcCAqL1xuICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZGVwZW5kZW5jaWVzSW5mbykge1xuICAgIGxldCB7bmFtZTogZGVwZW5kZW5jeU5hbWUsIHR5cGU6IGRlcGVuZGVuY3lUeXBlfSA9IGRlcGVuZGVuY3k7XG4gICAgaWYgKGRlcGVuZGVuY3lOYW1lLnN0YXJ0c1dpdGgoJ1xcXFwnKSkge1xuICAgICAgZGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbmN5TmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGxldCBmaWx0ZXI7XG4gICAgaWYgKGRlcGVuZGVuY3lUeXBlID09PSAnY2xhc3MnKSB7XG4gICAgICBmaWx0ZXIgPSBbXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuQ0xBU1MsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuQUJTVFJBQ1RfQ0xBU1MsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuVFJBSVQsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuVFlQRURFRixcbiAgICAgICAgU2VhcmNoUmVzdWx0VHlwZS5JTlRFUkZBQ0UsXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWx0ZXIgPSBbU2VhcmNoUmVzdWx0VHlwZS5GVU5DVElPTl07XG4gICAgfVxuXG4gICAgY29uc3Qgc2VhcmNoUmVzcG9uc2UgPSBhd2FpdCBnZXRTZWFyY2hSZXN1bHRzKGZpbGVQYXRoLCBkZXBlbmRlbmN5TmFtZSwgZmlsdGVyKTtcbiAgICBpZiAoc2VhcmNoUmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGludmFyaWFudChzZWFyY2hSZXNwb25zZSk7XG4gICAgY29uc3Qge3Jlc3VsdDogc2VhcmNoUmVzdWx0c30gPSBzZWFyY2hSZXNwb25zZTtcbiAgICBoYWNrUm9vdCA9IHNlYXJjaFJlc3BvbnNlLmhhY2tSb290O1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHNlYXJjaFJlc3VsdHMubWFwKGFzeW5jIChsb2NhdGlvbikgPT4ge1xuICAgICAgY29uc3Qge25hbWUsIHBhdGh9ID0gbG9jYXRpb247XG4gICAgICBpZiAobmFtZSAhPT0gZGVwZW5kZW5jeU5hbWUgfHwgZGVwZW5kZW5jeVBhdGhzLmhhcyhwYXRoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZXBlbmRlbmN5UGF0aHMuYWRkKHBhdGgpO1xuICAgICAgbGV0IGNvbnRlbnRzID0gYXdhaXQgZnNQcm9taXNlLnJlYWRGaWxlKHBhdGgsICd1dGY4Jyk7XG4gICAgICBpZiAoIWNvbnRlbnRzLnN0YXJ0c1dpdGgoJzw/aGgnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHR1cm5zIGFueXRoaW5nIHdlJ3JlIGFkZGluZyBpbnRvIGRlY2wgbW9kZSwgc28gdGhhdCBpdCB1c2VzIGxlc3MgbWVtb3J5LlxuICAgICAgLy8gSWRlYWxseSwgaGhfc2VydmVyIHNob3VsZCBkbyB0aGlzLCBhbmQgc3RyaXAgdGhlIG1ldGhvZC9mdW5jdGlvbiBib2RpZXMuXG4gICAgICBpZiAoY29udGVudHMuc3RhcnRzV2l0aChISF9ORVdMSU5FKSkge1xuICAgICAgICBjb250ZW50cyA9ICc8P2hoIC8vIGRlY2xcXG4nICsgY29udGVudHMuc3Vic3RyaW5nKEhIX05FV0xJTkUubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGVudHMuc3RhcnRzV2l0aChISF9TVFJJQ1RfTkVXTElORSkpIHtcbiAgICAgICAgY29udGVudHMgPSAnPD9oaCAvLyBkZWNsXFxuJyArIGNvbnRlbnRzLnN1YnN0cmluZyhISF9TVFJJQ1RfTkVXTElORS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgZGVwZW5kZW5jaWVzLnNldChwYXRoLCBjb250ZW50cyk7XG4gICAgfSkpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgYmFiZWwvbm8tYXdhaXQtaW4tbG9vcCAqL1xuICByZXR1cm4ge1xuICAgIGhhY2tSb290LFxuICAgIGRlcGVuZGVuY2llcyxcbiAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlZmVyZW5jZXMoXG4gIGZpbGVQYXRoOiBOdWNsaWRlVXJpLFxuICBzeW1ib2xOYW1lOiBzdHJpbmcsXG4gIHN5bWJvbFR5cGU/OiBTeW1ib2xUeXBlVmFsdWUsXG4pOiBQcm9taXNlPD9IYWNrUmVmZXJlbmNlc1Jlc3VsdD4ge1xuICBsZXQgY21kID0gJy0tZmluZC1yZWZzJztcbiAgaWYgKHN5bWJvbFR5cGUgPT09IFN5bWJvbFR5cGUuQ0xBU1MpIHtcbiAgICBjbWQgPSAnLS1maW5kLWNsYXNzLXJlZnMnO1xuICB9XG4gIGNvbnN0IGhoUmVzdWx0ID0gYXdhaXQgY2FsbEhIQ2xpZW50KFxuICAgIC8qYXJncyovIFtjbWQsIHN5bWJvbE5hbWVdLFxuICAgIC8qZXJyb3JTdHJlYW0qLyBmYWxzZSxcbiAgICAvKm91dHB1dEpzb24qLyB0cnVlLFxuICAgIC8qcHJvY2Vzc0lucHV0Ki8gbnVsbCxcbiAgICAvKmZpbGUqLyBmaWxlUGF0aCxcbiAgKTtcbiAgaWYgKCFoaFJlc3VsdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHtoYWNrUm9vdCwgcmVzdWx0fSA9IGhoUmVzdWx0O1xuICBjb25zdCByZWZlcmVuY2VzID0gKChyZXN1bHQ6IGFueSk6IEFycmF5PEhhY2tSZWZlcmVuY2U+KTtcbiAgcmV0dXJuIHtcbiAgICBoYWNrUm9vdCxcbiAgICByZWZlcmVuY2VzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFja0Vudmlyb25tZW50RGV0YWlscyhcbiAgbG9jYWxGaWxlOiBzdHJpbmcsXG4pOiBQcm9taXNlPD97aGFja1Jvb3Q6IHN0cmluZywgaGFja0NvbW1hbmQ6IHN0cmluZ30+IHtcbiAgcmV0dXJuIGdldEhhY2tFeGVjT3B0aW9ucyhsb2NhbEZpbGUpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3REZWZpbml0aW9uU2VhcmNoUmVzdWx0cyhcbiAgc2VhcmNoUmVwb3Nuc2U6ID9IYWNrU2VhcmNoUmVzdWx0LFxuICBxdWVyeTogc3RyaW5nLFxuKTogP0hhY2tEZWZpbml0aW9uUmVzdWx0IHtcbiAgaWYgKCFzZWFyY2hSZXBvc25zZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHtyZXN1bHQ6IHNlYXJjaFJlc3VsdHMsIGhhY2tSb290fSA9IHNlYXJjaFJlcG9zbnNlO1xuICBjb25zdCBtYXRjaGluZ1Jlc3VsdHMgPSBzZWFyY2hSZXN1bHRzLmZpbHRlcihyZXN1bHQgPT4ge1xuICAgIC8vIElmIHRoZSByZXF1ZXN0IGhhZCBhIDo6IGluIGl0LCBpdCdzIGEgZnVsbCBuYW1lLCBzbyB3ZSBzaG91bGQgY29tcGFyZSB0b1xuICAgIC8vIHRoZSBuYW1lIG9mIHRoZSByZXN1bHQgaW4gdGhhdCBmb3JtYXQuXG4gICAgbGV0IGZ1bGxOYW1lID0gcmVzdWx0Lm5hbWU7XG4gICAgaWYgKHF1ZXJ5LmluZGV4T2YoJzo6JykgIT09IC0xICYmIHJlc3VsdC5zY29wZSkge1xuICAgICAgZnVsbE5hbWUgPSByZXN1bHQuc2NvcGUgKyAnOjonICsgZnVsbE5hbWU7XG4gICAgfVxuICAgIHJldHVybiBmdWxsTmFtZSA9PT0gcXVlcnk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhhY2tSb290LFxuICAgIGRlZmluaXRpb25zOiBtYXRjaGluZ1Jlc3VsdHMsXG4gIH07XG59XG4iXX0=
