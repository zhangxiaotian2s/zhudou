Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _rx = require('rx');

var _nuclideLogging = require('nuclide-logging');

var _nuclideCommons = require('nuclide-commons');

var _FlowHelpersJs = require('./FlowHelpers.js');

var _FlowConstants = require('./FlowConstants');

// Names modeled after https://github.com/facebook/flow/blob/master/src/common/flowExitStatus.ml
'use babel';

var logger = (0, _nuclideLogging.getLogger)();

var FLOW_RETURN_CODES = {
  ok: 0,
  serverInitializing: 1,
  typeError: 2,
  noServerRunning: 6,
  // This means that the server exists, but it is not responding, typically because it is busy doing
  // other work.
  outOfRetries: 7,
  buildIdMismatch: 9
};

exports.FLOW_RETURN_CODES = FLOW_RETURN_CODES;
var SERVER_READY_TIMEOUT_MS = 10 * 1000;

var EXEC_FLOW_RETRIES = 5;

var FlowProcess = (function () {
  function FlowProcess(root) {
    var _this = this;

    _classCallCheck(this, FlowProcess);

    this._serverStatus = new _rx.BehaviorSubject(_FlowConstants.ServerStatus.UNKNOWN);
    this._root = root;

    this._serverStatus.filter(function (x) {
      return x === _FlowConstants.ServerStatus.NOT_RUNNING;
    }).subscribe(function () {
      _this._startFlowServer();
      _this._pingServer();
    });
    function isBusyOrInit(status) {
      return status === _FlowConstants.ServerStatus.BUSY || status === _FlowConstants.ServerStatus.INIT;
    }
    this._serverStatus.filter(isBusyOrInit).subscribe(function () {
      _this._pingServer();
    });
  }

  _createClass(FlowProcess, [{
    key: 'dispose',
    value: function dispose() {
      this._serverStatus.onCompleted();
      if (this._startedServer) {
        // The default, SIGTERM, does not reliably kill the flow servers.
        this._startedServer.kill('SIGKILL');
      }
    }
  }, {
    key: 'getServerStatusUpdates',
    value: function getServerStatusUpdates() {
      return this._serverStatus.asObservable();
    }

    /**
     * Returns null if Flow cannot be found.
     */
  }, {
    key: 'execFlow',
    value: _asyncToGenerator(function* (args, options, file) {
      var waitForServer = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      var maxRetries = waitForServer ? EXEC_FLOW_RETRIES : 0;
      if (this._serverStatus.getValue() === _FlowConstants.ServerStatus.failed) {
        return null;
      }
      for (var i = 0;; i++) {
        try {
          var result = yield this._rawExecFlow( // eslint-disable-line babel/no-await-in-loop
          args, options);
          return result;
        } catch (e) {
          var couldRetry = [_FlowConstants.ServerStatus.NOT_RUNNING, _FlowConstants.ServerStatus.INIT, _FlowConstants.ServerStatus.BUSY].indexOf(this._serverStatus.getValue()) !== -1;
          if (i < maxRetries && couldRetry) {
            yield this._serverIsReady(); // eslint-disable-line babel/no-await-in-loop
            // Then try again.
          } else {
              // If it couldn't retry, it means there was a legitimate error. If it could retry, we
              // don't want to log because it just means the server is busy and we don't want to wait.
              if (!couldRetry) {
                // not sure what happened, but we'll let the caller deal with it
                logger.error('Flow failed: flow ' + args.join(' ') + '. Error: ' + JSON.stringify(e));
              }
              throw e;
            }
          // try again
        }
      }
      // otherwise flow complains
      return null;
    })

    /** Starts a Flow server in the current root */
  }, {
    key: '_startFlowServer',
    value: _asyncToGenerator(function* () {
      var _this2 = this;

      var pathToFlow = (0, _FlowHelpersJs.getPathToFlow)();
      // `flow server` will start a server in the foreground. asyncExecute
      // will not resolve the promise until the process exits, which in this
      // case is never. We need to use spawn directly to get access to the
      // ChildProcess object.
      var serverProcess = yield (0, _nuclideCommons.safeSpawn)( // eslint-disable-line babel/no-await-in-loop
      pathToFlow, ['server', this._root]);
      var logIt = function logIt(data) {
        logger.debug('flow server: ' + data);
      };
      serverProcess.stdout.on('data', logIt);
      serverProcess.stderr.on('data', logIt);
      serverProcess.on('exit', function (code, signal) {
        // We only want to blacklist this root if the Flow processes
        // actually failed, rather than being killed manually. It seems that
        // if they are killed, the code is null and the signal is 'SIGTERM'.
        // In the Flow crashes I have observed, the code is 2 and the signal
        // is null. So, let's blacklist conservatively for now and we can
        // add cases later if we observe Flow crashes that do not fit this
        // pattern.
        if (code === 2 && signal === null) {
          logger.error('Flow server unexpectedly exited', _this2._root);
          _this2._serverStatus.onNext(_FlowConstants.ServerStatus.FAILED);
          _this2._serverStatus.onCompleted();
        }
      });
      this._startedServer = serverProcess;
    })

    /** Execute Flow with the given arguments */
  }, {
    key: '_rawExecFlow',
    value: _asyncToGenerator(function* (args) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var flowOptions = yield this._getFlowExecOptions();
      if (!flowOptions) {
        return null;
      }
      options = _extends({}, flowOptions, options);
      args = [].concat(_toConsumableArray(args), ['--retry-if-init', 'false', '--retries', '0', '--no-auto-start', '--from', 'nuclide']);
      var pathToFlow = (0, _FlowHelpersJs.getPathToFlow)();
      try {
        var result = yield (0, _nuclideCommons.asyncExecute)(pathToFlow, args, options);
        this._updateServerStatus(result);
        return result;
      } catch (e) {
        this._updateServerStatus(e);
        if (e.exitCode === FLOW_RETURN_CODES.typeError) {
          return e;
        } else {
          throw e;
        }
      }
    })
  }, {
    key: '_updateServerStatus',
    value: function _updateServerStatus(result) {
      var status = undefined;
      if (result == null) {
        status = _FlowConstants.ServerStatus.NOT_INSTALLED;
      } else {
        switch (result.exitCode) {
          case FLOW_RETURN_CODES.ok:
          // falls through
          case FLOW_RETURN_CODES.typeError:
            status = _FlowConstants.ServerStatus.READY;
            break;
          case FLOW_RETURN_CODES.serverInitializing:
            status = _FlowConstants.ServerStatus.INIT;
            break;
          case FLOW_RETURN_CODES.noServerRunning:
            status = _FlowConstants.ServerStatus.NOT_RUNNING;
            break;
          case FLOW_RETURN_CODES.outOfRetries:
            status = _FlowConstants.ServerStatus.BUSY;
            break;
          case FLOW_RETURN_CODES.buildIdMismatch:
            // If the version doesn't match, the server is automatically killed and the client
            // returns 9.
            logger.info('Killed flow server with incorrect version in', this._root);
            status = _FlowConstants.ServerStatus.NOT_RUNNING;
            break;
          default:
            logger.error('Unknown return code from Flow: ' + result.exitCode);
            status = _FlowConstants.ServerStatus.UNKNOWN;
        }
      }
      (0, _assert2['default'])(status != null);
      if (status !== this._serverStatus.getValue()) {
        this._serverStatus.onNext(status);
      }
    }

    /** Ping the server until it leaves the current state */
  }, {
    key: '_pingServer',
    value: _asyncToGenerator(function* () {
      var tries = arguments.length <= 0 || arguments[0] === undefined ? 5 : arguments[0];

      var fromState = this._serverStatus.getValue();
      var stateChanged = false;
      this._serverStatus.filter(function (newState) {
        return newState !== fromState;
      }).first().subscribe(function () {
        stateChanged = true;
      });
      for (var i = 0; !stateChanged && i < tries; i++) {
        /* eslint-disable babel/no-await-in-loop */
        yield this._rawExecFlow(['status'])['catch'](function () {
          return null;
        });
        // Wait 1 second
        yield _rx.Observable.just(null).delay(1000).toPromise();
        /* eslint-enable babel/no-await-in-loop */
      }
    })

    /**
     * Resolves when the server is ready or the request times out, as indicated by the result of the
     * returned Promise.
     */
  }, {
    key: '_serverIsReady',
    value: function _serverIsReady() {
      return this._serverStatus.filter(function (x) {
        return x === _FlowConstants.ServerStatus.READY;
      }).map(function () {
        return true;
      }).timeout(SERVER_READY_TIMEOUT_MS, _rx.Observable.just(false)).first().toPromise();
    }

    /**
    * If this returns null, then it is not safe to run flow.
    */
  }, {
    key: '_getFlowExecOptions',
    value: _asyncToGenerator(function* () {
      var installed = yield (0, _FlowHelpersJs.isFlowInstalled)();
      if (installed) {
        return {
          cwd: this._root
        };
      } else {
        return null;
      }
    })
  }]);

  return FlowProcess;
})();

exports.FlowProcess = FlowProcess;

// If we had to start a Flow server, store the process here so we can kill it when we shut down.

// The current state of the Flow server in this directory

// The path to the directory where the .flowconfig is -- i.e. the root of the Flow project.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWZsb3ctYmFzZS9saWIvRmxvd1Byb2Nlc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQWVzQixRQUFROzs7O2tCQUVZLElBQUk7OzhCQUV0QixpQkFBaUI7OzhCQU1sQyxpQkFBaUI7OzZCQUtqQixrQkFBa0I7OzZCQUVFLGlCQUFpQjs7O0FBaEM1QyxXQUFXLENBQUM7O0FBb0JaLElBQU0sTUFBTSxHQUFHLG9CQURQLFNBQVMsR0FDUyxDQUFDOztBQWVwQixJQUFNLGlCQUFpQixHQUFHO0FBQy9CLElBQUUsRUFBRSxDQUFDO0FBQ0wsb0JBQWtCLEVBQUUsQ0FBQztBQUNyQixXQUFTLEVBQUUsQ0FBQztBQUNaLGlCQUFlLEVBQUUsQ0FBQzs7O0FBR2xCLGNBQVksRUFBRSxDQUFDO0FBQ2YsaUJBQWUsRUFBRSxDQUFDO0NBQ25CLENBQUM7OztBQUVGLElBQU0sdUJBQXVCLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQzs7QUFFMUMsSUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7O0lBRWYsV0FBVztBQVFYLFdBUkEsV0FBVyxDQVFWLElBQVksRUFBRTs7OzBCQVJmLFdBQVc7O0FBU3BCLFFBQUksQ0FBQyxhQUFhLEdBQUcsUUExQ2pCLGVBQWUsQ0EwQ3NCLGVBM0JyQyxZQUFZLENBMkJzQyxPQUFPLENBQUMsQ0FBQztBQUMvRCxRQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7QUFFbEIsUUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsVUFBQSxDQUFDO2FBQUksQ0FBQyxLQUFLLGVBOUJqQyxZQUFZLENBOEJrQyxXQUFXO0tBQUEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxZQUFNO0FBQzdFLFlBQUssZ0JBQWdCLEVBQUUsQ0FBQztBQUN4QixZ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QUM7ZUFBTSxJQUFJO09BQUEsQ0FBQyxDQUNmLE9BQU8sQ0FDTix1QkFBdUIsRUFDdkIsSUE1T2lCLFVBQVUsQ0E0T2hCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FDdkIsQ0FDQSxLQUFLLEVBQUUsQ0FDUCxTQUFTLEVBQUUsQ0FBQztLQUNoQjs7Ozs7Ozs2QkFLd0IsYUFBNEI7QUFDbkQsVUFBTSxTQUFTLEdBQUcsTUFBTSxtQkEzTzFCLGVBQWUsR0EyTzRCLENBQUM7QUFDMUMsVUFBSSxTQUFTLEVBQUU7QUFDYixlQUFPO0FBQ0wsYUFBRyxFQUFFLElBQUksQ0FBQyxLQUFLO1NBQ2hCLENBQUM7T0FDSCxNQUFNO0FBQ0wsZUFBTyxJQUFJLENBQUM7T0FDYjtLQUNGOzs7U0E3TlUsV0FBVyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1mbG93LWJhc2UvbGliL0Zsb3dQcm9jZXNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHR5cGUge3Byb2Nlc3MkYXN5bmNFeGVjdXRlUmV0fSBmcm9tICdudWNsaWRlLWNvbW1vbnMnO1xuXG5pbXBvcnQgdHlwZSB7U2VydmVyU3RhdHVzVHlwZX0gZnJvbSAnLi9GbG93U2VydmljZSc7XG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcblxuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGV9IGZyb20gJ3J4JztcblxuaW1wb3J0IHtnZXRMb2dnZXJ9IGZyb20gJ251Y2xpZGUtbG9nZ2luZyc7XG5jb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKTtcblxuaW1wb3J0IHtcbiAgYXN5bmNFeGVjdXRlLFxuICBzYWZlU3Bhd24sXG59IGZyb20gJ251Y2xpZGUtY29tbW9ucyc7XG5cbmltcG9ydCB7XG4gIGlzRmxvd0luc3RhbGxlZCxcbiAgZ2V0UGF0aFRvRmxvdyxcbn0gZnJvbSAnLi9GbG93SGVscGVycy5qcyc7XG5cbmltcG9ydCB7U2VydmVyU3RhdHVzfSBmcm9tICcuL0Zsb3dDb25zdGFudHMnO1xuXG4vLyBOYW1lcyBtb2RlbGVkIGFmdGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2Jsb2IvbWFzdGVyL3NyYy9jb21tb24vZmxvd0V4aXRTdGF0dXMubWxcbmV4cG9ydCBjb25zdCBGTE9XX1JFVFVSTl9DT0RFUyA9IHtcbiAgb2s6IDAsXG4gIHNlcnZlckluaXRpYWxpemluZzogMSxcbiAgdHlwZUVycm9yOiAyLFxuICBub1NlcnZlclJ1bm5pbmc6IDYsXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgc2VydmVyIGV4aXN0cywgYnV0IGl0IGlzIG5vdCByZXNwb25kaW5nLCB0eXBpY2FsbHkgYmVjYXVzZSBpdCBpcyBidXN5IGRvaW5nXG4gIC8vIG90aGVyIHdvcmsuXG4gIG91dE9mUmV0cmllczogNyxcbiAgYnVpbGRJZE1pc21hdGNoOiA5LFxufTtcblxuY29uc3QgU0VSVkVSX1JFQURZX1RJTUVPVVRfTVMgPSAxMCAqIDEwMDA7XG5cbmNvbnN0IEVYRUNfRkxPV19SRVRSSUVTID0gNTtcblxuZXhwb3J0IGNsYXNzIEZsb3dQcm9jZXNzIHtcbiAgLy8gSWYgd2UgaGFkIHRvIHN0YXJ0IGEgRmxvdyBzZXJ2ZXIsIHN0b3JlIHRoZSBwcm9jZXNzIGhlcmUgc28gd2UgY2FuIGtpbGwgaXQgd2hlbiB3ZSBzaHV0IGRvd24uXG4gIF9zdGFydGVkU2VydmVyOiA/Y2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M7XG4gIC8vIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBGbG93IHNlcnZlciBpbiB0aGlzIGRpcmVjdG9yeVxuICBfc2VydmVyU3RhdHVzOiBCZWhhdmlvclN1YmplY3Q8U2VydmVyU3RhdHVzVHlwZT47XG4gIC8vIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIC5mbG93Y29uZmlnIGlzIC0tIGkuZS4gdGhlIHJvb3Qgb2YgdGhlIEZsb3cgcHJvamVjdC5cbiAgX3Jvb3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihyb290OiBzdHJpbmcpIHtcbiAgICB0aGlzLl9zZXJ2ZXJTdGF0dXMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFNlcnZlclN0YXR1cy5VTktOT1dOKTtcbiAgICB0aGlzLl9yb290ID0gcm9vdDtcblxuICAgIHRoaXMuX3NlcnZlclN0YXR1cy5maWx0ZXIoeCA9PiB4ID09PSBTZXJ2ZXJTdGF0dXMuTk9UX1JVTk5JTkcpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9zdGFydEZsb3dTZXJ2ZXIoKTtcbiAgICAgIHRoaXMuX3BpbmdTZXJ2ZXIoKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpc0J1c3lPckluaXQoc3RhdHVzOiBTZXJ2ZXJTdGF0dXNUeXBlKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBTZXJ2ZXJTdGF0dXMuQlVTWSB8fCBzdGF0dXMgPT09IFNlcnZlclN0YXR1cy5JTklUO1xuICAgIH1cbiAgICB0aGlzLl9zZXJ2ZXJTdGF0dXMuZmlsdGVyKGlzQnVzeU9ySW5pdCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuX3BpbmdTZXJ2ZXIoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5fc2VydmVyU3RhdHVzLm9uQ29tcGxldGVkKCk7XG4gICAgaWYgKHRoaXMuX3N0YXJ0ZWRTZXJ2ZXIpIHtcbiAgICAgIC8vIFRoZSBkZWZhdWx0LCBTSUdURVJNLCBkb2VzIG5vdCByZWxpYWJseSBraWxsIHRoZSBmbG93IHNlcnZlcnMuXG4gICAgICB0aGlzLl9zdGFydGVkU2VydmVyLmtpbGwoJ1NJR0tJTEwnKTtcbiAgICB9XG4gIH1cblxuICBnZXRTZXJ2ZXJTdGF0dXNVcGRhdGVzKCk6IE9ic2VydmFibGU8U2VydmVyU3RhdHVzVHlwZT4ge1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJTdGF0dXMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBudWxsIGlmIEZsb3cgY2Fubm90IGJlIGZvdW5kLlxuICAgKi9cbiAgYXN5bmMgZXhlY0Zsb3coXG4gICAgYXJnczogQXJyYXk8YW55PixcbiAgICBvcHRpb25zOiBPYmplY3QsXG4gICAgZmlsZTogc3RyaW5nLFxuICAgIHdhaXRGb3JTZXJ2ZXI/OiBib29sZWFuID0gZmFsc2UsXG4gICk6IFByb21pc2U8P3Byb2Nlc3MkYXN5bmNFeGVjdXRlUmV0PiB7XG4gICAgY29uc3QgbWF4UmV0cmllcyA9IHdhaXRGb3JTZXJ2ZXIgPyBFWEVDX0ZMT1dfUkVUUklFUyA6IDA7XG4gICAgaWYgKHRoaXMuX3NlcnZlclN0YXR1cy5nZXRWYWx1ZSgpID09PSBTZXJ2ZXJTdGF0dXMuZmFpbGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9yYXdFeGVjRmxvdyggLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYWJlbC9uby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBjb3VsZFJldHJ5ID0gW1NlcnZlclN0YXR1cy5OT1RfUlVOTklORywgU2VydmVyU3RhdHVzLklOSVQsIFNlcnZlclN0YXR1cy5CVVNZXVxuICAgICAgICAgIC5pbmRleE9mKHRoaXMuX3NlcnZlclN0YXR1cy5nZXRWYWx1ZSgpKSAhPT0gLTE7XG4gICAgICAgIGlmIChpIDwgbWF4UmV0cmllcyAmJiBjb3VsZFJldHJ5KSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fc2VydmVySXNSZWFkeSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhYmVsL25vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAvLyBUaGVuIHRyeSBhZ2Fpbi5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBpdCBjb3VsZG4ndCByZXRyeSwgaXQgbWVhbnMgdGhlcmUgd2FzIGEgbGVnaXRpbWF0ZSBlcnJvci4gSWYgaXQgY291bGQgcmV0cnksIHdlXG4gICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBsb2cgYmVjYXVzZSBpdCBqdXN0IG1lYW5zIHRoZSBzZXJ2ZXIgaXMgYnVzeSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YWl0LlxuICAgICAgICAgIGlmICghY291bGRSZXRyeSkge1xuICAgICAgICAgICAgLy8gbm90IHN1cmUgd2hhdCBoYXBwZW5lZCwgYnV0IHdlJ2xsIGxldCB0aGUgY2FsbGVyIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGbG93IGZhaWxlZDogZmxvdyAke2FyZ3Muam9pbignICcpfS4gRXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoZSl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJ5IGFnYWluXG4gICAgICB9XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSBmbG93IGNvbXBsYWluc1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIFN0YXJ0cyBhIEZsb3cgc2VydmVyIGluIHRoZSBjdXJyZW50IHJvb3QgKi9cbiAgYXN5bmMgX3N0YXJ0Rmxvd1NlcnZlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwYXRoVG9GbG93ID0gZ2V0UGF0aFRvRmxvdygpO1xuICAgIC8vIGBmbG93IHNlcnZlcmAgd2lsbCBzdGFydCBhIHNlcnZlciBpbiB0aGUgZm9yZWdyb3VuZC4gYXN5bmNFeGVjdXRlXG4gICAgLy8gd2lsbCBub3QgcmVzb2x2ZSB0aGUgcHJvbWlzZSB1bnRpbCB0aGUgcHJvY2VzcyBleGl0cywgd2hpY2ggaW4gdGhpc1xuICAgIC8vIGNhc2UgaXMgbmV2ZXIuIFdlIG5lZWQgdG8gdXNlIHNwYXduIGRpcmVjdGx5IHRvIGdldCBhY2Nlc3MgdG8gdGhlXG4gICAgLy8gQ2hpbGRQcm9jZXNzIG9iamVjdC5cbiAgICBjb25zdCBzZXJ2ZXJQcm9jZXNzID0gYXdhaXQgc2FmZVNwYXduKCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhYmVsL25vLWF3YWl0LWluLWxvb3BcbiAgICAgIHBhdGhUb0Zsb3csXG4gICAgICBbJ3NlcnZlcicsIHRoaXMuX3Jvb3RdLFxuICAgICk7XG4gICAgY29uc3QgbG9nSXQgPSBkYXRhID0+IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnZmxvdyBzZXJ2ZXI6ICcgKyBkYXRhKTtcbiAgICB9O1xuICAgIHNlcnZlclByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgbG9nSXQpO1xuICAgIHNlcnZlclByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgbG9nSXQpO1xuICAgIHNlcnZlclByb2Nlc3Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gYmxhY2tsaXN0IHRoaXMgcm9vdCBpZiB0aGUgRmxvdyBwcm9jZXNzZXNcbiAgICAgIC8vIGFjdHVhbGx5IGZhaWxlZCwgcmF0aGVyIHRoYW4gYmVpbmcga2lsbGVkIG1hbnVhbGx5LiBJdCBzZWVtcyB0aGF0XG4gICAgICAvLyBpZiB0aGV5IGFyZSBraWxsZWQsIHRoZSBjb2RlIGlzIG51bGwgYW5kIHRoZSBzaWduYWwgaXMgJ1NJR1RFUk0nLlxuICAgICAgLy8gSW4gdGhlIEZsb3cgY3Jhc2hlcyBJIGhhdmUgb2JzZXJ2ZWQsIHRoZSBjb2RlIGlzIDIgYW5kIHRoZSBzaWduYWxcbiAgICAgIC8vIGlzIG51bGwuIFNvLCBsZXQncyBibGFja2xpc3QgY29uc2VydmF0aXZlbHkgZm9yIG5vdyBhbmQgd2UgY2FuXG4gICAgICAvLyBhZGQgY2FzZXMgbGF0ZXIgaWYgd2Ugb2JzZXJ2ZSBGbG93IGNyYXNoZXMgdGhhdCBkbyBub3QgZml0IHRoaXNcbiAgICAgIC8vIHBhdHRlcm4uXG4gICAgICBpZiAoY29kZSA9PT0gMiAmJiBzaWduYWwgPT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGbG93IHNlcnZlciB1bmV4cGVjdGVkbHkgZXhpdGVkJywgdGhpcy5fcm9vdCk7XG4gICAgICAgIHRoaXMuX3NlcnZlclN0YXR1cy5vbk5leHQoU2VydmVyU3RhdHVzLkZBSUxFRCk7XG4gICAgICAgIHRoaXMuX3NlcnZlclN0YXR1cy5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3N0YXJ0ZWRTZXJ2ZXIgPSBzZXJ2ZXJQcm9jZXNzO1xuICB9XG5cbiAgLyoqIEV4ZWN1dGUgRmxvdyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMgKi9cbiAgYXN5bmMgX3Jhd0V4ZWNGbG93KGFyZ3M6IEFycmF5PGFueT4sIG9wdGlvbnM/OiBPYmplY3QgPSB7fSk6IFByb21pc2U8P3Byb2Nlc3MkYXN5bmNFeGVjdXRlUmV0PiB7XG4gICAgY29uc3QgZmxvd09wdGlvbnMgPSBhd2FpdCB0aGlzLl9nZXRGbG93RXhlY09wdGlvbnMoKTtcbiAgICBpZiAoIWZsb3dPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsuLi5mbG93T3B0aW9ucywgLi4ub3B0aW9uc307XG4gICAgYXJncyA9IFtcbiAgICAgIC4uLmFyZ3MsXG4gICAgICAnLS1yZXRyeS1pZi1pbml0JywgJ2ZhbHNlJyxcbiAgICAgICctLXJldHJpZXMnLCAnMCcsXG4gICAgICAnLS1uby1hdXRvLXN0YXJ0JyxcbiAgICAgICctLWZyb20nLCAnbnVjbGlkZScsXG4gICAgXTtcbiAgICBjb25zdCBwYXRoVG9GbG93ID0gZ2V0UGF0aFRvRmxvdygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhc3luY0V4ZWN1dGUocGF0aFRvRmxvdywgYXJncywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl91cGRhdGVTZXJ2ZXJTdGF0dXMocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5fdXBkYXRlU2VydmVyU3RhdHVzKGUpO1xuICAgICAgaWYgKGUuZXhpdENvZGUgPT09IEZMT1dfUkVUVVJOX0NPREVTLnR5cGVFcnJvcikge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVNlcnZlclN0YXR1cyhyZXN1bHQ6ID9wcm9jZXNzJGFzeW5jRXhlY3V0ZVJldCk6IHZvaWQge1xuICAgIGxldCBzdGF0dXM7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICBzdGF0dXMgPSBTZXJ2ZXJTdGF0dXMuTk9UX0lOU1RBTExFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChyZXN1bHQuZXhpdENvZGUpIHtcbiAgICAgICAgY2FzZSBGTE9XX1JFVFVSTl9DT0RFUy5vazpcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgRkxPV19SRVRVUk5fQ09ERVMudHlwZUVycm9yOlxuICAgICAgICAgIHN0YXR1cyA9IFNlcnZlclN0YXR1cy5SRUFEWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGTE9XX1JFVFVSTl9DT0RFUy5zZXJ2ZXJJbml0aWFsaXppbmc6XG4gICAgICAgICAgc3RhdHVzID0gU2VydmVyU3RhdHVzLklOSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRkxPV19SRVRVUk5fQ09ERVMubm9TZXJ2ZXJSdW5uaW5nOlxuICAgICAgICAgIHN0YXR1cyA9IFNlcnZlclN0YXR1cy5OT1RfUlVOTklORztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGTE9XX1JFVFVSTl9DT0RFUy5vdXRPZlJldHJpZXM6XG4gICAgICAgICAgc3RhdHVzID0gU2VydmVyU3RhdHVzLkJVU1k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRkxPV19SRVRVUk5fQ09ERVMuYnVpbGRJZE1pc21hdGNoOlxuICAgICAgICAgIC8vIElmIHRoZSB2ZXJzaW9uIGRvZXNuJ3QgbWF0Y2gsIHRoZSBzZXJ2ZXIgaXMgYXV0b21hdGljYWxseSBraWxsZWQgYW5kIHRoZSBjbGllbnRcbiAgICAgICAgICAvLyByZXR1cm5zIDkuXG4gICAgICAgICAgbG9nZ2VyLmluZm8oJ0tpbGxlZCBmbG93IHNlcnZlciB3aXRoIGluY29ycmVjdCB2ZXJzaW9uIGluJywgdGhpcy5fcm9vdCk7XG4gICAgICAgICAgc3RhdHVzID0gU2VydmVyU3RhdHVzLk5PVF9SVU5OSU5HO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxvZ2dlci5lcnJvcignVW5rbm93biByZXR1cm4gY29kZSBmcm9tIEZsb3c6ICcgKyByZXN1bHQuZXhpdENvZGUpO1xuICAgICAgICAgIHN0YXR1cyA9IFNlcnZlclN0YXR1cy5VTktOT1dOO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnZhcmlhbnQoc3RhdHVzICE9IG51bGwpO1xuICAgIGlmIChzdGF0dXMgIT09IHRoaXMuX3NlcnZlclN0YXR1cy5nZXRWYWx1ZSgpKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXJTdGF0dXMub25OZXh0KHN0YXR1cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFBpbmcgdGhlIHNlcnZlciB1bnRpbCBpdCBsZWF2ZXMgdGhlIGN1cnJlbnQgc3RhdGUgKi9cbiAgYXN5bmMgX3BpbmdTZXJ2ZXIodHJpZXM/OiBudW1iZXIgPSA1KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZnJvbVN0YXRlID0gdGhpcy5fc2VydmVyU3RhdHVzLmdldFZhbHVlKCk7XG4gICAgbGV0IHN0YXRlQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3NlcnZlclN0YXR1cy5maWx0ZXIobmV3U3RhdGUgPT4gbmV3U3RhdGUgIT09IGZyb21TdGF0ZSkuZmlyc3QoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgc3RhdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgIXN0YXRlQ2hhbmdlZCAmJiBpIDwgdHJpZXM7IGkrKykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgYmFiZWwvbm8tYXdhaXQtaW4tbG9vcCAqL1xuICAgICAgYXdhaXQgdGhpcy5fcmF3RXhlY0Zsb3coWydzdGF0dXMnXSkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAvLyBXYWl0IDEgc2Vjb25kXG4gICAgICBhd2FpdCBPYnNlcnZhYmxlLmp1c3QobnVsbCkuZGVsYXkoMTAwMCkudG9Qcm9taXNlKCk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGJhYmVsL25vLWF3YWl0LWluLWxvb3AgKi9cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgd2hlbiB0aGUgc2VydmVyIGlzIHJlYWR5IG9yIHRoZSByZXF1ZXN0IHRpbWVzIG91dCwgYXMgaW5kaWNhdGVkIGJ5IHRoZSByZXN1bHQgb2YgdGhlXG4gICAqIHJldHVybmVkIFByb21pc2UuXG4gICAqL1xuICBfc2VydmVySXNSZWFkeSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyU3RhdHVzXG4gICAgICAuZmlsdGVyKHggPT4geCA9PT0gU2VydmVyU3RhdHVzLlJFQURZKVxuICAgICAgLm1hcCgoKSA9PiB0cnVlKVxuICAgICAgLnRpbWVvdXQoXG4gICAgICAgIFNFUlZFUl9SRUFEWV9USU1FT1VUX01TLFxuICAgICAgICBPYnNlcnZhYmxlLmp1c3QoZmFsc2UpLFxuICAgICAgKVxuICAgICAgLmZpcnN0KClcbiAgICAgIC50b1Byb21pc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAqIElmIHRoaXMgcmV0dXJucyBudWxsLCB0aGVuIGl0IGlzIG5vdCBzYWZlIHRvIHJ1biBmbG93LlxuICAqL1xuICBhc3luYyBfZ2V0Rmxvd0V4ZWNPcHRpb25zKCk6IFByb21pc2U8P3tjd2Q6IHN0cmluZ30+IHtcbiAgICBjb25zdCBpbnN0YWxsZWQgPSBhd2FpdCBpc0Zsb3dJbnN0YWxsZWQoKTtcbiAgICBpZiAoaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjd2Q6IHRoaXMuX3Jvb3QsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==
