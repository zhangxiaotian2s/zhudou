Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/**
 * As defined in com.facebook.buck.cli.Command, some of Buck's subcommands are
 * read-only. The read-only commands can be executed in parallel, but the rest
 * must be executed serially.
 *
 * TODO(mbolin): This does not account for the case where the user runs
 * `buck build` from the command line while Nuclide is also trying to build.
 */
'use babel';

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _require = require('nuclide-commons');

var asyncExecute = _require.asyncExecute;
var scriptSafeSpawnAndObserveOutput = _require.scriptSafeSpawnAndObserveOutput;

var _require2 = require('nuclide-commons');

var fsPromise = _require2.fsPromise;

var logger = require('nuclide-logging').getLogger();
var path = require('path');

var BLOCKING_BUCK_COMMAND_QUEUE_PREFIX = 'buck';

/**
 * Represents a Buck project on disk. All Buck commands for a project should be
 * done through an instance of this class.
 */

var BuckProject = (function () {

  /**
   * @param options.rootPath Absolute path to the directory that contains the
   *     .buckconfig file to configure the project.
   */

  function BuckProject(options) {
    _classCallCheck(this, BuckProject);

    this._rootPath = options.rootPath;
    this._serialQueueName = BLOCKING_BUCK_COMMAND_QUEUE_PREFIX + this._rootPath;
  }

  _createClass(BuckProject, [{
    key: 'dispose',
    value: function dispose() {
      // This method is required by the service framework.
    }
  }, {
    key: 'getPath',
    value: function getPath() {
      return Promise.resolve(this._rootPath);
    }

    /**
     * This syntax is not supported yet, but the return type is:
     * Promise<{stdout: string; stderr: string; exitCode: number}>
     *
     * @param args Do not include 'buck' as the first argument: it will be added
     *     automatically.
     */
  }, {
    key: '_runBuckCommandFromProjectRoot',
    value: function _runBuckCommandFromProjectRoot(args) {
      var _getBuckCommandAndOptions2 = this._getBuckCommandAndOptions();

      var pathToBuck = _getBuckCommandAndOptions2.pathToBuck;
      var options = _getBuckCommandAndOptions2.buckCommandOptions;

      logger.debug('Buck command:', pathToBuck, args, options);
      return asyncExecute(pathToBuck, args, options);
    }

    /**
     * @return The path to buck and set of options to be used to run a `buck` command.
     */
  }, {
    key: '_getBuckCommandAndOptions',
    value: function _getBuckCommandAndOptions() {
      var pathToBuck = undefined;
      if (global.atom) {
        pathToBuck = global.atom.config.get('nuclide-buck-files.pathToBuck');
      } else {
        pathToBuck = 'buck';
      }
      var buckCommandOptions = {
        cwd: this._rootPath,
        queueName: this._serialQueueName
      };
      return { pathToBuck: pathToBuck, buckCommandOptions: buckCommandOptions };
    }
  }, {
    key: 'getOwner',
    value: _asyncToGenerator(function* (filePath) {
      var args = ['audit', 'owner', filePath];
      var result = yield this._runBuckCommandFromProjectRoot(args);
      var stdout = result.stdout;
      var targets = stdout.trim().split('\n');
      return targets;
    })
  }, {
    key: 'getBuckConfig',
    value: _asyncToGenerator(function* (section, property) {
      var buckConfig = this._buckConfig;
      if (!buckConfig) {
        buckConfig = this._buckConfig = yield this._loadBuckConfig();
      }
      if (!buckConfig.hasOwnProperty(section)) {
        return null;
      }
      var sectionConfig = buckConfig[section];
      if (!sectionConfig.hasOwnProperty(property)) {
        return null;
      }
      return sectionConfig[property];
    })

    /**
     * TODO(natthu): Also load .buckconfig.local. Consider loading .buckconfig from the home directory
     * and ~/.buckconfig.d/ directory.
     */
  }, {
    key: '_loadBuckConfig',
    value: _asyncToGenerator(function* () {
      var ini = require('ini');
      var header = 'scope = global\n';
      var buckConfigContent = yield fsPromise.readFile(path.join(this._rootPath, '.buckconfig'));
      return ini.parse(header + buckConfigContent);
    })
  }, {
    key: 'build',
    value: function build(buildTargets) {
      return this._build(buildTargets, { install: false });
    }
  }, {
    key: 'install',
    value: function install(buildTargets, simulator, runOptions) {
      return this._build(buildTargets, { install: true, simulator: simulator, runOptions: runOptions });
    }
  }, {
    key: '_build',
    value: _asyncToGenerator(function* (buildTargets, options) {
      var report = yield fsPromise.tempfile({ suffix: '.json' });
      var args = this._translateOptionsToBuckBuildArgs({
        baseOptions: _extends({}, options),
        pathToBuildReport: report,
        buildTargets: buildTargets
      });

      try {
        yield this._runBuckCommandFromProjectRoot(args);
      } catch (e) {
        // The build failed. However, because --keep-going was specified, the
        // build report should have still been written unless any of the target
        // args were invalid. We check the existence of the report file to be sure.
        var fileWasWritten = yield fsPromise.exists(report);
        if (!fileWasWritten) {
          throw e;
        }
      }

      try {
        var json = yield fsPromise.readFile(report, { encoding: 'UTF-8' });
        if (!json) {
          throw Error('Report file ' + report + ' for ' + buildTargets + ' was opened, ' + 'but nothing was written.');
        }

        try {
          return JSON.parse(json);
        } catch (e) {
          throw Error('Failed to parse:\n' + json);
        }
      } finally {
        fsPromise.unlink(report);
      }
    })
  }, {
    key: 'buildWithOutput',
    value: function buildWithOutput(buildTargets) {
      return this._buildWithOutput(buildTargets, { install: false });
    }
  }, {
    key: 'installWithOutput',
    value: function installWithOutput(buildTargets, simulator, runOptions) {
      return this._buildWithOutput(buildTargets, { install: true, simulator: simulator, runOptions: runOptions });
    }

    /**
     * Does a build/install.
     * @return An Observable that returns output from buck, as described by the
     *   docblocks for `buildWithOutput` and `installWithOutput`.
     */
  }, {
    key: '_buildWithOutput',
    value: function _buildWithOutput(buildTargets, options) {
      var args = this._translateOptionsToBuckBuildArgs({
        baseOptions: _extends({}, options),
        buildTargets: buildTargets
      });

      var _getBuckCommandAndOptions3 = this._getBuckCommandAndOptions();

      var pathToBuck = _getBuckCommandAndOptions3.pathToBuck;
      var buckCommandOptions = _getBuckCommandAndOptions3.buckCommandOptions;

      return scriptSafeSpawnAndObserveOutput(pathToBuck, args, buckCommandOptions);
    }

    /**
     * @param options An object describing the desired buck build operation.
     * @return An array of strings that can be passed as `args` to spawn a
     *   process to run the `buck` command.
     */
  }, {
    key: '_translateOptionsToBuckBuildArgs',
    value: function _translateOptionsToBuckBuildArgs(options) {
      var baseOptions = options.baseOptions;
      var pathToBuildReport = options.pathToBuildReport;
      var buildTargets = options.buildTargets;
      var install = baseOptions.install;
      var simulator = baseOptions.simulator;

      var runOptions = baseOptions.runOptions || { run: false };

      var args = install ? ['install'] : ['build'];
      args = args.concat(buildTargets);

      args.push('--keep-going');
      if (pathToBuildReport) {
        args = args.concat(['--build-report', pathToBuildReport]);
      }
      if (install) {
        if (simulator) {
          args.push('--udid');
          args.push(simulator);
        }

        if (runOptions.run) {
          args.push('--run');
          if (runOptions.debug) {
            args.push('--wait-for-debugger');
          }
          if (runOptions.appArgs) {
            args.push('--');
            // $FlowIssue runOptions.run == true => appArgs must be set.
            args = args.concat(runOptions.appArgs);
          }
        }
      }
      return args;
    }
  }, {
    key: 'listAliases',
    value: _asyncToGenerator(function* () {
      var args = ['audit', 'alias', '--list'];
      var result = yield this._runBuckCommandFromProjectRoot(args);
      var stdout = result.stdout.trim();
      return stdout ? stdout.split('\n') : [];
    })

    /**
     * Currently, if `aliasOrTarget` contains a flavor, this will fail.
     */
  }, {
    key: 'resolveAlias',
    value: _asyncToGenerator(function* (aliasOrTarget) {
      var args = ['targets', '--resolve-alias', aliasOrTarget];
      var result = yield this._runBuckCommandFromProjectRoot(args);
      return result.stdout.trim();
    })

    /**
     * Currently, if `aliasOrTarget` contains a flavor, this will fail.
     *
     * @return Promise resolves to absolute path to output file
     */
  }, {
    key: 'outputFileFor',
    value: _asyncToGenerator(function* (aliasOrTarget) {
      var args = ['targets', '--show-output', aliasOrTarget];
      var result = yield this._runBuckCommandFromProjectRoot(args);
      var stdout = result.stdout.trim();
      if (stdout.indexOf(' ') !== -1) {
        var relativePath = stdout.split(' ')[1];
        return path.resolve(this._rootPath, relativePath);
      } else {
        return null;
      }
    })

    /**
     * Currently, if `aliasOrTarget` contains a flavor, this will fail.
     */
  }, {
    key: 'buildRuleTypeFor',
    value: _asyncToGenerator(function* (aliasOrTarget) {
      var args = ['query', aliasOrTarget, '--json', '--output-attributes', 'buck.type'];
      var result = yield this._runBuckCommandFromProjectRoot(args);
      var json = JSON.parse(result.stdout);
      // If aliasOrTarget is an alias, targets[0] will be the fully qualified build target.
      var targets = Object.keys(json);
      if (!targets || targets.length !== 1) {
        throw new Error('Error determining rule type of \'' + aliasOrTarget + '\'.');
      }
      return json[targets[0]]['buck.type'];
    })
  }, {
    key: 'getServerPort',
    value: _asyncToGenerator(function* () {
      var args = ['server', 'status', '--json', '--http-port'];
      var result = yield this._runBuckCommandFromProjectRoot(args);
      var json = JSON.parse(result.stdout);
      return json['http.port'];
    })
  }, {
    key: 'query',
    value: _asyncToGenerator(function* (_query) {
      var args = ['query', '--json', _query];
      var result = yield this._runBuckCommandFromProjectRoot(args);
      var json = JSON.parse(result.stdout);
      return json;
    })
  }, {
    key: 'queryWithArgs',
    value: _asyncToGenerator(function* (query, args) {
      var completeArgs = ['query', '--json', query].concat(args);
      var result = yield this._runBuckCommandFromProjectRoot(completeArgs);
      var json = JSON.parse(result.stdout);

      // `buck query` does not include entries in the JSON for params that did not match anything. We
      // massage the output to ensure that every argument has an entry in the output.
      for (var arg of args) {
        if (!json.hasOwnProperty(arg)) {
          json[arg] = [];
        }
      }
      return json;
    })
  }]);

  return BuckProject;
})();

exports.BuckProject = BuckProject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWJ1Y2stYmFzZS9saWIvQnVja1Byb2plY3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxXQUFXLENBQUM7Ozs7Ozs7Ozs7ZUFXNEMsT0FBTyxDQUFDLGlCQUFpQixDQUFDOztJQUEzRSxZQUFZLFlBQVosWUFBWTtJQUFFLCtCQUErQixZQUEvQiwrQkFBK0I7O2dCQUNoQyxPQUFPLENBQUMsaUJBQWlCLENBQUM7O0lBQXZDLFNBQVMsYUFBVCxTQUFTOztBQUNoQixJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUN0RCxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBMEM3QixJQUFNLGtDQUFrQyxHQUFHLE1BQU0sQ0FBQzs7Ozs7OztJQU1yQyxXQUFXOzs7Ozs7O0FBVVgsV0FWQSxXQUFXLENBVVYsT0FBMkIsRUFBRTswQkFWOUIsV0FBVzs7QUFXcEIsUUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO0FBQ2xDLFFBQUksQ0FBQyxnQkFBZ0IsR0FBRyxrQ0FBa0MsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO0dBQzdFOztlQWJVLFdBQVc7O1dBZWYsbUJBQUc7O0tBRVQ7OztXQUVNLG1CQUFvQjtBQUN6QixhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ3hDOzs7Ozs7Ozs7OztXQVM2Qix3Q0FBQyxJQUFtQixFQUNpQjt1Q0FDZixJQUFJLENBQUMseUJBQXlCLEVBQUU7O1VBQTNFLFVBQVUsOEJBQVYsVUFBVTtVQUFzQixPQUFPLDhCQUEzQixrQkFBa0I7O0FBQ3JDLFlBQU0sQ0FBQyxLQUFLLENB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LEVBQUU7QUFDdEIsWUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDN0IsY0FBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztTQUNoQjtPQUNGO0FBQ0QsYUFBTyxJQUFJLENBQUM7S0FDYjs7O1NBcFNVLFdBQVciLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtYnVjay1iYXNlL2xpYi9CdWNrUHJvamVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IHthc3luY0V4ZWN1dGUsIHNjcmlwdFNhZmVTcGF3bkFuZE9ic2VydmVPdXRwdXR9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJyk7XG5jb25zdCB7ZnNQcm9taXNlfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnbnVjbGlkZS1sb2dnaW5nJykuZ2V0TG9nZ2VyKCk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG50eXBlIGRvbnRSdW5PcHRpb25zID0ge1xuICBydW46IGZhbHNlO1xufTtcblxudHlwZSBkb1J1bk9wdGlvbnMgPSB7XG4gIHJ1bjogdHJ1ZTtcbiAgZGVidWc6IGJvb2xlYW47XG4gIGFwcEFyZ3M6IEFycmF5PHN0cmluZz47XG59XG5cbnR5cGUgQnVja1J1bk9wdGlvbnMgPSBkb250UnVuT3B0aW9ucyB8IGRvUnVuT3B0aW9ucztcblxudHlwZSBCdWNrQ29uZmlnID0gT2JqZWN0O1xudHlwZSBCYXNlQnVja0J1aWxkT3B0aW9ucyA9IHtcbiAgaW5zdGFsbDogYm9vbGVhbjtcbiAgc2ltdWxhdG9yPzogP3N0cmluZztcbiAgcnVuT3B0aW9ucz86ID9CdWNrUnVuT3B0aW9ucztcbn07XG50eXBlIEZ1bGxCdWNrQnVpbGRPcHRpb25zID0ge1xuICBiYXNlT3B0aW9uczogQmFzZUJ1Y2tCdWlsZE9wdGlvbnM7XG4gIHBhdGhUb0J1aWxkUmVwb3J0Pzogc3RyaW5nO1xuICBidWlsZFRhcmdldHM6IEFycmF5PHN0cmluZz47XG59O1xudHlwZSBCdWNrQ29tbWFuZEFuZE9wdGlvbnMgPSB7XG4gIHBhdGhUb0J1Y2s6IHN0cmluZztcbiAgYnVja0NvbW1hbmRPcHRpb25zOiB7XG4gICAgY3dkOiBzdHJpbmc7XG4gICAgcXVldWVOYW1lOiBzdHJpbmc7XG4gIH07XG59O1xuaW1wb3J0IHR5cGUge09ic2VydmFibGV9IGZyb20gJ3J4JztcblxuLyoqXG4gKiBBcyBkZWZpbmVkIGluIGNvbS5mYWNlYm9vay5idWNrLmNsaS5Db21tYW5kLCBzb21lIG9mIEJ1Y2sncyBzdWJjb21tYW5kcyBhcmVcbiAqIHJlYWQtb25seS4gVGhlIHJlYWQtb25seSBjb21tYW5kcyBjYW4gYmUgZXhlY3V0ZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdFxuICogbXVzdCBiZSBleGVjdXRlZCBzZXJpYWxseS5cbiAqXG4gKiBUT0RPKG1ib2xpbik6IFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlIHVzZXIgcnVuc1xuICogYGJ1Y2sgYnVpbGRgIGZyb20gdGhlIGNvbW1hbmQgbGluZSB3aGlsZSBOdWNsaWRlIGlzIGFsc28gdHJ5aW5nIHRvIGJ1aWxkLlxuICovXG5jb25zdCBCTE9DS0lOR19CVUNLX0NPTU1BTkRfUVVFVUVfUFJFRklYID0gJ2J1Y2snO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBCdWNrIHByb2plY3Qgb24gZGlzay4gQWxsIEJ1Y2sgY29tbWFuZHMgZm9yIGEgcHJvamVjdCBzaG91bGQgYmVcbiAqIGRvbmUgdGhyb3VnaCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgQnVja1Byb2plY3Qge1xuXG4gIF9yb290UGF0aDogc3RyaW5nO1xuICBfc2VyaWFsUXVldWVOYW1lOiBzdHJpbmc7XG4gIF9idWNrQ29uZmlnOiA/QnVja0NvbmZpZztcblxuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMucm9vdFBhdGggQWJzb2x1dGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgdGhlXG4gICAqICAgICAuYnVja2NvbmZpZyBmaWxlIHRvIGNvbmZpZ3VyZSB0aGUgcHJvamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IHtyb290UGF0aDogc3RyaW5nfSkge1xuICAgIHRoaXMuX3Jvb3RQYXRoID0gb3B0aW9ucy5yb290UGF0aDtcbiAgICB0aGlzLl9zZXJpYWxRdWV1ZU5hbWUgPSBCTE9DS0lOR19CVUNLX0NPTU1BTkRfUVVFVUVfUFJFRklYICsgdGhpcy5fcm9vdFBhdGg7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIHJlcXVpcmVkIGJ5IHRoZSBzZXJ2aWNlIGZyYW1ld29yay5cbiAgfVxuXG4gIGdldFBhdGgoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Jvb3RQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHN5bnRheCBpcyBub3Qgc3VwcG9ydGVkIHlldCwgYnV0IHRoZSByZXR1cm4gdHlwZSBpczpcbiAgICogUHJvbWlzZTx7c3Rkb3V0OiBzdHJpbmc7IHN0ZGVycjogc3RyaW5nOyBleGl0Q29kZTogbnVtYmVyfT5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgRG8gbm90IGluY2x1ZGUgJ2J1Y2snIGFzIHRoZSBmaXJzdCBhcmd1bWVudDogaXQgd2lsbCBiZSBhZGRlZFxuICAgKiAgICAgYXV0b21hdGljYWxseS5cbiAgICovXG4gIF9ydW5CdWNrQ29tbWFuZEZyb21Qcm9qZWN0Um9vdChhcmdzOiBBcnJheTxzdHJpbmc+XG4gICAgICApOiBQcm9taXNlPHtzdGRvdXQ6IHN0cmluZzsgc3RkZXJyOiBzdHJpbmc7IGV4aXRDb2RlOiBudW1iZXJ9PiB7XG4gICAgY29uc3Qge3BhdGhUb0J1Y2ssIGJ1Y2tDb21tYW5kT3B0aW9uczogb3B0aW9uc30gPSB0aGlzLl9nZXRCdWNrQ29tbWFuZEFuZE9wdGlvbnMoKTtcbiAgICBsb2dnZXIuZGVidWcoJ0J1Y2sgY29tbWFuZDonLCBwYXRoVG9CdWNrLCBhcmdzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXN5bmNFeGVjdXRlKHBhdGhUb0J1Y2ssIGFyZ3MsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gVGhlIHBhdGggdG8gYnVjayBhbmQgc2V0IG9mIG9wdGlvbnMgdG8gYmUgdXNlZCB0byBydW4gYSBgYnVja2AgY29tbWFuZC5cbiAgICovXG4gIF9nZXRCdWNrQ29tbWFuZEFuZE9wdGlvbnMoKTogQnVja0NvbW1hbmRBbmRPcHRpb25zIHtcbiAgICBsZXQgcGF0aFRvQnVjaztcbiAgICBpZiAoZ2xvYmFsLmF0b20pIHtcbiAgICAgIHBhdGhUb0J1Y2sgPSBnbG9iYWwuYXRvbS5jb25maWcuZ2V0KCdudWNsaWRlLWJ1Y2stZmlsZXMucGF0aFRvQnVjaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoVG9CdWNrID0gJ2J1Y2snO1xuICAgIH1cbiAgICBjb25zdCBidWNrQ29tbWFuZE9wdGlvbnMgPSB7XG4gICAgICBjd2Q6IHRoaXMuX3Jvb3RQYXRoLFxuICAgICAgcXVldWVOYW1lOiB0aGlzLl9zZXJpYWxRdWV1ZU5hbWUsXG4gICAgfTtcbiAgICByZXR1cm4ge3BhdGhUb0J1Y2ssIGJ1Y2tDb21tYW5kT3B0aW9uc307XG4gIH1cblxuICBhc3luYyBnZXRPd25lcihmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxzdHJpbmc+PiB7XG4gICAgY29uc3QgYXJncyA9IFsnYXVkaXQnLCAnb3duZXInLCBmaWxlUGF0aF07XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcnVuQnVja0NvbW1hbmRGcm9tUHJvamVjdFJvb3QoYXJncyk7XG4gICAgY29uc3Qgc3Rkb3V0ID0gcmVzdWx0LnN0ZG91dDtcbiAgICBjb25zdCB0YXJnZXRzID0gc3Rkb3V0LnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gICAgcmV0dXJuIHRhcmdldHM7XG4gIH1cblxuICBhc3luYyBnZXRCdWNrQ29uZmlnKHNlY3Rpb246IHN0cmluZywgcHJvcGVydHk6IHN0cmluZyk6IFByb21pc2U8P3N0cmluZz4ge1xuICAgIGxldCBidWNrQ29uZmlnID0gdGhpcy5fYnVja0NvbmZpZztcbiAgICBpZiAoIWJ1Y2tDb25maWcpIHtcbiAgICAgIGJ1Y2tDb25maWcgPSB0aGlzLl9idWNrQ29uZmlnID0gYXdhaXQgdGhpcy5fbG9hZEJ1Y2tDb25maWcoKTtcbiAgICB9XG4gICAgaWYgKCFidWNrQ29uZmlnLmhhc093blByb3BlcnR5KHNlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VjdGlvbkNvbmZpZyA9IGJ1Y2tDb25maWdbc2VjdGlvbl07XG4gICAgaWYgKCFzZWN0aW9uQ29uZmlnLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnW3Byb3BlcnR5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPKG5hdHRodSk6IEFsc28gbG9hZCAuYnVja2NvbmZpZy5sb2NhbC4gQ29uc2lkZXIgbG9hZGluZyAuYnVja2NvbmZpZyBmcm9tIHRoZSBob21lIGRpcmVjdG9yeVxuICAgKiBhbmQgfi8uYnVja2NvbmZpZy5kLyBkaXJlY3RvcnkuXG4gICAqL1xuICBhc3luYyBfbG9hZEJ1Y2tDb25maWcoKTogUHJvbWlzZTxCdWNrQ29uZmlnPiB7XG4gICAgY29uc3QgaW5pID0gcmVxdWlyZSgnaW5pJyk7XG4gICAgY29uc3QgaGVhZGVyID0gJ3Njb3BlID0gZ2xvYmFsXFxuJztcbiAgICBjb25zdCBidWNrQ29uZmlnQ29udGVudCA9IGF3YWl0IGZzUHJvbWlzZS5yZWFkRmlsZShwYXRoLmpvaW4odGhpcy5fcm9vdFBhdGgsICcuYnVja2NvbmZpZycpKTtcbiAgICByZXR1cm4gaW5pLnBhcnNlKGhlYWRlciArIGJ1Y2tDb25maWdDb250ZW50KTtcbiAgfVxuXG4gIGJ1aWxkKGJ1aWxkVGFyZ2V0czogQXJyYXk8c3RyaW5nPik6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkKGJ1aWxkVGFyZ2V0cywge2luc3RhbGw6IGZhbHNlfSk7XG4gIH1cblxuICBpbnN0YWxsKFxuICAgIGJ1aWxkVGFyZ2V0czogQXJyYXk8c3RyaW5nPixcbiAgICBzaW11bGF0b3I6ID9zdHJpbmcsXG4gICAgcnVuT3B0aW9uczogP0J1Y2tSdW5PcHRpb25zLFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9idWlsZChidWlsZFRhcmdldHMsIHtpbnN0YWxsOiB0cnVlLCBzaW11bGF0b3IsIHJ1bk9wdGlvbnN9KTtcbiAgfVxuXG4gIGFzeW5jIF9idWlsZChidWlsZFRhcmdldHM6IEFycmF5PHN0cmluZz4sIG9wdGlvbnM6IEJhc2VCdWNrQnVpbGRPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBmc1Byb21pc2UudGVtcGZpbGUoe3N1ZmZpeDogJy5qc29uJ30pO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl90cmFuc2xhdGVPcHRpb25zVG9CdWNrQnVpbGRBcmdzKHtcbiAgICAgIGJhc2VPcHRpb25zOiB7Li4ub3B0aW9uc30sXG4gICAgICBwYXRoVG9CdWlsZFJlcG9ydDogcmVwb3J0LFxuICAgICAgYnVpbGRUYXJnZXRzLFxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3J1bkJ1Y2tDb21tYW5kRnJvbVByb2plY3RSb290KGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRoZSBidWlsZCBmYWlsZWQuIEhvd2V2ZXIsIGJlY2F1c2UgLS1rZWVwLWdvaW5nIHdhcyBzcGVjaWZpZWQsIHRoZVxuICAgICAgLy8gYnVpbGQgcmVwb3J0IHNob3VsZCBoYXZlIHN0aWxsIGJlZW4gd3JpdHRlbiB1bmxlc3MgYW55IG9mIHRoZSB0YXJnZXRcbiAgICAgIC8vIGFyZ3Mgd2VyZSBpbnZhbGlkLiBXZSBjaGVjayB0aGUgZXhpc3RlbmNlIG9mIHRoZSByZXBvcnQgZmlsZSB0byBiZSBzdXJlLlxuICAgICAgY29uc3QgZmlsZVdhc1dyaXR0ZW4gPSBhd2FpdCBmc1Byb21pc2UuZXhpc3RzKHJlcG9ydCk7XG4gICAgICBpZiAoIWZpbGVXYXNXcml0dGVuKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpzb246IHN0cmluZyA9IGF3YWl0IGZzUHJvbWlzZS5yZWFkRmlsZShyZXBvcnQsIHtlbmNvZGluZzogJ1VURi04J30pO1xuICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBSZXBvcnQgZmlsZSAke3JlcG9ydH0gZm9yICR7YnVpbGRUYXJnZXRzfSB3YXMgb3BlbmVkLCBgICtcbiAgICAgICAgICAgIGBidXQgbm90aGluZyB3YXMgd3JpdHRlbi5gKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gcGFyc2U6XFxuJHtqc29ufWApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBmc1Byb21pc2UudW5saW5rKHJlcG9ydCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRXaXRoT3V0cHV0KFxuICAgIGJ1aWxkVGFyZ2V0czogQXJyYXk8c3RyaW5nPlxuICApOiBPYnNlcnZhYmxlPHtzdGRlcnI/OiBzdHJpbmc7IHN0ZG91dD86IHN0cmluZzt9PiB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkV2l0aE91dHB1dChidWlsZFRhcmdldHMsIHtpbnN0YWxsOiBmYWxzZX0pO1xuICB9XG5cbiAgaW5zdGFsbFdpdGhPdXRwdXQoXG4gICAgYnVpbGRUYXJnZXRzOiBBcnJheTxzdHJpbmc+LFxuICAgIHNpbXVsYXRvcjogP3N0cmluZyxcbiAgICBydW5PcHRpb25zOiA/QnVja1J1bk9wdGlvbnMsXG4gICk6IE9ic2VydmFibGU8e3N0ZGVycj86IHN0cmluZzsgc3Rkb3V0Pzogc3RyaW5nO30+IHtcbiAgICByZXR1cm4gdGhpcy5fYnVpbGRXaXRoT3V0cHV0KGJ1aWxkVGFyZ2V0cywge2luc3RhbGw6IHRydWUsIHNpbXVsYXRvciwgcnVuT3B0aW9uc30pO1xuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgYSBidWlsZC9pbnN0YWxsLlxuICAgKiBAcmV0dXJuIEFuIE9ic2VydmFibGUgdGhhdCByZXR1cm5zIG91dHB1dCBmcm9tIGJ1Y2ssIGFzIGRlc2NyaWJlZCBieSB0aGVcbiAgICogICBkb2NibG9ja3MgZm9yIGBidWlsZFdpdGhPdXRwdXRgIGFuZCBgaW5zdGFsbFdpdGhPdXRwdXRgLlxuICAgKi9cbiAgX2J1aWxkV2l0aE91dHB1dChcbiAgICBidWlsZFRhcmdldHM6IEFycmF5PHN0cmluZz4sXG4gICAgb3B0aW9uczogQmFzZUJ1Y2tCdWlsZE9wdGlvbnMsXG4gICk6IE9ic2VydmFibGU8e3N0ZGVycj86IHN0cmluZzsgc3Rkb3V0Pzogc3RyaW5nO30+IHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fdHJhbnNsYXRlT3B0aW9uc1RvQnVja0J1aWxkQXJncyh7XG4gICAgICBiYXNlT3B0aW9uczogey4uLm9wdGlvbnN9LFxuICAgICAgYnVpbGRUYXJnZXRzLFxuICAgIH0pO1xuICAgIGNvbnN0IHtwYXRoVG9CdWNrLCBidWNrQ29tbWFuZE9wdGlvbnN9ID0gdGhpcy5fZ2V0QnVja0NvbW1hbmRBbmRPcHRpb25zKCk7XG5cbiAgICByZXR1cm4gc2NyaXB0U2FmZVNwYXduQW5kT2JzZXJ2ZU91dHB1dChwYXRoVG9CdWNrLCBhcmdzLCBidWNrQ29tbWFuZE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIGJ1Y2sgYnVpbGQgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJuIEFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBjYW4gYmUgcGFzc2VkIGFzIGBhcmdzYCB0byBzcGF3biBhXG4gICAqICAgcHJvY2VzcyB0byBydW4gdGhlIGBidWNrYCBjb21tYW5kLlxuICAgKi9cbiAgX3RyYW5zbGF0ZU9wdGlvbnNUb0J1Y2tCdWlsZEFyZ3Mob3B0aW9uczogRnVsbEJ1Y2tCdWlsZE9wdGlvbnMpOiBBcnJheTxzdHJpbmc+IHtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlT3B0aW9ucyxcbiAgICAgIHBhdGhUb0J1aWxkUmVwb3J0LFxuICAgICAgYnVpbGRUYXJnZXRzLFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIGluc3RhbGwsXG4gICAgICBzaW11bGF0b3IsXG4gICAgfSA9IGJhc2VPcHRpb25zO1xuICAgIGNvbnN0IHJ1bk9wdGlvbnMgPSBiYXNlT3B0aW9ucy5ydW5PcHRpb25zIHx8IHtydW46IGZhbHNlfTtcblxuICAgIGxldCBhcmdzID0gaW5zdGFsbCA/IFsnaW5zdGFsbCddIDogWydidWlsZCddO1xuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChidWlsZFRhcmdldHMpO1xuXG4gICAgYXJncy5wdXNoKCctLWtlZXAtZ29pbmcnKTtcbiAgICBpZiAocGF0aFRvQnVpbGRSZXBvcnQpIHtcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbJy0tYnVpbGQtcmVwb3J0JywgcGF0aFRvQnVpbGRSZXBvcnRdKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbGwpIHtcbiAgICAgIGlmIChzaW11bGF0b3IpIHtcbiAgICAgICAgYXJncy5wdXNoKCctLXVkaWQnKTtcbiAgICAgICAgYXJncy5wdXNoKHNpbXVsYXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5PcHRpb25zLnJ1bikge1xuICAgICAgICBhcmdzLnB1c2goJy0tcnVuJyk7XG4gICAgICAgIGlmIChydW5PcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgYXJncy5wdXNoKCctLXdhaXQtZm9yLWRlYnVnZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bk9wdGlvbnMuYXBwQXJncykge1xuICAgICAgICAgIGFyZ3MucHVzaCgnLS0nKTtcbiAgICAgICAgICAvLyAkRmxvd0lzc3VlIHJ1bk9wdGlvbnMucnVuID09IHRydWUgPT4gYXBwQXJncyBtdXN0IGJlIHNldC5cbiAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQocnVuT3B0aW9ucy5hcHBBcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIGFzeW5jIGxpc3RBbGlhc2VzKCk6IFByb21pc2U8QXJyYXk8c3RyaW5nPj4ge1xuICAgIGNvbnN0IGFyZ3MgPSBbJ2F1ZGl0JywgJ2FsaWFzJywgJy0tbGlzdCddO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3J1bkJ1Y2tDb21tYW5kRnJvbVByb2plY3RSb290KGFyZ3MpO1xuICAgIGNvbnN0IHN0ZG91dCA9IHJlc3VsdC5zdGRvdXQudHJpbSgpO1xuICAgIHJldHVybiBzdGRvdXQgPyBzdGRvdXQuc3BsaXQoJ1xcbicpIDogW107XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudGx5LCBpZiBgYWxpYXNPclRhcmdldGAgY29udGFpbnMgYSBmbGF2b3IsIHRoaXMgd2lsbCBmYWlsLlxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZUFsaWFzKGFsaWFzT3JUYXJnZXQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgYXJncyA9IFsndGFyZ2V0cycsICctLXJlc29sdmUtYWxpYXMnLCBhbGlhc09yVGFyZ2V0XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9ydW5CdWNrQ29tbWFuZEZyb21Qcm9qZWN0Um9vdChhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0LnN0ZG91dC50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudGx5LCBpZiBgYWxpYXNPclRhcmdldGAgY29udGFpbnMgYSBmbGF2b3IsIHRoaXMgd2lsbCBmYWlsLlxuICAgKlxuICAgKiBAcmV0dXJuIFByb21pc2UgcmVzb2x2ZXMgdG8gYWJzb2x1dGUgcGF0aCB0byBvdXRwdXQgZmlsZVxuICAgKi9cbiAgYXN5bmMgb3V0cHV0RmlsZUZvcihhbGlhc09yVGFyZ2V0OiBzdHJpbmcpOiBQcm9taXNlPD9zdHJpbmc+IHtcbiAgICBjb25zdCBhcmdzID0gWyd0YXJnZXRzJywgJy0tc2hvdy1vdXRwdXQnLCBhbGlhc09yVGFyZ2V0XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9ydW5CdWNrQ29tbWFuZEZyb21Qcm9qZWN0Um9vdChhcmdzKTtcbiAgICBjb25zdCBzdGRvdXQgPSByZXN1bHQuc3Rkb3V0LnRyaW0oKTtcbiAgICBpZiAoc3Rkb3V0LmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHN0ZG91dC5zcGxpdCgnICcpWzFdO1xuICAgICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh0aGlzLl9yb290UGF0aCwgcmVsYXRpdmVQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSwgaWYgYGFsaWFzT3JUYXJnZXRgIGNvbnRhaW5zIGEgZmxhdm9yLCB0aGlzIHdpbGwgZmFpbC5cbiAgICovXG4gIGFzeW5jIGJ1aWxkUnVsZVR5cGVGb3IoYWxpYXNPclRhcmdldDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBhcmdzID0gWydxdWVyeScsIGFsaWFzT3JUYXJnZXQsICctLWpzb24nLCAnLS1vdXRwdXQtYXR0cmlidXRlcycsICdidWNrLnR5cGUnXTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9ydW5CdWNrQ29tbWFuZEZyb21Qcm9qZWN0Um9vdChhcmdzKTtcbiAgICBjb25zdCBqc29uOiB7W3RhcmdldDogc3RyaW5nXTogT2JqZWN0fSA9IEpTT04ucGFyc2UocmVzdWx0LnN0ZG91dCk7XG4gICAgLy8gSWYgYWxpYXNPclRhcmdldCBpcyBhbiBhbGlhcywgdGFyZ2V0c1swXSB3aWxsIGJlIHRoZSBmdWxseSBxdWFsaWZpZWQgYnVpbGQgdGFyZ2V0LlxuICAgIGNvbnN0IHRhcmdldHMgPSBPYmplY3Qua2V5cyhqc29uKTtcbiAgICBpZiAoIXRhcmdldHMgfHwgdGFyZ2V0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGV0ZXJtaW5pbmcgcnVsZSB0eXBlIG9mICcke2FsaWFzT3JUYXJnZXR9Jy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25bdGFyZ2V0c1swXV1bJ2J1Y2sudHlwZSddO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2VydmVyUG9ydCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IGFyZ3MgPSBbJ3NlcnZlcicsICdzdGF0dXMnLCAnLS1qc29uJywgJy0taHR0cC1wb3J0J107XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcnVuQnVja0NvbW1hbmRGcm9tUHJvamVjdFJvb3QoYXJncyk7XG4gICAgY29uc3QganNvbjogT2JqZWN0ID0gSlNPTi5wYXJzZShyZXN1bHQuc3Rkb3V0KTtcbiAgICByZXR1cm4ganNvblsnaHR0cC5wb3J0J107XG4gIH1cblxuICBhc3luYyBxdWVyeShxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxzdHJpbmc+PiB7XG4gICAgY29uc3QgYXJncyA9IFsncXVlcnknLCAnLS1qc29uJywgcXVlcnldO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3J1bkJ1Y2tDb21tYW5kRnJvbVByb2plY3RSb290KGFyZ3MpO1xuICAgIGNvbnN0IGpzb246IEFycmF5PHN0cmluZz4gPSBKU09OLnBhcnNlKHJlc3VsdC5zdGRvdXQpO1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgYXN5bmMgcXVlcnlXaXRoQXJncyhcbiAgICBxdWVyeTogc3RyaW5nLFxuICAgIGFyZ3M6IEFycmF5PHN0cmluZz4sXG4gICk6IFByb21pc2U8e1thbGlhc09yVGFyZ2V0OiBzdHJpbmddOiBBcnJheTxzdHJpbmc+fT4ge1xuICAgIGNvbnN0IGNvbXBsZXRlQXJncyA9IFsncXVlcnknLCAnLS1qc29uJywgcXVlcnldLmNvbmNhdChhcmdzKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9ydW5CdWNrQ29tbWFuZEZyb21Qcm9qZWN0Um9vdChjb21wbGV0ZUFyZ3MpO1xuICAgIGNvbnN0IGpzb246IHtbYWxpYXNPclRhcmdldDogc3RyaW5nXTogQXJyYXk8c3RyaW5nPn0gPSBKU09OLnBhcnNlKHJlc3VsdC5zdGRvdXQpO1xuXG4gICAgLy8gYGJ1Y2sgcXVlcnlgIGRvZXMgbm90IGluY2x1ZGUgZW50cmllcyBpbiB0aGUgSlNPTiBmb3IgcGFyYW1zIHRoYXQgZGlkIG5vdCBtYXRjaCBhbnl0aGluZy4gV2VcbiAgICAvLyBtYXNzYWdlIHRoZSBvdXRwdXQgdG8gZW5zdXJlIHRoYXQgZXZlcnkgYXJndW1lbnQgaGFzIGFuIGVudHJ5IGluIHRoZSBvdXRwdXQuXG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgaWYgKCFqc29uLmhhc093blByb3BlcnR5KGFyZykpIHtcbiAgICAgICAganNvblthcmddID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG59XG4iXX0=
