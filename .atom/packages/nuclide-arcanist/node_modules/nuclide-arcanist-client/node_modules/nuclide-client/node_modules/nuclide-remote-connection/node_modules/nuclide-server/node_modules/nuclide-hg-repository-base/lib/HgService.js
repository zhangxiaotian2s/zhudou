
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require('nuclide-commons');

var debounce = _require.debounce;
var denodeify = _require.denodeify;

var DelayedEventManager = require('./DelayedEventManager');
var watchman = require('fb-watchman');
var HgServiceBase = require('./HgServiceBase');
var logger = require('nuclide-logging').getLogger();

var _require2 = require('nuclide-watchman-helpers');

var getWatchmanBinaryPath = _require2.getWatchmanBinaryPath;

var path = require('path');

var WATCHMAN_SUBSCRIPTION_NAME_PRIMARY = 'hg-repository-watchman-subscription-primary';
var WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE = 'hg-repository-watchman-subscription-hgignore';
var WATCHMAN_SUBSCRIPTION_NAME_HGLOCK = 'hg-repository-watchman-subscription-hglock';
var WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE = 'hg-repository-watchman-subscription-hgdirstate';
var WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK = 'hg-repository-watchman-subscription-hgbookmark';
var WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK = 'arc-build-lock';
var EVENT_DELAY_IN_MS = 1000;

function getArcBuildLockFile() {
  var lockFile = undefined;
  try {
    lockFile = require('./fb/config').arcBuildLockFile;
  } catch (e) {
    // purposely blank
  }
  return lockFile;
}

/**
 * @return Array of additional watch expressions to apply to the primary
 *   watchman subscription.
 */
function getPrimaryWatchmanSubscriptionRefinements() {
  var refinements = [];
  try {
    refinements = require('./fb/config').primaryWatchSubscriptionRefinements;
  } catch (e) {
    // purposely blank
  }
  return refinements;
}

// To make HgServiceBase more easily testable, the watchman dependency is
// broken out. We add the watchman dependency here.

var HgService = (function (_HgServiceBase) {
  _inherits(HgService, _HgServiceBase);

  function HgService(workingDirectory) {
    _classCallCheck(this, HgService);

    _get(Object.getPrototypeOf(HgService.prototype), 'constructor', this).call(this, workingDirectory);
    this._delayedEventManager = new DelayedEventManager(setTimeout, clearTimeout);
    this._lockFileHeld = false;
    this._shouldUseDirstate = true;
    this._subscribeToWatchman();
  }

  _createClass(HgService, [{
    key: 'dispose',
    value: _asyncToGenerator(function* () {
      yield this._cleanUpWatchman();
      this._delayedEventManager.dispose();
      if (this._dirstateDelayedEventManager) {
        this._dirstateDelayedEventManager.dispose();
      }
      return _get(Object.getPrototypeOf(HgService.prototype), 'dispose', this).call(this);
    })
  }, {
    key: '_asyncExecuteWatchmanCommand',
    value: function _asyncExecuteWatchmanCommand(args) {
      var watchmanClient = this._watchmanClient;
      if (watchmanClient == null) {
        throw Error('Watchman Client is not intialized.');
      }
      return denodeify(watchmanClient.command.bind(watchmanClient))(args);
    }
  }, {
    key: '_subscribeToWatchman',
    value: _asyncToGenerator(function* () {
      var _this = this;

      // Using a local variable here to allow better type refinement.
      var watchmanClient = new watchman.Client({
        watchmanBinaryPath: yield getWatchmanBinaryPath()
      });
      this._watchmanClient = watchmanClient;
      var workingDirectory = this.getWorkingDirectory();
      watchmanClient.command(['watch', workingDirectory], function (watchError, watchResp) {
        if (watchError) {
          logger.error('Error initiating watchman watch: ' + watchError);
          return;
        }
        // By default, watchman will deliver a list of all current files when you
        // first subscribe. We don't want this behavior, so we issue a `clock`
        // command to give a logical time constraint on the subscription.
        // This is recommended by https://www.npmjs.com/package/fb-watchman.
        watchmanClient.command(['clock', workingDirectory], function (clockError, clockResp) {
          if (clockError) {
            logger.error('Failed to query watchman clock: ', clockError);
            return;
          }

          var primarySubscriptionExpression = ['allof', ['not', ['dirname', '.hg']], ['not', ['name', '.hgignore', 'wholename']],
          // Hg appears to modify temporary files that begin with these
          // prefixes, every time a file is saved.
          // TODO (t7832809) Remove this when it is unnecessary.
          ['not', ['match', 'hg-checkexec-*', 'wholename']], ['not', ['match', 'hg-checklink-*', 'wholename']],
          // This watchman subscription is used to determine when and which
          // files to fetch new statuses for. There is no reason to include
          // directories in these updates, and in fact they may make us overfetch
          // statuses. (See diff summary of D2021498.)
          // This line restricts this subscription to only return files.
          ['type', 'f']];
          primarySubscriptionExpression = primarySubscriptionExpression.concat(getPrimaryWatchmanSubscriptionRefinements());

          // Subscribe to changes to files unrelated to source control.
          watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_PRIMARY, {
            fields: ['name', 'exists', 'new'],
            expression: primarySubscriptionExpression,
            since: clockResp.clock
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_PRIMARY + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_PRIMARY + ' established.');
          });

          // Subscribe to changes to .hgignore files.
          watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE, {
            fields: ['name'],
            expression: ['name', '.hgignore', 'wholename'],
            since: clockResp.clock
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE + ' established.');
          });

          // Subscribe to changes to the source control lock file.
          watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGLOCK, {
            fields: ['name', 'exists'],
            expression: ['name', '.hg/wlock', 'wholename'],
            since: clockResp.clock,
            defer_vcs: false
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGLOCK + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGLOCK + ' established.');
          });

          // Subscribe to changes to the source control directory state file.
          watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE, {
            fields: ['name', 'exists'],
            expression: ['name', '.hg/dirstate', 'wholename'],
            since: clockResp.clock,
            defer_vcs: false
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE + ' established.');
          });

          // Subscribe to changes in the current Hg bookmark.
          watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK, {
            fields: ['name', 'exists'],
            expression: ['name', '.hg/bookmarks.current', 'wholename'],
            since: clockResp.clock,
            defer_vcs: false
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK + ' established.');
          });

          // Subscribe to changes to a file that appears to be the 'arc build' lock file.
          var arcBuildLockFile = getArcBuildLockFile();
          if (arcBuildLockFile) {
            watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK, {
              fields: ['name', 'exists'],
              expression: ['name', arcBuildLockFile, 'wholename'],
              since: clockResp.clock
            }], function (subscribeError, subscribeResp) {
              if (subscribeError) {
                logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK + ' ' + 'with clock limit: ', subscribeError);
                return;
              }
              logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK + ' established.');
            });
          }
        });

        // Mercurial creates the .hg/wlock file before it modifies the working directory,
        // and deletes it when it's done. We want to ignore the watchman updates
        // caused by these modifications, so we do two things:
        // 1. The first level of defense is to watch for the creation and deletion of
        // the wlock and ignore events accordingly.
        // However, the watchman update for the files that have changed
        // due to the Mercurial action may arrive before the update for the wlock
        // file.
        // To work around this, we introduce an artificial delay for the watchman
        // updates for our files of interest, which allows time for a wlock watchman
        // update (if any) to arrive and cancel them.
        // This may occasionally result in a false positive: cancelling events that
        // were generated by a user action (not Mercurial) that occur shortly before
        // Mercurial modifies the working directory. But this should be fine,
        // because the client of LocalHgService should be reacting to the
        // 'onHgRepoStateDidChange' event that follows the Mercurial event.
        // 2. The wlock is surest way to detect the beginning and end of events. But
        // because it is a transient file, watchman may not pick up on it, especially
        // if the Mercurial action is quick (e.g. a commit, as opposed to a rebase).
        // In this case we fall back on watching the dirstate, which is a persistent
        // file that is written to whenever Mercurial updates the state of the working
        // directory (except reverts -- but this will also modify the state of the
        // relevant files). The dirstate gets modified in the middle of an update
        // and at the end, but not the beginning. Therefore it's a bit noisier of
        // a signal, and is prone to both false positives and negatives.
        watchmanClient.on('subscription', function (update) {
          if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_PRIMARY) {
            _this._delayedEventManager.addEvent(_this._filesDidChange.bind(_this, update), EVENT_DELAY_IN_MS);
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE) {
            // There are three events that may outdate the status of ignored files.
            // 1. The .hgignore file changes. In this case, we want to run a fresh 'hg status -i'.
            // 2. A file is added that meets the criteria under .hgignore. In this case, we can
            //    scope the 'hg status -i' call to just the added file.
            // 3. A file that was previously ignored, has been deleted. (A bit debatable in this
            //    case what ::isPathIgnored should return if the file doesn't exist. But let's
            //    at least keep the local cache updated.) In this case, we just want to remove
            //    the deleted file if it is in the cache.
            // Case 1 is covered by the response to WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE firing.
            // Cases 2 and 3 are covered by the response to WATCHMAN_SUBSCRIPTION_NAME_PRIMARY firing.
            _this._delayedEventManager.addEvent(_this._hgIgnoreFileDidChange.bind(_this), EVENT_DELAY_IN_MS);
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGLOCK || update.subscription === WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK) {
            var lockfile = update.files[0];
            if (lockfile.exists) {
              // TODO: Implement a timer to unset this, in case watchman update
              // fails to notify of the removal of the lock. I haven't seen this
              // in practice but it's better to be safe.
              _this._lockFileHeld = true;
              // The lock being created is a definitive start to a Mercurial action/arc build.
              // Block the effects from any dirstate change, which is a fuzzier signal.
              _this._shouldUseDirstate = false;
              _this._delayedEventManager.setCanAcceptEvents(false);
              _this._delayedEventManager.cancelAllEvents();
            } else {
              _this._lockFileHeld = false;
              _this._delayedEventManager.setCanAcceptEvents(true);
              // The lock being deleted is a definitive end to a Mercurial action/arc build.
              // Block the effects from any dirstate change, which is a fuzzier signal.
              _this._shouldUseDirstate = false;
            }
            _this._hgLockDidChange(lockfile.exists);
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE) {
            // We don't know whether the change to the dirstate is at the middle or end
            // of a Mercurial action. But we would rather have false positives (ignore
            // some user-generated events that occur near a Mercurial event) than false
            // negatives (register irrelevant Mercurial events).
            // Each time this watchman update fires, we will make the LocalHgService
            // ignore events for a certain grace period.

            // A lock file is a more reliable signal, so defer to it.
            if (_this._lockFileHeld) {
              return;
            }

            _this._shouldUseDirstate = true;
            _this._delayedEventManager.setCanAcceptEvents(false);
            _this._delayedEventManager.cancelAllEvents();

            // Using a local variable here to allow better type refinement.
            var allowEventsAgain = _this._allowEventsAgain;
            if (!allowEventsAgain) {
              allowEventsAgain = debounce(function () {
                if (_this._shouldUseDirstate) {
                  _this._delayedEventManager.setCanAcceptEvents(true);
                  _this._hgDirstateDidChange();
                }
              }, EVENT_DELAY_IN_MS,
              /* immediate */false);
              _this._allowEventsAgain = allowEventsAgain;
            }
            allowEventsAgain();
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK) {
            _this._hgBookmarkDidChange();
          }
        });
      });
    })
  }, {
    key: '_cleanUpWatchman',
    value: _asyncToGenerator(function* () {
      var watchmanClient = this._watchmanClient;
      if (watchmanClient) {
        yield Promise.all([this._asyncExecuteWatchmanCommand(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_PRIMARY]), this._asyncExecuteWatchmanCommand(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE]), this._asyncExecuteWatchmanCommand(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGLOCK]), this._asyncExecuteWatchmanCommand(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE]), yield this._asyncExecuteWatchmanCommand(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK])]);
        watchmanClient.end();
      }
    })

    /**
     * @param update The latest watchman update.
     */
  }, {
    key: '_filesDidChange',
    value: function _filesDidChange(update) {
      var workingDirectory = this.getWorkingDirectory();
      var changedFiles = update.files.map(function (file) {
        return path.join(workingDirectory, file.name);
      });
      this._filesDidChangeObserver.onNext(changedFiles);
    }
  }, {
    key: '_hgIgnoreFileDidChange',
    value: function _hgIgnoreFileDidChange() {
      this._hgIgnoreFileDidChangeObserver.onNext();
    }
  }, {
    key: '_hgLockDidChange',
    value: function _hgLockDidChange(lockExists) {
      if (!lockExists) {
        this._emitHgRepoStateChanged();
      }
    }
  }, {
    key: '_hgDirstateDidChange',
    value: function _hgDirstateDidChange() {
      this._emitHgRepoStateChanged();
    }
  }, {
    key: '_emitHgRepoStateChanged',
    value: function _emitHgRepoStateChanged() {
      this._hgRepoStateDidChangeObserver.onNext();
    }
  }, {
    key: '_hgBookmarkDidChange',
    value: function _hgBookmarkDidChange() {
      this._hgBookmarkDidChangeObserver.onNext();
    }
  }]);

  return HgService;
})(HgServiceBase);

exports.HgService = HgService;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvSGdTZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBV2tCLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQzs7SUFBakQsUUFBUSxZQUFSLFFBQVE7SUFBRSxTQUFTLFlBQVQsU0FBUzs7QUFDMUIsSUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUM3RCxJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDeEMsSUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDakQsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7O2dCQUN0QixPQUFPLENBQUMsMEJBQTBCLENBQUM7O0lBQTVELHFCQUFxQixhQUFyQixxQkFBcUI7O0FBQzVCLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFN0IsSUFBTSxrQ0FBa0MsR0FBRyw2Q0FBNkMsQ0FBQztBQUN6RixJQUFNLG1DQUFtQyxHQUFHLDhDQUE4QyxDQUFDO0FBQzNGLElBQU0saUNBQWlDLEdBQUcsNENBQTRDLENBQUM7QUFDdkYsSUFBTSxxQ0FBcUMsR0FBRyxnREFBZ0QsQ0FBQztBQUMvRixJQUFNLHFDQUFxQyxHQUFHLGdEQUFnRCxDQUFDO0FBQy9GLElBQU0seUNBQXlDLEdBQUcsZ0JBQWdCLENBQUM7QUFDbkUsSUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUM7O0FBRS9CLFNBQVMsbUJBQW1CLEdBQVk7QUFDdEMsTUFBSSxRQUFRLFlBQUEsQ0FBQztBQUNiLE1BQUk7QUFD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RSxDQUFDO0tBQzVDOzs7U0FuWFUsU0FBUztHQUFTLGFBQWEiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtaGctcmVwb3NpdG9yeS1iYXNlL2xpYi9IZ1NlcnZpY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5jb25zdCB7ZGVib3VuY2UsIGRlbm9kZWlmeX0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKTtcbmNvbnN0IERlbGF5ZWRFdmVudE1hbmFnZXIgPSByZXF1aXJlKCcuL0RlbGF5ZWRFdmVudE1hbmFnZXInKTtcbmNvbnN0IHdhdGNobWFuID0gcmVxdWlyZSgnZmItd2F0Y2htYW4nKTtcbmNvbnN0IEhnU2VydmljZUJhc2UgPSByZXF1aXJlKCcuL0hnU2VydmljZUJhc2UnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xuY29uc3Qge2dldFdhdGNobWFuQmluYXJ5UGF0aH0gPSByZXF1aXJlKCdudWNsaWRlLXdhdGNobWFuLWhlbHBlcnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX1BSSU1BUlkgPSAnaGctcmVwb3NpdG9yeS13YXRjaG1hbi1zdWJzY3JpcHRpb24tcHJpbWFyeSc7XG5jb25zdCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0lHTk9SRSA9ICdoZy1yZXBvc2l0b3J5LXdhdGNobWFuLXN1YnNjcmlwdGlvbi1oZ2lnbm9yZSc7XG5jb25zdCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0xPQ0sgPSAnaGctcmVwb3NpdG9yeS13YXRjaG1hbi1zdWJzY3JpcHRpb24taGdsb2NrJztcbmNvbnN0IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHRElSU1RBVEUgPSAnaGctcmVwb3NpdG9yeS13YXRjaG1hbi1zdWJzY3JpcHRpb24taGdkaXJzdGF0ZSc7XG5jb25zdCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0JPT0tNQVJLID0gJ2hnLXJlcG9zaXRvcnktd2F0Y2htYW4tc3Vic2NyaXB0aW9uLWhnYm9va21hcmsnO1xuY29uc3QgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfQVJDX0JVSUxEX0xPQ0sgPSAnYXJjLWJ1aWxkLWxvY2snO1xuY29uc3QgRVZFTlRfREVMQVlfSU5fTVMgPSAxMDAwO1xuXG5mdW5jdGlvbiBnZXRBcmNCdWlsZExvY2tGaWxlKCk6ID9zdHJpbmcge1xuICBsZXQgbG9ja0ZpbGU7XG4gIHRyeSB7XG4gICAgbG9ja0ZpbGUgPSByZXF1aXJlKCcuL2ZiL2NvbmZpZycpLmFyY0J1aWxkTG9ja0ZpbGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBwdXJwb3NlbHkgYmxhbmtcbiAgfVxuICByZXR1cm4gbG9ja0ZpbGU7XG59XG5cbi8qKlxuICogQHJldHVybiBBcnJheSBvZiBhZGRpdGlvbmFsIHdhdGNoIGV4cHJlc3Npb25zIHRvIGFwcGx5IHRvIHRoZSBwcmltYXJ5XG4gKiAgIHdhdGNobWFuIHN1YnNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJpbWFyeVdhdGNobWFuU3Vic2NyaXB0aW9uUmVmaW5lbWVudHMoKTogQXJyYXk8bWl4ZWQ+IHtcbiAgbGV0IHJlZmluZW1lbnRzID0gW107XG4gIHRyeSB7XG4gICAgcmVmaW5lbWVudHMgPSByZXF1aXJlKCcuL2ZiL2NvbmZpZycpLnByaW1hcnlXYXRjaFN1YnNjcmlwdGlvblJlZmluZW1lbnRzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcHVycG9zZWx5IGJsYW5rXG4gIH1cbiAgcmV0dXJuIHJlZmluZW1lbnRzO1xufVxuXG4vLyBUbyBtYWtlIEhnU2VydmljZUJhc2UgbW9yZSBlYXNpbHkgdGVzdGFibGUsIHRoZSB3YXRjaG1hbiBkZXBlbmRlbmN5IGlzXG4vLyBicm9rZW4gb3V0LiBXZSBhZGQgdGhlIHdhdGNobWFuIGRlcGVuZGVuY3kgaGVyZS5cbmV4cG9ydCBjbGFzcyBIZ1NlcnZpY2UgZXh0ZW5kcyBIZ1NlcnZpY2VCYXNlIHtcblxuICBfZGVsYXllZEV2ZW50TWFuYWdlcjogRGVsYXllZEV2ZW50TWFuYWdlcjtcbiAgX2xvY2tGaWxlSGVsZDogYm9vbGVhbjtcbiAgX3Nob3VsZFVzZURpcnN0YXRlOiBib29sZWFuO1xuICBfd2F0Y2htYW5DbGllbnQ6ID93YXRjaG1hbi5DbGllbnQ7XG4gIF9hbGxvd0V2ZW50c0FnYWluOiA/KCkgPT4gP3ZvaWQ7XG5cbiAgY29uc3RydWN0b3Iod29ya2luZ0RpcmVjdG9yeTogc3RyaW5nKSB7XG4gICAgc3VwZXIod29ya2luZ0RpcmVjdG9yeSk7XG4gICAgdGhpcy5fZGVsYXllZEV2ZW50TWFuYWdlciA9IG5ldyBEZWxheWVkRXZlbnRNYW5hZ2VyKHNldFRpbWVvdXQsIGNsZWFyVGltZW91dCk7XG4gICAgdGhpcy5fbG9ja0ZpbGVIZWxkID0gZmFsc2U7XG4gICAgdGhpcy5fc2hvdWxkVXNlRGlyc3RhdGUgPSB0cnVlO1xuICAgIHRoaXMuX3N1YnNjcmliZVRvV2F0Y2htYW4oKTtcbiAgfVxuXG4gIGFzeW5jIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5fY2xlYW5VcFdhdGNobWFuKCk7XG4gICAgdGhpcy5fZGVsYXllZEV2ZW50TWFuYWdlci5kaXNwb3NlKCk7XG4gICAgaWYgKHRoaXMuX2RpcnN0YXRlRGVsYXllZEV2ZW50TWFuYWdlcikge1xuICAgICAgdGhpcy5fZGlyc3RhdGVEZWxheWVkRXZlbnRNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIF9hc3luY0V4ZWN1dGVXYXRjaG1hbkNvbW1hbmQoYXJnczogQXJyYXk8bWl4ZWQ+KTogUHJvbWlzZTxPYmplY3Q+IHtcbiAgICBjb25zdCB3YXRjaG1hbkNsaWVudCA9IHRoaXMuX3dhdGNobWFuQ2xpZW50O1xuICAgIGlmICh3YXRjaG1hbkNsaWVudCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcignV2F0Y2htYW4gQ2xpZW50IGlzIG5vdCBpbnRpYWxpemVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gZGVub2RlaWZ5KHdhdGNobWFuQ2xpZW50LmNvbW1hbmQuYmluZCh3YXRjaG1hbkNsaWVudCkpKGFyZ3MpO1xuICB9XG5cbiAgYXN5bmMgX3N1YnNjcmliZVRvV2F0Y2htYW4oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVXNpbmcgYSBsb2NhbCB2YXJpYWJsZSBoZXJlIHRvIGFsbG93IGJldHRlciB0eXBlIHJlZmluZW1lbnQuXG4gICAgY29uc3Qgd2F0Y2htYW5DbGllbnQgPSBuZXcgd2F0Y2htYW4uQ2xpZW50KHtcbiAgICAgIHdhdGNobWFuQmluYXJ5UGF0aDogYXdhaXQgZ2V0V2F0Y2htYW5CaW5hcnlQYXRoKCksXG4gICAgfSk7XG4gICAgdGhpcy5fd2F0Y2htYW5DbGllbnQgPSB3YXRjaG1hbkNsaWVudDtcbiAgICBjb25zdCB3b3JraW5nRGlyZWN0b3J5ID0gdGhpcy5nZXRXb3JraW5nRGlyZWN0b3J5KCk7XG4gICAgd2F0Y2htYW5DbGllbnQuY29tbWFuZChbJ3dhdGNoJywgd29ya2luZ0RpcmVjdG9yeV0sICh3YXRjaEVycm9yLCB3YXRjaFJlc3ApID0+IHtcbiAgICAgIGlmICh3YXRjaEVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW5pdGlhdGluZyB3YXRjaG1hbiB3YXRjaDogJyArIHdhdGNoRXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBCeSBkZWZhdWx0LCB3YXRjaG1hbiB3aWxsIGRlbGl2ZXIgYSBsaXN0IG9mIGFsbCBjdXJyZW50IGZpbGVzIHdoZW4geW91XG4gICAgICAvLyBmaXJzdCBzdWJzY3JpYmUuIFdlIGRvbid0IHdhbnQgdGhpcyBiZWhhdmlvciwgc28gd2UgaXNzdWUgYSBgY2xvY2tgXG4gICAgICAvLyBjb21tYW5kIHRvIGdpdmUgYSBsb2dpY2FsIHRpbWUgY29uc3RyYWludCBvbiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgLy8gVGhpcyBpcyByZWNvbW1lbmRlZCBieSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mYi13YXRjaG1hbi5cbiAgICAgIHdhdGNobWFuQ2xpZW50LmNvbW1hbmQoWydjbG9jaycsIHdvcmtpbmdEaXJlY3RvcnldLCAoY2xvY2tFcnJvciwgY2xvY2tSZXNwKSA9PiB7XG4gICAgICAgIGlmIChjbG9ja0Vycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcXVlcnkgd2F0Y2htYW4gY2xvY2s6ICcsIGNsb2NrRXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcmltYXJ5U3Vic2NyaXB0aW9uRXhwcmVzc2lvbiA9IFsnYWxsb2YnLFxuICAgICAgICAgIFsnbm90JywgWydkaXJuYW1lJywgJy5oZyddXSxcbiAgICAgICAgICBbJ25vdCcsIFsnbmFtZScsICcuaGdpZ25vcmUnLCAnd2hvbGVuYW1lJ11dLFxuICAgICAgICAgIC8vIEhnIGFwcGVhcnMgdG8gbW9kaWZ5IHRlbXBvcmFyeSBmaWxlcyB0aGF0IGJlZ2luIHdpdGggdGhlc2VcbiAgICAgICAgICAvLyBwcmVmaXhlcywgZXZlcnkgdGltZSBhIGZpbGUgaXMgc2F2ZWQuXG4gICAgICAgICAgLy8gVE9ETyAodDc4MzI4MDkpIFJlbW92ZSB0aGlzIHdoZW4gaXQgaXMgdW5uZWNlc3NhcnkuXG4gICAgICAgICAgWydub3QnLCBbJ21hdGNoJywgJ2hnLWNoZWNrZXhlYy0qJywgJ3dob2xlbmFtZSddXSxcbiAgICAgICAgICBbJ25vdCcsIFsnbWF0Y2gnLCAnaGctY2hlY2tsaW5rLSonLCAnd2hvbGVuYW1lJ11dLFxuICAgICAgICAgIC8vIFRoaXMgd2F0Y2htYW4gc3Vic2NyaXB0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIHdoaWNoXG4gICAgICAgICAgLy8gZmlsZXMgdG8gZmV0Y2ggbmV3IHN0YXR1c2VzIGZvci4gVGhlcmUgaXMgbm8gcmVhc29uIHRvIGluY2x1ZGVcbiAgICAgICAgICAvLyBkaXJlY3RvcmllcyBpbiB0aGVzZSB1cGRhdGVzLCBhbmQgaW4gZmFjdCB0aGV5IG1heSBtYWtlIHVzIG92ZXJmZXRjaFxuICAgICAgICAgIC8vIHN0YXR1c2VzLiAoU2VlIGRpZmYgc3VtbWFyeSBvZiBEMjAyMTQ5OC4pXG4gICAgICAgICAgLy8gVGhpcyBsaW5lIHJlc3RyaWN0cyB0aGlzIHN1YnNjcmlwdGlvbiB0byBvbmx5IHJldHVybiBmaWxlcy5cbiAgICAgICAgICBbJ3R5cGUnLCAnZiddLFxuICAgICAgICBdO1xuICAgICAgICBwcmltYXJ5U3Vic2NyaXB0aW9uRXhwcmVzc2lvbiA9XG4gICAgICAgICAgcHJpbWFyeVN1YnNjcmlwdGlvbkV4cHJlc3Npb24uY29uY2F0KGdldFByaW1hcnlXYXRjaG1hblN1YnNjcmlwdGlvblJlZmluZW1lbnRzKCkpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIGZpbGVzIHVucmVsYXRlZCB0byBzb3VyY2UgY29udHJvbC5cbiAgICAgICAgd2F0Y2htYW5DbGllbnQuY29tbWFuZChbXG4gICAgICAgICAgJ3N1YnNjcmliZScsXG4gICAgICAgICAgd29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgICBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9QUklNQVJZLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZpZWxkczogWyduYW1lJywgJ2V4aXN0cycsICduZXcnXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHByaW1hcnlTdWJzY3JpcHRpb25FeHByZXNzaW9uLFxuICAgICAgICAgICAgc2luY2U6IGNsb2NrUmVzcC5jbG9jayxcbiAgICAgICAgICB9LFxuICAgICAgICBdLCAoc3Vic2NyaWJlRXJyb3IsIHN1YnNjcmliZVJlc3ApID0+IHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBzdWJzY3JpYmUgdG8gJHtXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9QUklNQVJZfSB3aXRoIGNsb2NrIGxpbWl0OiBgLFxuICAgICAgICAgICAgICBzdWJzY3JpYmVFcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKGBXYXRjaG1hbiBzdWJzY3JpcHRpb24gJHtXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9QUklNQVJZfSBlc3RhYmxpc2hlZC5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gLmhnaWdub3JlIGZpbGVzLlxuICAgICAgICB3YXRjaG1hbkNsaWVudC5jb21tYW5kKFtcbiAgICAgICAgICAnc3Vic2NyaWJlJyxcbiAgICAgICAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICAgIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHSUdOT1JFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZpZWxkczogWyduYW1lJ10sXG4gICAgICAgICAgICBleHByZXNzaW9uOiBbJ25hbWUnLCAnLmhnaWdub3JlJywgJ3dob2xlbmFtZSddLFxuICAgICAgICAgICAgc2luY2U6IGNsb2NrUmVzcC5jbG9jayxcbiAgICAgICAgICB9LFxuICAgICAgICBdLCAoc3Vic2NyaWJlRXJyb3IsIHN1YnNjcmliZVJlc3ApID0+IHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBzdWJzY3JpYmUgdG8gJHtXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0lHTk9SRX0gd2l0aCBjbG9jayBsaW1pdDogYCxcbiAgICAgICAgICAgICAgc3Vic2NyaWJlRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgV2F0Y2htYW4gc3Vic2NyaXB0aW9uICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdJR05PUkV9IGVzdGFibGlzaGVkLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlcyB0byB0aGUgc291cmNlIGNvbnRyb2wgbG9jayBmaWxlLlxuICAgICAgICB3YXRjaG1hbkNsaWVudC5jb21tYW5kKFtcbiAgICAgICAgICAnc3Vic2NyaWJlJyxcbiAgICAgICAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICAgIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHTE9DSyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmaWVsZHM6IFsnbmFtZScsICdleGlzdHMnXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFsnbmFtZScsICcuaGcvd2xvY2snLCAnd2hvbGVuYW1lJ10sXG4gICAgICAgICAgICBzaW5jZTogY2xvY2tSZXNwLmNsb2NrLFxuICAgICAgICAgICAgZGVmZXJfdmNzOiBmYWxzZSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLCAoc3Vic2NyaWJlRXJyb3IsIHN1YnNjcmliZVJlc3ApID0+IHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBzdWJzY3JpYmUgdG8gJHtXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0xPQ0t9IHdpdGggY2xvY2sgbGltaXQ6IGAsXG4gICAgICAgICAgICAgIHN1YnNjcmliZUVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFdhdGNobWFuIHN1YnNjcmlwdGlvbiAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHTE9DS30gZXN0YWJsaXNoZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIHRoZSBzb3VyY2UgY29udHJvbCBkaXJlY3Rvcnkgc3RhdGUgZmlsZS5cbiAgICAgICAgd2F0Y2htYW5DbGllbnQuY29tbWFuZChbXG4gICAgICAgICAgJ3N1YnNjcmliZScsXG4gICAgICAgICAgd29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgICBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0RJUlNUQVRFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZpZWxkczogWyduYW1lJywgJ2V4aXN0cyddLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogWyduYW1lJywgJy5oZy9kaXJzdGF0ZScsICd3aG9sZW5hbWUnXSxcbiAgICAgICAgICAgIHNpbmNlOiBjbG9ja1Jlc3AuY2xvY2ssXG4gICAgICAgICAgICBkZWZlcl92Y3M6IGZhbHNlLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sIChzdWJzY3JpYmVFcnJvciwgc3Vic2NyaWJlUmVzcCkgPT4ge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIHN1YnNjcmliZSB0byAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHRElSU1RBVEV9IHdpdGggY2xvY2sgbGltaXQ6IGAsXG4gICAgICAgICAgICAgIHN1YnNjcmliZUVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBgV2F0Y2htYW4gc3Vic2NyaXB0aW9uICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdESVJTVEFURX0gZXN0YWJsaXNoZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBjdXJyZW50IEhnIGJvb2ttYXJrLlxuICAgICAgICB3YXRjaG1hbkNsaWVudC5jb21tYW5kKFtcbiAgICAgICAgICAnc3Vic2NyaWJlJyxcbiAgICAgICAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICAgIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHQk9PS01BUkssXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRzOiBbJ25hbWUnLCAnZXhpc3RzJ10sXG4gICAgICAgICAgICBleHByZXNzaW9uOiBbJ25hbWUnLCAnLmhnL2Jvb2ttYXJrcy5jdXJyZW50JywgJ3dob2xlbmFtZSddLFxuICAgICAgICAgICAgc2luY2U6IGNsb2NrUmVzcC5jbG9jayxcbiAgICAgICAgICAgIGRlZmVyX3ZjczogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSwgKHN1YnNjcmliZUVycm9yLCBzdWJzY3JpYmVSZXNwKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZUVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gc3Vic2NyaWJlIHRvICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdCT09LTUFSS30gd2l0aCBjbG9jayBsaW1pdDogYCxcbiAgICAgICAgICAgICAgc3Vic2NyaWJlRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIGBXYXRjaG1hbiBzdWJzY3JpcHRpb24gJHtXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0JPT0tNQVJLfSBlc3RhYmxpc2hlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gYSBmaWxlIHRoYXQgYXBwZWFycyB0byBiZSB0aGUgJ2FyYyBidWlsZCcgbG9jayBmaWxlLlxuICAgICAgICBjb25zdCBhcmNCdWlsZExvY2tGaWxlID0gZ2V0QXJjQnVpbGRMb2NrRmlsZSgpO1xuICAgICAgICBpZiAoYXJjQnVpbGRMb2NrRmlsZSkge1xuICAgICAgICAgIHdhdGNobWFuQ2xpZW50LmNvbW1hbmQoW1xuICAgICAgICAgICAgJ3N1YnNjcmliZScsXG4gICAgICAgICAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICAgICAgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfQVJDX0JVSUxEX0xPQ0ssXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZpZWxkczogWyduYW1lJywgJ2V4aXN0cyddLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBbJ25hbWUnLCBhcmNCdWlsZExvY2tGaWxlLCAnd2hvbGVuYW1lJ10sXG4gICAgICAgICAgICAgIHNpbmNlOiBjbG9ja1Jlc3AuY2xvY2ssXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sIChzdWJzY3JpYmVFcnJvciwgc3Vic2NyaWJlUmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZUVycm9yKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIHN1YnNjcmliZSB0byAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0FSQ19CVUlMRF9MT0NLfSBgICtcbiAgICAgICAgICAgICAgICAgIGB3aXRoIGNsb2NrIGxpbWl0OiBgLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZUVycm9yXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgYFdhdGNobWFuIHN1YnNjcmlwdGlvbiAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0FSQ19CVUlMRF9MT0NLfSBlc3RhYmxpc2hlZC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gTWVyY3VyaWFsIGNyZWF0ZXMgdGhlIC5oZy93bG9jayBmaWxlIGJlZm9yZSBpdCBtb2RpZmllcyB0aGUgd29ya2luZyBkaXJlY3RvcnksXG4gICAgICAvLyBhbmQgZGVsZXRlcyBpdCB3aGVuIGl0J3MgZG9uZS4gV2Ugd2FudCB0byBpZ25vcmUgdGhlIHdhdGNobWFuIHVwZGF0ZXNcbiAgICAgIC8vIGNhdXNlZCBieSB0aGVzZSBtb2RpZmljYXRpb25zLCBzbyB3ZSBkbyB0d28gdGhpbmdzOlxuICAgICAgLy8gMS4gVGhlIGZpcnN0IGxldmVsIG9mIGRlZmVuc2UgaXMgdG8gd2F0Y2ggZm9yIHRoZSBjcmVhdGlvbiBhbmQgZGVsZXRpb24gb2ZcbiAgICAgIC8vIHRoZSB3bG9jayBhbmQgaWdub3JlIGV2ZW50cyBhY2NvcmRpbmdseS5cbiAgICAgIC8vIEhvd2V2ZXIsIHRoZSB3YXRjaG1hbiB1cGRhdGUgZm9yIHRoZSBmaWxlcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgICAgLy8gZHVlIHRvIHRoZSBNZXJjdXJpYWwgYWN0aW9uIG1heSBhcnJpdmUgYmVmb3JlIHRoZSB1cGRhdGUgZm9yIHRoZSB3bG9ja1xuICAgICAgLy8gZmlsZS5cbiAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIGludHJvZHVjZSBhbiBhcnRpZmljaWFsIGRlbGF5IGZvciB0aGUgd2F0Y2htYW5cbiAgICAgIC8vIHVwZGF0ZXMgZm9yIG91ciBmaWxlcyBvZiBpbnRlcmVzdCwgd2hpY2ggYWxsb3dzIHRpbWUgZm9yIGEgd2xvY2sgd2F0Y2htYW5cbiAgICAgIC8vIHVwZGF0ZSAoaWYgYW55KSB0byBhcnJpdmUgYW5kIGNhbmNlbCB0aGVtLlxuICAgICAgLy8gVGhpcyBtYXkgb2NjYXNpb25hbGx5IHJlc3VsdCBpbiBhIGZhbHNlIHBvc2l0aXZlOiBjYW5jZWxsaW5nIGV2ZW50cyB0aGF0XG4gICAgICAvLyB3ZXJlIGdlbmVyYXRlZCBieSBhIHVzZXIgYWN0aW9uIChub3QgTWVyY3VyaWFsKSB0aGF0IG9jY3VyIHNob3J0bHkgYmVmb3JlXG4gICAgICAvLyBNZXJjdXJpYWwgbW9kaWZpZXMgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LiBCdXQgdGhpcyBzaG91bGQgYmUgZmluZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGNsaWVudCBvZiBMb2NhbEhnU2VydmljZSBzaG91bGQgYmUgcmVhY3RpbmcgdG8gdGhlXG4gICAgICAvLyAnb25IZ1JlcG9TdGF0ZURpZENoYW5nZScgZXZlbnQgdGhhdCBmb2xsb3dzIHRoZSBNZXJjdXJpYWwgZXZlbnQuXG4gICAgICAvLyAyLiBUaGUgd2xvY2sgaXMgc3VyZXN0IHdheSB0byBkZXRlY3QgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGV2ZW50cy4gQnV0XG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgdHJhbnNpZW50IGZpbGUsIHdhdGNobWFuIG1heSBub3QgcGljayB1cCBvbiBpdCwgZXNwZWNpYWxseVxuICAgICAgLy8gaWYgdGhlIE1lcmN1cmlhbCBhY3Rpb24gaXMgcXVpY2sgKGUuZy4gYSBjb21taXQsIGFzIG9wcG9zZWQgdG8gYSByZWJhc2UpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGZhbGwgYmFjayBvbiB3YXRjaGluZyB0aGUgZGlyc3RhdGUsIHdoaWNoIGlzIGEgcGVyc2lzdGVudFxuICAgICAgLy8gZmlsZSB0aGF0IGlzIHdyaXR0ZW4gdG8gd2hlbmV2ZXIgTWVyY3VyaWFsIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSB3b3JraW5nXG4gICAgICAvLyBkaXJlY3RvcnkgKGV4Y2VwdCByZXZlcnRzIC0tIGJ1dCB0aGlzIHdpbGwgYWxzbyBtb2RpZnkgdGhlIHN0YXRlIG9mIHRoZVxuICAgICAgLy8gcmVsZXZhbnQgZmlsZXMpLiBUaGUgZGlyc3RhdGUgZ2V0cyBtb2RpZmllZCBpbiB0aGUgbWlkZGxlIG9mIGFuIHVwZGF0ZVxuICAgICAgLy8gYW5kIGF0IHRoZSBlbmQsIGJ1dCBub3QgdGhlIGJlZ2lubmluZy4gVGhlcmVmb3JlIGl0J3MgYSBiaXQgbm9pc2llciBvZlxuICAgICAgLy8gYSBzaWduYWwsIGFuZCBpcyBwcm9uZSB0byBib3RoIGZhbHNlIHBvc2l0aXZlcyBhbmQgbmVnYXRpdmVzLlxuICAgICAgd2F0Y2htYW5DbGllbnQub24oJ3N1YnNjcmlwdGlvbicsICh1cGRhdGUpID0+IHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zdWJzY3JpcHRpb24gPT09IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX1BSSU1BUlkpIHtcbiAgICAgICAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLmFkZEV2ZW50KFxuICAgICAgICAgICAgdGhpcy5fZmlsZXNEaWRDaGFuZ2UuYmluZCh0aGlzLCB1cGRhdGUpLFxuICAgICAgICAgICAgRVZFTlRfREVMQVlfSU5fTVNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS5zdWJzY3JpcHRpb24gPT09IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHSUdOT1JFKSB7XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIHRocmVlIGV2ZW50cyB0aGF0IG1heSBvdXRkYXRlIHRoZSBzdGF0dXMgb2YgaWdub3JlZCBmaWxlcy5cbiAgICAgICAgICAvLyAxLiBUaGUgLmhnaWdub3JlIGZpbGUgY2hhbmdlcy4gSW4gdGhpcyBjYXNlLCB3ZSB3YW50IHRvIHJ1biBhIGZyZXNoICdoZyBzdGF0dXMgLWknLlxuICAgICAgICAgIC8vIDIuIEEgZmlsZSBpcyBhZGRlZCB0aGF0IG1lZXRzIHRoZSBjcml0ZXJpYSB1bmRlciAuaGdpZ25vcmUuIEluIHRoaXMgY2FzZSwgd2UgY2FuXG4gICAgICAgICAgLy8gICAgc2NvcGUgdGhlICdoZyBzdGF0dXMgLWknIGNhbGwgdG8ganVzdCB0aGUgYWRkZWQgZmlsZS5cbiAgICAgICAgICAvLyAzLiBBIGZpbGUgdGhhdCB3YXMgcHJldmlvdXNseSBpZ25vcmVkLCBoYXMgYmVlbiBkZWxldGVkLiAoQSBiaXQgZGViYXRhYmxlIGluIHRoaXNcbiAgICAgICAgICAvLyAgICBjYXNlIHdoYXQgOjppc1BhdGhJZ25vcmVkIHNob3VsZCByZXR1cm4gaWYgdGhlIGZpbGUgZG9lc24ndCBleGlzdC4gQnV0IGxldCdzXG4gICAgICAgICAgLy8gICAgYXQgbGVhc3Qga2VlcCB0aGUgbG9jYWwgY2FjaGUgdXBkYXRlZC4pIEluIHRoaXMgY2FzZSwgd2UganVzdCB3YW50IHRvIHJlbW92ZVxuICAgICAgICAgIC8vICAgIHRoZSBkZWxldGVkIGZpbGUgaWYgaXQgaXMgaW4gdGhlIGNhY2hlLlxuICAgICAgICAgIC8vIENhc2UgMSBpcyBjb3ZlcmVkIGJ5IHRoZSByZXNwb25zZSB0byBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0lHTk9SRSBmaXJpbmcuXG4gICAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMyBhcmUgY292ZXJlZCBieSB0aGUgcmVzcG9uc2UgdG8gV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfUFJJTUFSWSBmaXJpbmcuXG4gICAgICAgICAgdGhpcy5fZGVsYXllZEV2ZW50TWFuYWdlci5hZGRFdmVudChcbiAgICAgICAgICAgIHRoaXMuX2hnSWdub3JlRmlsZURpZENoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgRVZFTlRfREVMQVlfSU5fTVNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS5zdWJzY3JpcHRpb24gPT09IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHTE9DSyB8fFxuICAgICAgICAgICAgICAgICAgIHVwZGF0ZS5zdWJzY3JpcHRpb24gPT09IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0FSQ19CVUlMRF9MT0NLKSB7XG4gICAgICAgICAgY29uc3QgbG9ja2ZpbGUgPSB1cGRhdGUuZmlsZXNbMF07XG4gICAgICAgICAgaWYgKGxvY2tmaWxlLmV4aXN0cykge1xuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGEgdGltZXIgdG8gdW5zZXQgdGhpcywgaW4gY2FzZSB3YXRjaG1hbiB1cGRhdGVcbiAgICAgICAgICAgIC8vIGZhaWxzIHRvIG5vdGlmeSBvZiB0aGUgcmVtb3ZhbCBvZiB0aGUgbG9jay4gSSBoYXZlbid0IHNlZW4gdGhpc1xuICAgICAgICAgICAgLy8gaW4gcHJhY3RpY2UgYnV0IGl0J3MgYmV0dGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICB0aGlzLl9sb2NrRmlsZUhlbGQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVGhlIGxvY2sgYmVpbmcgY3JlYXRlZCBpcyBhIGRlZmluaXRpdmUgc3RhcnQgdG8gYSBNZXJjdXJpYWwgYWN0aW9uL2FyYyBidWlsZC5cbiAgICAgICAgICAgIC8vIEJsb2NrIHRoZSBlZmZlY3RzIGZyb20gYW55IGRpcnN0YXRlIGNoYW5nZSwgd2hpY2ggaXMgYSBmdXp6aWVyIHNpZ25hbC5cbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFVzZURpcnN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLnNldENhbkFjY2VwdEV2ZW50cyhmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLmNhbmNlbEFsbEV2ZW50cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NrRmlsZUhlbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ZWRFdmVudE1hbmFnZXIuc2V0Q2FuQWNjZXB0RXZlbnRzKHRydWUpO1xuICAgICAgICAgICAgLy8gVGhlIGxvY2sgYmVpbmcgZGVsZXRlZCBpcyBhIGRlZmluaXRpdmUgZW5kIHRvIGEgTWVyY3VyaWFsIGFjdGlvbi9hcmMgYnVpbGQuXG4gICAgICAgICAgICAvLyBCbG9jayB0aGUgZWZmZWN0cyBmcm9tIGFueSBkaXJzdGF0ZSBjaGFuZ2UsIHdoaWNoIGlzIGEgZnV6emllciBzaWduYWwuXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRVc2VEaXJzdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9oZ0xvY2tEaWRDaGFuZ2UobG9ja2ZpbGUuZXhpc3RzKTtcbiAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUuc3Vic2NyaXB0aW9uID09PSBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0RJUlNUQVRFKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZSBjaGFuZ2UgdG8gdGhlIGRpcnN0YXRlIGlzIGF0IHRoZSBtaWRkbGUgb3IgZW5kXG4gICAgICAgICAgLy8gb2YgYSBNZXJjdXJpYWwgYWN0aW9uLiBCdXQgd2Ugd291bGQgcmF0aGVyIGhhdmUgZmFsc2UgcG9zaXRpdmVzIChpZ25vcmVcbiAgICAgICAgICAvLyBzb21lIHVzZXItZ2VuZXJhdGVkIGV2ZW50cyB0aGF0IG9jY3VyIG5lYXIgYSBNZXJjdXJpYWwgZXZlbnQpIHRoYW4gZmFsc2VcbiAgICAgICAgICAvLyBuZWdhdGl2ZXMgKHJlZ2lzdGVyIGlycmVsZXZhbnQgTWVyY3VyaWFsIGV2ZW50cykuXG4gICAgICAgICAgLy8gRWFjaCB0aW1lIHRoaXMgd2F0Y2htYW4gdXBkYXRlIGZpcmVzLCB3ZSB3aWxsIG1ha2UgdGhlIExvY2FsSGdTZXJ2aWNlXG4gICAgICAgICAgLy8gaWdub3JlIGV2ZW50cyBmb3IgYSBjZXJ0YWluIGdyYWNlIHBlcmlvZC5cblxuICAgICAgICAgIC8vIEEgbG9jayBmaWxlIGlzIGEgbW9yZSByZWxpYWJsZSBzaWduYWwsIHNvIGRlZmVyIHRvIGl0LlxuICAgICAgICAgIGlmICh0aGlzLl9sb2NrRmlsZUhlbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zaG91bGRVc2VEaXJzdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fZGVsYXllZEV2ZW50TWFuYWdlci5zZXRDYW5BY2NlcHRFdmVudHMoZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX2RlbGF5ZWRFdmVudE1hbmFnZXIuY2FuY2VsQWxsRXZlbnRzKCk7XG5cbiAgICAgICAgICAvLyBVc2luZyBhIGxvY2FsIHZhcmlhYmxlIGhlcmUgdG8gYWxsb3cgYmV0dGVyIHR5cGUgcmVmaW5lbWVudC5cbiAgICAgICAgICBsZXQgYWxsb3dFdmVudHNBZ2FpbiA9IHRoaXMuX2FsbG93RXZlbnRzQWdhaW47XG4gICAgICAgICAgaWYgKCFhbGxvd0V2ZW50c0FnYWluKSB7XG4gICAgICAgICAgICBhbGxvd0V2ZW50c0FnYWluID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkVXNlRGlyc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLnNldENhbkFjY2VwdEV2ZW50cyh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZ0RpcnN0YXRlRGlkQ2hhbmdlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBFVkVOVF9ERUxBWV9JTl9NUyxcbiAgICAgICAgICAgIC8qIGltbWVkaWF0ZSAqLyBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9hbGxvd0V2ZW50c0FnYWluID0gYWxsb3dFdmVudHNBZ2FpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWxsb3dFdmVudHNBZ2FpbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS5zdWJzY3JpcHRpb24gPT09IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHQk9PS01BUkspIHtcbiAgICAgICAgICB0aGlzLl9oZ0Jvb2ttYXJrRGlkQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgX2NsZWFuVXBXYXRjaG1hbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB3YXRjaG1hbkNsaWVudCA9IHRoaXMuX3dhdGNobWFuQ2xpZW50O1xuICAgIGlmICh3YXRjaG1hbkNsaWVudCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLl9hc3luY0V4ZWN1dGVXYXRjaG1hbkNvbW1hbmQoXG4gICAgICAgICAgWyd1bnN1YnNjcmliZScsIHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpLCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9QUklNQVJZXVxuICAgICAgICApLFxuICAgICAgICB0aGlzLl9hc3luY0V4ZWN1dGVXYXRjaG1hbkNvbW1hbmQoXG4gICAgICAgICAgWyd1bnN1YnNjcmliZScsIHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpLCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0lHTk9SRV1cbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5fYXN5bmNFeGVjdXRlV2F0Y2htYW5Db21tYW5kKFxuICAgICAgICAgIFsndW5zdWJzY3JpYmUnLCB0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnkoKSwgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdMT0NLXVxuICAgICAgICApLFxuICAgICAgICB0aGlzLl9hc3luY0V4ZWN1dGVXYXRjaG1hbkNvbW1hbmQoXG4gICAgICAgICAgWyd1bnN1YnNjcmliZScsIHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpLCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0RJUlNUQVRFXVxuICAgICAgICApLFxuICAgICAgICBhd2FpdCB0aGlzLl9hc3luY0V4ZWN1dGVXYXRjaG1hbkNvbW1hbmQoXG4gICAgICAgICAgWyd1bnN1YnNjcmliZScsIHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpLCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0JPT0tNQVJLXVxuICAgICAgICApLFxuICAgICAgXSk7XG4gICAgICB3YXRjaG1hbkNsaWVudC5lbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHVwZGF0ZSBUaGUgbGF0ZXN0IHdhdGNobWFuIHVwZGF0ZS5cbiAgICovXG4gIF9maWxlc0RpZENoYW5nZSh1cGRhdGU6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHdvcmtpbmdEaXJlY3RvcnkgPSB0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnkoKTtcbiAgICBjb25zdCBjaGFuZ2VkRmlsZXMgPSB1cGRhdGUuZmlsZXMubWFwKGZpbGUgPT4gcGF0aC5qb2luKHdvcmtpbmdEaXJlY3RvcnksIGZpbGUubmFtZSkpO1xuICAgIHRoaXMuX2ZpbGVzRGlkQ2hhbmdlT2JzZXJ2ZXIub25OZXh0KGNoYW5nZWRGaWxlcyk7XG4gIH1cblxuICBfaGdJZ25vcmVGaWxlRGlkQ2hhbmdlKCk6IHZvaWQge1xuICAgIHRoaXMuX2hnSWdub3JlRmlsZURpZENoYW5nZU9ic2VydmVyLm9uTmV4dCgpO1xuICB9XG5cbiAgX2hnTG9ja0RpZENoYW5nZShsb2NrRXhpc3RzOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKCFsb2NrRXhpc3RzKSB7XG4gICAgICB0aGlzLl9lbWl0SGdSZXBvU3RhdGVDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgX2hnRGlyc3RhdGVEaWRDaGFuZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5fZW1pdEhnUmVwb1N0YXRlQ2hhbmdlZCgpO1xuICB9XG5cbiAgX2VtaXRIZ1JlcG9TdGF0ZUNoYW5nZWQoKSB7XG4gICAgdGhpcy5faGdSZXBvU3RhdGVEaWRDaGFuZ2VPYnNlcnZlci5vbk5leHQoKTtcbiAgfVxuXG4gIF9oZ0Jvb2ttYXJrRGlkQ2hhbmdlKCk6IHZvaWQge1xuICAgIHRoaXMuX2hnQm9va21hcmtEaWRDaGFuZ2VPYnNlcnZlci5vbk5leHQoKTtcbiAgfVxuXG59XG4iXX0=
