
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var INITIAL_CHUNK_SIZE = 200;

/**
 * Value of the `.errorCode` property on the `Error` for a rejected Promise
 * returned by `PathSet.submit()`.
 */
var ERROR_CODE_CANCELED = 21;

// TODO(mikeo): Replace this with nuclide-logging once #6378527 is fixed.
var logger = {
  debug: function debug() {
    // Uncomment for debugging.
    // console.log.apply(console, args);
  }
};

/**
 * A set of paths to iterate over. This set may be extremely large (more than
 * 500,000 items), so processing is performed in chunks as to not lock up the
 * event loop.
 *
 * Because processing is performed in chunks, it is possible that mutations to
 * the set could be interleaved with chunk processing, so special care is
 * taken to ensure that each Processor sees a consistent view of the contents
 * of the set.
 */

var PathSet = (function () {
  _createClass(PathSet, null, [{
    key: 'ERROR_CODE_CANCELED',

    // $FlowIssue t8486988
    value: ERROR_CODE_CANCELED,
    enumerable: true
  }]);

  function PathSet() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, PathSet);

    // An ordinary JavaScript object is used instead of an ES6 Map or Set
    // because this code may also be run on Node 0.10.x, which would require the
    // use of an ES6 polyfill, which may not be performant enough for an
    // extremely large collection.
    // Each key in this object is a file path; each value is the boolean `true`.
    this._paths = options.paths || {};

    this._initialChunkSize = options.initialChunkSize || INITIAL_CHUNK_SIZE;

    // If non-null, this is an object with `this._paths` in its prototype chain.
    // For this object, and every object in its prototype chain up to, but not
    // including, `this._paths`, each key in this object is a file path while
    // each value is either `true` or `false`.
    //
    // Each link in the prototype chain represents a set of modifications to the
    // members of this PathSet where `true`/`false` corresponds to
    // presence/absence in the PathSet. Because of the way prototypes work in
    // JavaScript, checking for the presence of a path in this PathSet in the
    // context of the aggregate changes can be achieved via:
    //
    //     (this._latestPaths || this._paths)[path] === true
    //
    // Each Processor will operate on a link in the prototype chain. Once a link
    // is created (except for the root, this._paths), it is never modified, so
    // the Processor is guaranteed to see a consistent view of the set from the
    // time it starts processing.
    this._latestPaths = null;

    // This array has the invariant that every element corresponds to a job
    // that is running.
    this._jobs = [];
  }

  /**
   * Given two objects where one is a descendant of the other in the prototype
   * chain, return an array that corresponds to the chain of prototype objects.
   *
   * @return an Array ordered by "distance in the prototype chain from ancestor"
   *     in ascending order. The ancestor argument will not be in the Array.
   */

  // TODO(mbolin): If the list of paths passed to addPaths() and removePaths()
  // is very large, then those methods could block the event loop. Consider
  // dividing things up to do the processing in batches, though that would
  // require changing those methods to be async. If that happens, care must be
  // taken to ensure that all class invariants are maintained. In practice,
  // providing the option to specify this._paths via the constructor might be
  // sufficient because the initial call to addPaths() is likely to require a
  // lot of processing, but subsequent updates are expected to be considerably
  // smaller.

  _createClass(PathSet, [{
    key: 'addPaths',
    value: function addPaths(paths) {
      var _this = this;

      if (this._jobs.length === 0) {
        // No jobs in process: update this._paths directly.
        paths.forEach(function (path) {
          _this._paths[path] = true;
        });
      } else {
        (function () {
          // Otherwise, add a new head to the this._latestPaths chain.
          var proto = _this._latestPaths || _this._paths;
          var props = {};
          paths.forEach(function (path) {
            props[path] = { value: true, enumerable: true };
          });
          _this._latestPaths = Object.freeze(Object.create(proto, props));
        })();
      }
    }
  }, {
    key: 'removePaths',
    value: function removePaths(paths) {
      var _this2 = this;

      if (this._jobs.length === 0) {
        // No jobs in process: update this._paths directly.
        paths.forEach(function (path) {
          delete _this2._paths[path];
        });
      } else {
        (function () {
          // Otherwise, add a new head to the this._latestPaths chain.
          var proto = _this2._latestPaths || _this2._paths;
          var props = {};
          paths.forEach(function (path) {
            props[path] = { value: false, enumerable: true };
          });
          _this2._latestPaths = Object.freeze(Object.create(proto, props));
        })();
      }
    }

    /**
     * Helper function to iterate over all the elements in this set.
     * Compatible with https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach.
     */
  }, {
    key: 'forEach',
    value: function forEach(callback) {
      for (var _path in this._paths) {
        callback(_path, _path, this);
      }
    }

    /**
     * Helper function to obtain a list of all of the paths in this set.
     */
  }, {
    key: 'values',
    value: function values() {
      var values = [];
      for (var _path2 in this._paths) {
        values.push(_path2);
      }
      return values;
    }

    /**
     * Submits a processor and returns a special `Promise` that has a
     * `cancelJob()` method that can be used to cancel this job, which will reject
     * the `Promise`.
     *
     * If the returned `Promise` is canceled because `cancelJob()` was invoked (as
     * opposed to some sort of internal error), the `errorCode` property of the
     * `Error` will be `PathSet.ERROR_CODE_CANCELED`.
     */
  }, {
    key: 'submit',
    value: function submit(processor) {
      // Because the paths for the job is iterated via for/in, it is imperative
      // that the paths object is not modified while it is being iterated.
      var job = {
        processor: processor,
        paths: this._latestPaths || this._paths,
        canceled: false,
        startTime: Date.now(),
        chunkCount: 0
      };
      this._jobs.push(job);
      var promise = this._runJob(job);
      // $FlowFixMe: Remove the cancelJob expando off the promise.
      promise.cancelJob = function () {
        job.canceled = true;
      };
      return promise;
    }
  }, {
    key: '_runJob',
    value: function _runJob(job) {
      var _this3 = this;

      var paths = job.paths;
      var processor = job.processor;

      var count = 0;
      var chunkSize = this._initialChunkSize;

      var doCleanup = function doCleanup(err) {
        logger.debug((err ? 'Canceled ' : '') + 'ProcessorJob for ' + processor + ' ' + ('processed ' + job.chunkCount + ' items in ' + (Date.now() - job.startTime) + 'ms.'));

        // Now that the Promise has been determined, remove the job from the list.
        var index = _this3._jobs.indexOf(job);
        _this3._jobs.splice(index, 1);

        // Clean up the modification history to this PathSet, if appropriate.
        _this3._squashHistory();

        if (err) {
          throw err;
        }
      };

      return new Promise(function (resolve, reject) {
        var generator = undefined;
        function* run() {
          for (var _path3 in paths) {
            // Make sure the entry for `path` corresponds to `true`, as the
            // original entry could be shadowed by a nearer property in the
            // prototype chain whose value corresponds to `false`.
            if (paths[_path3] === true) {
              processor(_path3);
            }

            ++count;
            if (count === chunkSize) {
              job.chunkCount += chunkSize;
              process.nextTick(function () {
                if (generator) {
                  generator.next();
                }
              });

              // TODO: fix with https://github.com/facebook/flow/issues/912
              yield undefined;

              // Upon resuming, check whether this job has been canceled.
              if (job.canceled) {
                logger.debug('canceling ' + processor);
                var error = Error('canceled ' + processor);
                // $FlowFixMe: Remove the errorCode expando off the error.
                error.errorCode = ERROR_CODE_CANCELED;
                reject(error);
                return;
              }

              logger.debug('resuming ' + processor);

              // Otherwise, reset the count and process the next chunk.
              count = 0;
              // For each iteration, we double the chunk size under the assumption
              // that the more iterations we have gone through processing this
              // job, the more likely it is that the user is waiting on this job
              // and is not going to preempt it with another job. (Earlier in the
              // iteration cycle, the user is likely still typing,
              // creating/canceling jobs repeatedly.)
              chunkSize *= 2;
            }
          }
          job.chunkCount += count;
          resolve();
        }
        generator = run();
        generator.next();
      }).then(doCleanup, doCleanup);
    }
  }, {
    key: '_squashHistory',
    value: function _squashHistory() {
      var _this4 = this;

      // If the job list is now empty, collapse this._latestPaths, if not null or undefined.
      if (this._latestPaths == null || this._jobs.length !== 0) {
        return;
      }

      var chain = findPrototypeChain(this._paths, this._latestPaths);
      chain.forEach(function (link) {
        for (var _path4 in link) {
          if (link[_path4] === true) {
            _this4._paths[_path4] = true;
          } else {
            delete _this4._paths[_path4];
          }
        }
      });
      this._latestPaths = null;
    }
  }]);

  return PathSet;
})();

exports['default'] = PathSet;
function findPrototypeChain(ancestor, descendant) {
  var chain = [];
  while (ancestor !== descendant) {
    chain.push(descendant);
    descendant = Object.getPrototypeOf(descendant);
  }
  return chain.reverse();
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXBhdGgtc2VhcmNoL2xpYi9QYXRoU2V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JaLElBQU0sa0JBQWtCLEdBQUcsR0FBRyxDQUFDOzs7Ozs7QUFNL0IsSUFBTSxtQkFBbUIsR0FBRyxFQUFFLENBQUM7OztBQUcvQixJQUFNLE1BQU0sR0FBRztBQUNiLE9BQUssRUFBQSxpQkFBVTs7O0dBR2Q7Q0FDRixDQUFDOzs7Ozs7Ozs7Ozs7O0lBWW1CLE9BQU87ZUFBUCxPQUFPOzs7O1dBT0csbUJBQW1COzs7O0FBRXJDLFdBVFEsT0FBTyxHQVNRO1FBQXRCLE9BQWUseURBQUcsRUFBRTs7MEJBVGIsT0FBTzs7Ozs7OztBQWV4QixRQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDOztBQUVsQyxRQUFJLENBQUMsaUJBQWlCLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixJQUFJLGtCQUFrQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJ4RSxRQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQzs7OztBQUl6QixRQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztHQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUF6Q2tCLE9BQU87O1dBcURsQixrQkFBQyxLQUFvQixFQUFFOzs7QUFDN0IsVUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7O0FBRTNCLGFBQUssQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFBRSxnQkFBSyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQUUsQ0FBQyxDQUFDO09BQ3RELE1BQU07OztBQUVMLGNBQU0sS0FBSyxHQUFHLE1BQUssWUFBWSxJQUFJLE1BQUssTUFBTSxDQUFDO0FBQy9DLGNBQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNqQixlQUFLLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSSxFQUFJO0FBQUUsaUJBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBQyxDQUFDO1dBQUUsQ0FBQyxDQUFDO0FBQzFFLGdCQUFLLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7O09BQ2hFO0tBQ0Y7OztXQUVVLHFCQUFDLEtBQW9CLEVBQUU7OztBQUNoQyxVQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7QUFFM0IsYUFBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLElBQUksRUFBSTtBQUFFLGlCQUFPLE9BQUssTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQUUsQ0FBQyxDQUFDO09BQ3RELE1BQU07OztBQUVMLGNBQU0sS0FBSyxHQUFHLE9BQUssWUFBWSxJQUFJLE9BQUssTUFBTSxDQUFDO0FBQy9DLGNBQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNqQixlQUFLLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSSxFQUFJO0FBQUUsaUJBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBQyxDQUFDO1dBQUUsQ0FBQyxDQUFDO0FBQzNFLGlCQUFLLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7O09BQ2hFO0tBQ0Y7Ozs7Ozs7O1dBTU0saUJBQUMsUUFBeUIsRUFBUTtBQUN2QyxXQUFLLElBQU0sS0FBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDOUIsZ0JBQVEsQ0FBQyxLQUFJLEVBQUUsS0FBSSxFQUFFLElBQUksQ0FBQyxDQUFDO09BQzVCO0tBQ0Y7Ozs7Ozs7V0FLSyxrQkFBa0I7QUFDdEIsVUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2xCLFdBQUssSUFBTSxNQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUM5QixjQUFNLENBQUMsSUFBSSxDQUFDLE1BQUksQ0FBQyxDQUFDO09BQ25CO0FBQ0QsYUFBTyxNQUFNLENBQUM7S0FDZjs7Ozs7Ozs7Ozs7OztXQVdLLGdCQUFDLFNBQW9CLEVBQWlCOzs7QUFHMUMsVUFBTSxHQUFHLEdBQUc7QUFDVixpQkFBUyxFQUFULFNBQVM7QUFDVCxhQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsTUFBTTtBQUN2QyxnQkFBUSxFQUFFLEtBQUs7QUFDZixpQkFBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDckIsa0JBQVUsRUFBRSxDQUFDO09BQ2QsQ0FBQztBQUNGLFVBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCLFVBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRWxDLGFBQU8sQ0FBQyxTQUFTLEdBQUcsWUFBTTtBQUN4QixXQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztPQUNyQixDQUFDO0FBQ0YsYUFBTyxPQUFPLENBQUM7S0FDaEI7OztXQUVNLGlCQUFDLEdBQWlCLEVBQWlCOzs7VUFDakMsS0FBSyxHQUFlLEdBQUcsQ0FBdkIsS0FBSztVQUFFLFNBQVMsR0FBSSxHQUFHLENBQWhCLFNBQVM7O0FBQ3ZCLFVBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNkLFVBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQzs7QUFFdkMsVUFBTSxTQUFTLEdBQUcsU0FBWixTQUFTLENBQUksR0FBRyxFQUFhO0FBQ2pDLGNBQU0sQ0FBQyxLQUFLLENBQ1IsQ0FBRyxHQUFHLEdBQUcsV0FBVyxHQUFHLEVBQUUsQ0FBQSx5QkFBb0IsU0FBUyx5QkFDekMsR0FBRyxDQUFDLFVBQVUsbUJBQWEsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUEsU0FBSyxDQUFDLENBQUM7OztBQUc3RSxZQUFNLEtBQUssR0FBRyxPQUFLLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdEMsZUFBSyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQzs7O0FBRzVCLGVBQUssY0FBYyxFQUFFLENBQUM7O0FBRXRCLFlBQUksR0FBRyxFQUFFO0FBQ1AsZ0JBQU0sR0FBRyxDQUFDO1NBQ1g7T0FDRixDQUFDOztBQUVGLGFBQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLO0FBQ3RDLFlBQUksU0FBUyxZQUFBLENBQUM7QUFDZCxrQkFBVSxHQUFHLEdBQUc7QUFDZCxlQUFLLElBQU0sTUFBSSxJQUFJLEtBQUssRUFBRTs7OztBQUl4QixnQkFBSSxLQUFLLENBQUMsTUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQ3hCLHVCQUFTLENBQUMsTUFBSSxDQUFDLENBQUM7YUFDakI7O0FBRUQsY0FBRSxLQUFLLENBQUM7QUFDUixnQkFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO0FBQ3ZCLGlCQUFHLENBQUMsVUFBVSxJQUFJLFNBQVMsQ0FBQztBQUM1QixxQkFBTyxDQUFDLFFBQVEsQ0FBQyxZQUFXO0FBQzFCLG9CQUFJLFNBQVMsRUFBRTtBQUNiLDJCQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ2xCO2VBQ0YsQ0FBQyxDQUFDOzs7QUFHSCxvQkFBTSxTQUFTLENBQUM7OztBQUdoQixrQkFBSSxHQUFHLENBQUMsUUFBUSxFQUFFO0FBQ2hCLHNCQUFNLENBQUMsS0FBSyxnQkFBYyxTQUFTLENBQUcsQ0FBQztBQUN2QyxvQkFBTSxLQUFLLEdBQUcsS0FBSyxlQUFhLFNBQVMsQ0FBRyxDQUFDOztBQUU3QyxxQkFBSyxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQztBQUN0QyxzQkFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2QsdUJBQU87ZUFDUjs7QUFFRCxvQkFBTSxDQUFDLEtBQUssZUFBYSxTQUFTLENBQUcsQ0FBQzs7O0FBR3RDLG1CQUFLLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7O0FBT1YsdUJBQVMsSUFBSSxDQUFDLENBQUM7YUFDaEI7V0FDRjtBQUNELGFBQUcsQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDO0FBQ3hCLGlCQUFPLEVBQUUsQ0FBQztTQUNYO0FBQ0QsaUJBQVMsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNsQixpQkFBUyxDQUFDLElBQUksRUFBRSxDQUFDO09BQ2xCLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQy9COzs7V0FFYSwwQkFBRzs7OztBQUVmLFVBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ3hELGVBQU87T0FDUjs7QUFFRCxVQUFNLEtBQUssR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqRSxXQUFLLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSSxFQUFJO0FBQ3BCLGFBQUssSUFBTSxNQUFJLElBQUksSUFBSSxFQUFFO0FBQ3ZCLGNBQUksSUFBSSxDQUFDLE1BQUksQ0FBQyxLQUFLLElBQUksRUFBRTtBQUN2QixtQkFBSyxNQUFNLENBQUMsTUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1dBQzFCLE1BQU07QUFDTCxtQkFBTyxPQUFLLE1BQU0sQ0FBQyxNQUFJLENBQUMsQ0FBQztXQUMxQjtTQUNGO09BQ0YsQ0FBQyxDQUFDO0FBQ0gsVUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7S0FDMUI7OztTQTdOa0IsT0FBTzs7O3FCQUFQLE9BQU87QUF1TzVCLFNBQVMsa0JBQWtCLENBQUMsUUFBZ0IsRUFBRSxVQUFrQixFQUFpQjtBQUMvRSxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDakIsU0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFO0FBQzlCLFNBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDdkIsY0FBVSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7R0FDaEQ7QUFDRCxTQUFPLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztDQUN4QiIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1wYXRoLXNlYXJjaC9saWIvUGF0aFNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnR5cGUgUHJvY2Vzc29yID0gKHBhdGg6IHN0cmluZykgPT4gdm9pZDtcblxudHlwZSBQcm9jZXNzb3JKb2IgPSB7XG4gIHByb2Nlc3NvcjogUHJvY2Vzc29yO1xuICBwYXRoczoge1trZXk6IHN0cmluZ106IGJvb2xlYW59O1xuICBjYW5jZWxlZDogYm9vbGVhbjtcbiAgc3RhcnRUaW1lOiBudW1iZXI7XG4gIGNodW5rU2l6ZT86IG51bWJlcjtcbiAgY2h1bmtDb3VudDogbnVtYmVyO1xufTtcblxudHlwZSBGb3JFYWNoQ2FsbGJhY2sgPSAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIHNldDogUGF0aFNldCkgPT4gdm9pZDtcblxuY29uc3QgSU5JVElBTF9DSFVOS19TSVpFID0gMjAwO1xuXG4vKipcbiAqIFZhbHVlIG9mIHRoZSBgLmVycm9yQ29kZWAgcHJvcGVydHkgb24gdGhlIGBFcnJvcmAgZm9yIGEgcmVqZWN0ZWQgUHJvbWlzZVxuICogcmV0dXJuZWQgYnkgYFBhdGhTZXQuc3VibWl0KClgLlxuICovXG5jb25zdCBFUlJPUl9DT0RFX0NBTkNFTEVEID0gMjE7XG5cbi8vIFRPRE8obWlrZW8pOiBSZXBsYWNlIHRoaXMgd2l0aCBudWNsaWRlLWxvZ2dpbmcgb25jZSAjNjM3ODUyNyBpcyBmaXhlZC5cbmNvbnN0IGxvZ2dlciA9IHtcbiAgZGVidWcoLi4uYXJncykge1xuICAgIC8vIFVuY29tbWVudCBmb3IgZGVidWdnaW5nLlxuICAgIC8vIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9LFxufTtcblxuLyoqXG4gKiBBIHNldCBvZiBwYXRocyB0byBpdGVyYXRlIG92ZXIuIFRoaXMgc2V0IG1heSBiZSBleHRyZW1lbHkgbGFyZ2UgKG1vcmUgdGhhblxuICogNTAwLDAwMCBpdGVtcyksIHNvIHByb2Nlc3NpbmcgaXMgcGVyZm9ybWVkIGluIGNodW5rcyBhcyB0byBub3QgbG9jayB1cCB0aGVcbiAqIGV2ZW50IGxvb3AuXG4gKlxuICogQmVjYXVzZSBwcm9jZXNzaW5nIGlzIHBlcmZvcm1lZCBpbiBjaHVua3MsIGl0IGlzIHBvc3NpYmxlIHRoYXQgbXV0YXRpb25zIHRvXG4gKiB0aGUgc2V0IGNvdWxkIGJlIGludGVybGVhdmVkIHdpdGggY2h1bmsgcHJvY2Vzc2luZywgc28gc3BlY2lhbCBjYXJlIGlzXG4gKiB0YWtlbiB0byBlbnN1cmUgdGhhdCBlYWNoIFByb2Nlc3NvciBzZWVzIGEgY29uc2lzdGVudCB2aWV3IG9mIHRoZSBjb250ZW50c1xuICogb2YgdGhlIHNldC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aFNldCB7XG4gIF9pbml0aWFsQ2h1bmtTaXplOiBudW1iZXI7XG4gIF9wYXRoczoge1trZXk6IHN0cmluZ106IGJvb2xlYW59O1xuICBfbGF0ZXN0UGF0aHM6ID97W2tleTogc3RyaW5nXTogYm9vbGVhbn07XG4gIF9qb2JzOiBBcnJheTxQcm9jZXNzb3JKb2I+O1xuXG4gIC8vICRGbG93SXNzdWUgdDg0ODY5ODhcbiAgc3RhdGljIEVSUk9SX0NPREVfQ0FOQ0VMRUQgPSBFUlJPUl9DT0RFX0NBTkNFTEVEO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE9iamVjdCA9IHt9KSB7XG4gICAgLy8gQW4gb3JkaW5hcnkgSmF2YVNjcmlwdCBvYmplY3QgaXMgdXNlZCBpbnN0ZWFkIG9mIGFuIEVTNiBNYXAgb3IgU2V0XG4gICAgLy8gYmVjYXVzZSB0aGlzIGNvZGUgbWF5IGFsc28gYmUgcnVuIG9uIE5vZGUgMC4xMC54LCB3aGljaCB3b3VsZCByZXF1aXJlIHRoZVxuICAgIC8vIHVzZSBvZiBhbiBFUzYgcG9seWZpbGwsIHdoaWNoIG1heSBub3QgYmUgcGVyZm9ybWFudCBlbm91Z2ggZm9yIGFuXG4gICAgLy8gZXh0cmVtZWx5IGxhcmdlIGNvbGxlY3Rpb24uXG4gICAgLy8gRWFjaCBrZXkgaW4gdGhpcyBvYmplY3QgaXMgYSBmaWxlIHBhdGg7IGVhY2ggdmFsdWUgaXMgdGhlIGJvb2xlYW4gYHRydWVgLlxuICAgIHRoaXMuX3BhdGhzID0gb3B0aW9ucy5wYXRocyB8fCB7fTtcblxuICAgIHRoaXMuX2luaXRpYWxDaHVua1NpemUgPSBvcHRpb25zLmluaXRpYWxDaHVua1NpemUgfHwgSU5JVElBTF9DSFVOS19TSVpFO1xuXG4gICAgLy8gSWYgbm9uLW51bGwsIHRoaXMgaXMgYW4gb2JqZWN0IHdpdGggYHRoaXMuX3BhdGhzYCBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIEZvciB0aGlzIG9iamVjdCwgYW5kIGV2ZXJ5IG9iamVjdCBpbiBpdHMgcHJvdG90eXBlIGNoYWluIHVwIHRvLCBidXQgbm90XG4gICAgLy8gaW5jbHVkaW5nLCBgdGhpcy5fcGF0aHNgLCBlYWNoIGtleSBpbiB0aGlzIG9iamVjdCBpcyBhIGZpbGUgcGF0aCB3aGlsZVxuICAgIC8vIGVhY2ggdmFsdWUgaXMgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgLlxuICAgIC8vXG4gICAgLy8gRWFjaCBsaW5rIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gcmVwcmVzZW50cyBhIHNldCBvZiBtb2RpZmljYXRpb25zIHRvIHRoZVxuICAgIC8vIG1lbWJlcnMgb2YgdGhpcyBQYXRoU2V0IHdoZXJlIGB0cnVlYC9gZmFsc2VgIGNvcnJlc3BvbmRzIHRvXG4gICAgLy8gcHJlc2VuY2UvYWJzZW5jZSBpbiB0aGUgUGF0aFNldC4gQmVjYXVzZSBvZiB0aGUgd2F5IHByb3RvdHlwZXMgd29yayBpblxuICAgIC8vIEphdmFTY3JpcHQsIGNoZWNraW5nIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRoIGluIHRoaXMgUGF0aFNldCBpbiB0aGVcbiAgICAvLyBjb250ZXh0IG9mIHRoZSBhZ2dyZWdhdGUgY2hhbmdlcyBjYW4gYmUgYWNoaWV2ZWQgdmlhOlxuICAgIC8vXG4gICAgLy8gICAgICh0aGlzLl9sYXRlc3RQYXRocyB8fCB0aGlzLl9wYXRocylbcGF0aF0gPT09IHRydWVcbiAgICAvL1xuICAgIC8vIEVhY2ggUHJvY2Vzc29yIHdpbGwgb3BlcmF0ZSBvbiBhIGxpbmsgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi4gT25jZSBhIGxpbmtcbiAgICAvLyBpcyBjcmVhdGVkIChleGNlcHQgZm9yIHRoZSByb290LCB0aGlzLl9wYXRocyksIGl0IGlzIG5ldmVyIG1vZGlmaWVkLCBzb1xuICAgIC8vIHRoZSBQcm9jZXNzb3IgaXMgZ3VhcmFudGVlZCB0byBzZWUgYSBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIHNldCBmcm9tIHRoZVxuICAgIC8vIHRpbWUgaXQgc3RhcnRzIHByb2Nlc3NpbmcuXG4gICAgdGhpcy5fbGF0ZXN0UGF0aHMgPSBudWxsO1xuXG4gICAgLy8gVGhpcyBhcnJheSBoYXMgdGhlIGludmFyaWFudCB0aGF0IGV2ZXJ5IGVsZW1lbnQgY29ycmVzcG9uZHMgdG8gYSBqb2JcbiAgICAvLyB0aGF0IGlzIHJ1bm5pbmcuXG4gICAgdGhpcy5fam9icyA9IFtdO1xuICB9XG5cbiAgLy8gVE9ETyhtYm9saW4pOiBJZiB0aGUgbGlzdCBvZiBwYXRocyBwYXNzZWQgdG8gYWRkUGF0aHMoKSBhbmQgcmVtb3ZlUGF0aHMoKVxuICAvLyBpcyB2ZXJ5IGxhcmdlLCB0aGVuIHRob3NlIG1ldGhvZHMgY291bGQgYmxvY2sgdGhlIGV2ZW50IGxvb3AuIENvbnNpZGVyXG4gIC8vIGRpdmlkaW5nIHRoaW5ncyB1cCB0byBkbyB0aGUgcHJvY2Vzc2luZyBpbiBiYXRjaGVzLCB0aG91Z2ggdGhhdCB3b3VsZFxuICAvLyByZXF1aXJlIGNoYW5naW5nIHRob3NlIG1ldGhvZHMgdG8gYmUgYXN5bmMuIElmIHRoYXQgaGFwcGVucywgY2FyZSBtdXN0IGJlXG4gIC8vIHRha2VuIHRvIGVuc3VyZSB0aGF0IGFsbCBjbGFzcyBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkLiBJbiBwcmFjdGljZSxcbiAgLy8gcHJvdmlkaW5nIHRoZSBvcHRpb24gdG8gc3BlY2lmeSB0aGlzLl9wYXRocyB2aWEgdGhlIGNvbnN0cnVjdG9yIG1pZ2h0IGJlXG4gIC8vIHN1ZmZpY2llbnQgYmVjYXVzZSB0aGUgaW5pdGlhbCBjYWxsIHRvIGFkZFBhdGhzKCkgaXMgbGlrZWx5IHRvIHJlcXVpcmUgYVxuICAvLyBsb3Qgb2YgcHJvY2Vzc2luZywgYnV0IHN1YnNlcXVlbnQgdXBkYXRlcyBhcmUgZXhwZWN0ZWQgdG8gYmUgY29uc2lkZXJhYmx5XG4gIC8vIHNtYWxsZXIuXG5cbiAgYWRkUGF0aHMocGF0aHM6IEFycmF5PHN0cmluZz4pIHtcbiAgICBpZiAodGhpcy5fam9icy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIGpvYnMgaW4gcHJvY2VzczogdXBkYXRlIHRoaXMuX3BhdGhzIGRpcmVjdGx5LlxuICAgICAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHsgdGhpcy5fcGF0aHNbcGF0aF0gPSB0cnVlOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgYSBuZXcgaGVhZCB0byB0aGUgdGhpcy5fbGF0ZXN0UGF0aHMgY2hhaW4uXG4gICAgICBjb25zdCBwcm90byA9IHRoaXMuX2xhdGVzdFBhdGhzIHx8IHRoaXMuX3BhdGhzO1xuICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7IHByb3BzW3BhdGhdID0ge3ZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlfTsgfSk7XG4gICAgICB0aGlzLl9sYXRlc3RQYXRocyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmNyZWF0ZShwcm90bywgcHJvcHMpKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVQYXRocyhwYXRoczogQXJyYXk8c3RyaW5nPikge1xuICAgIGlmICh0aGlzLl9qb2JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm8gam9icyBpbiBwcm9jZXNzOiB1cGRhdGUgdGhpcy5fcGF0aHMgZGlyZWN0bHkuXG4gICAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4geyBkZWxldGUgdGhpcy5fcGF0aHNbcGF0aF07IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIGFkZCBhIG5ldyBoZWFkIHRvIHRoZSB0aGlzLl9sYXRlc3RQYXRocyBjaGFpbi5cbiAgICAgIGNvbnN0IHByb3RvID0gdGhpcy5fbGF0ZXN0UGF0aHMgfHwgdGhpcy5fcGF0aHM7XG4gICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHsgcHJvcHNbcGF0aF0gPSB7dmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlfTsgfSk7XG4gICAgICB0aGlzLl9sYXRlc3RQYXRocyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmNyZWF0ZShwcm90bywgcHJvcHMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbGwgdGhlIGVsZW1lbnRzIGluIHRoaXMgc2V0LlxuICAgKiBDb21wYXRpYmxlIHdpdGggaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2V0L2ZvckVhY2guXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrOiBGb3JFYWNoQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggaW4gdGhpcy5fcGF0aHMpIHtcbiAgICAgIGNhbGxiYWNrKHBhdGgsIHBhdGgsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gb2J0YWluIGEgbGlzdCBvZiBhbGwgb2YgdGhlIHBhdGhzIGluIHRoaXMgc2V0LlxuICAgKi9cbiAgdmFsdWVzKCk6IEFycmF5PHN0cmluZz4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGF0aCBpbiB0aGlzLl9wYXRocykge1xuICAgICAgdmFsdWVzLnB1c2gocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0cyBhIHByb2Nlc3NvciBhbmQgcmV0dXJucyBhIHNwZWNpYWwgYFByb21pc2VgIHRoYXQgaGFzIGFcbiAgICogYGNhbmNlbEpvYigpYCBtZXRob2QgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhpcyBqb2IsIHdoaWNoIHdpbGwgcmVqZWN0XG4gICAqIHRoZSBgUHJvbWlzZWAuXG4gICAqXG4gICAqIElmIHRoZSByZXR1cm5lZCBgUHJvbWlzZWAgaXMgY2FuY2VsZWQgYmVjYXVzZSBgY2FuY2VsSm9iKClgIHdhcyBpbnZva2VkIChhc1xuICAgKiBvcHBvc2VkIHRvIHNvbWUgc29ydCBvZiBpbnRlcm5hbCBlcnJvciksIHRoZSBgZXJyb3JDb2RlYCBwcm9wZXJ0eSBvZiB0aGVcbiAgICogYEVycm9yYCB3aWxsIGJlIGBQYXRoU2V0LkVSUk9SX0NPREVfQ0FOQ0VMRURgLlxuICAgKi9cbiAgc3VibWl0KHByb2Nlc3NvcjogUHJvY2Vzc29yKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQmVjYXVzZSB0aGUgcGF0aHMgZm9yIHRoZSBqb2IgaXMgaXRlcmF0ZWQgdmlhIGZvci9pbiwgaXQgaXMgaW1wZXJhdGl2ZVxuICAgIC8vIHRoYXQgdGhlIHBhdGhzIG9iamVjdCBpcyBub3QgbW9kaWZpZWQgd2hpbGUgaXQgaXMgYmVpbmcgaXRlcmF0ZWQuXG4gICAgY29uc3Qgam9iID0ge1xuICAgICAgcHJvY2Vzc29yLFxuICAgICAgcGF0aHM6IHRoaXMuX2xhdGVzdFBhdGhzIHx8IHRoaXMuX3BhdGhzLFxuICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgY2h1bmtDb3VudDogMCxcbiAgICB9O1xuICAgIHRoaXMuX2pvYnMucHVzaChqb2IpO1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9ydW5Kb2Ioam9iKTtcbiAgICAvLyAkRmxvd0ZpeE1lOiBSZW1vdmUgdGhlIGNhbmNlbEpvYiBleHBhbmRvIG9mZiB0aGUgcHJvbWlzZS5cbiAgICBwcm9taXNlLmNhbmNlbEpvYiA9ICgpID0+IHtcbiAgICAgIGpvYi5jYW5jZWxlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIF9ydW5Kb2Ioam9iOiBQcm9jZXNzb3JKb2IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7cGF0aHMsIHByb2Nlc3Nvcn0gPSBqb2I7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgY2h1bmtTaXplID0gdGhpcy5faW5pdGlhbENodW5rU2l6ZTtcblxuICAgIGNvbnN0IGRvQ2xlYW51cCA9IChlcnI6ID9FcnJvcikgPT4ge1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICAgIGAke2VyciA/ICdDYW5jZWxlZCAnIDogJyd9UHJvY2Vzc29ySm9iIGZvciAke3Byb2Nlc3Nvcn0gYCArXG4gICAgICAgICAgYHByb2Nlc3NlZCAke2pvYi5jaHVua0NvdW50fSBpdGVtcyBpbiAke0RhdGUubm93KCkgLSBqb2Iuc3RhcnRUaW1lfW1zLmApO1xuXG4gICAgICAvLyBOb3cgdGhhdCB0aGUgUHJvbWlzZSBoYXMgYmVlbiBkZXRlcm1pbmVkLCByZW1vdmUgdGhlIGpvYiBmcm9tIHRoZSBsaXN0LlxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9qb2JzLmluZGV4T2Yoam9iKTtcbiAgICAgIHRoaXMuX2pvYnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIG1vZGlmaWNhdGlvbiBoaXN0b3J5IHRvIHRoaXMgUGF0aFNldCwgaWYgYXBwcm9wcmlhdGUuXG4gICAgICB0aGlzLl9zcXVhc2hIaXN0b3J5KCk7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGdlbmVyYXRvcjtcbiAgICAgIGZ1bmN0aW9uKiBydW4oKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBpbiBwYXRocykge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZW50cnkgZm9yIGBwYXRoYCBjb3JyZXNwb25kcyB0byBgdHJ1ZWAsIGFzIHRoZVxuICAgICAgICAgIC8vIG9yaWdpbmFsIGVudHJ5IGNvdWxkIGJlIHNoYWRvd2VkIGJ5IGEgbmVhcmVyIHByb3BlcnR5IGluIHRoZVxuICAgICAgICAgIC8vIHByb3RvdHlwZSBjaGFpbiB3aG9zZSB2YWx1ZSBjb3JyZXNwb25kcyB0byBgZmFsc2VgLlxuICAgICAgICAgIGlmIChwYXRoc1twYXRoXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcHJvY2Vzc29yKHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGpvYi5jaHVua0NvdW50ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVE9ETzogZml4IHdpdGggaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzkxMlxuICAgICAgICAgICAgeWllbGQgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvLyBVcG9uIHJlc3VtaW5nLCBjaGVjayB3aGV0aGVyIHRoaXMgam9iIGhhcyBiZWVuIGNhbmNlbGVkLlxuICAgICAgICAgICAgaWYgKGpvYi5jYW5jZWxlZCkge1xuICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYGNhbmNlbGluZyAke3Byb2Nlc3Nvcn1gKTtcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBFcnJvcihgY2FuY2VsZWQgJHtwcm9jZXNzb3J9YCk7XG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWU6IFJlbW92ZSB0aGUgZXJyb3JDb2RlIGV4cGFuZG8gb2ZmIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgZXJyb3IuZXJyb3JDb2RlID0gRVJST1JfQ09ERV9DQU5DRUxFRDtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYHJlc3VtaW5nICR7cHJvY2Vzc29yfWApO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHJlc2V0IHRoZSBjb3VudCBhbmQgcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cbiAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGl0ZXJhdGlvbiwgd2UgZG91YmxlIHRoZSBjaHVuayBzaXplIHVuZGVyIHRoZSBhc3N1bXB0aW9uXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBtb3JlIGl0ZXJhdGlvbnMgd2UgaGF2ZSBnb25lIHRocm91Z2ggcHJvY2Vzc2luZyB0aGlzXG4gICAgICAgICAgICAvLyBqb2IsIHRoZSBtb3JlIGxpa2VseSBpdCBpcyB0aGF0IHRoZSB1c2VyIGlzIHdhaXRpbmcgb24gdGhpcyBqb2JcbiAgICAgICAgICAgIC8vIGFuZCBpcyBub3QgZ29pbmcgdG8gcHJlZW1wdCBpdCB3aXRoIGFub3RoZXIgam9iLiAoRWFybGllciBpbiB0aGVcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiBjeWNsZSwgdGhlIHVzZXIgaXMgbGlrZWx5IHN0aWxsIHR5cGluZyxcbiAgICAgICAgICAgIC8vIGNyZWF0aW5nL2NhbmNlbGluZyBqb2JzIHJlcGVhdGVkbHkuKVxuICAgICAgICAgICAgY2h1bmtTaXplICo9IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGpvYi5jaHVua0NvdW50ICs9IGNvdW50O1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBnZW5lcmF0b3IgPSBydW4oKTtcbiAgICAgIGdlbmVyYXRvci5uZXh0KCk7XG4gICAgfSkudGhlbihkb0NsZWFudXAsIGRvQ2xlYW51cCk7XG4gIH1cblxuICBfc3F1YXNoSGlzdG9yeSgpIHtcbiAgICAvLyBJZiB0aGUgam9iIGxpc3QgaXMgbm93IGVtcHR5LCBjb2xsYXBzZSB0aGlzLl9sYXRlc3RQYXRocywgaWYgbm90IG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIGlmICh0aGlzLl9sYXRlc3RQYXRocyA9PSBudWxsIHx8IHRoaXMuX2pvYnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhaW4gPSBmaW5kUHJvdG90eXBlQ2hhaW4odGhpcy5fcGF0aHMsIHRoaXMuX2xhdGVzdFBhdGhzKTtcbiAgICBjaGFpbi5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXRoIGluIGxpbmspIHtcbiAgICAgICAgaWYgKGxpbmtbcGF0aF0gPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9wYXRoc1twYXRoXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3BhdGhzW3BhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fbGF0ZXN0UGF0aHMgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gdHdvIG9iamVjdHMgd2hlcmUgb25lIGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgb3RoZXIgaW4gdGhlIHByb3RvdHlwZVxuICogY2hhaW4sIHJldHVybiBhbiBhcnJheSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBjaGFpbiBvZiBwcm90b3R5cGUgb2JqZWN0cy5cbiAqXG4gKiBAcmV0dXJuIGFuIEFycmF5IG9yZGVyZWQgYnkgXCJkaXN0YW5jZSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGZyb20gYW5jZXN0b3JcIlxuICogICAgIGluIGFzY2VuZGluZyBvcmRlci4gVGhlIGFuY2VzdG9yIGFyZ3VtZW50IHdpbGwgbm90IGJlIGluIHRoZSBBcnJheS5cbiAqL1xuZnVuY3Rpb24gZmluZFByb3RvdHlwZUNoYWluKGFuY2VzdG9yOiBPYmplY3QsIGRlc2NlbmRhbnQ6IE9iamVjdCk6IEFycmF5PE9iamVjdD4ge1xuICBjb25zdCBjaGFpbiA9IFtdO1xuICB3aGlsZSAoYW5jZXN0b3IgIT09IGRlc2NlbmRhbnQpIHtcbiAgICBjaGFpbi5wdXNoKGRlc2NlbmRhbnQpO1xuICAgIGRlc2NlbmRhbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZGVzY2VuZGFudCk7XG4gIH1cbiAgcmV0dXJuIGNoYWluLnJldmVyc2UoKTtcbn1cbiJdfQ==
