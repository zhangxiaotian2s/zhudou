
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _require = require('./flow-annotation');

var isNuclideUriFlowTypeAnnotation = _require.isNuclideUriFlowTypeAnnotation;

var t = require('babel-core').types;

/**
 * Given the identifier, create following assignment expression:
 * `$identifier  = this._connection.getPathOfUri($identifier);`
 */
function _createGetPathOfUriAssignmentExpression(identifier) {
  var callExpression = t.callExpression(
  /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('getPathOfUri')),
  /* arguments */[identifier]);

  return t.expressionStatement(t.assignmentExpression(
  /* operator */'=',
  /* left */identifier,
  /* right */callExpression));
}

/**
 * Given the identifier, create following assignment expression:
 * `$identifier  = this._connection.getUriOfRemotePath($identifier);`
 */
function _createGetUriOfRemotePathAssignmentExpression(identifier) {
  var callExpression = t.callExpression(
  /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('getUriOfRemotePath')),
  /* arguments */[identifier]);

  return t.expressionStatement(t.assignmentExpression(
  /* operator */'=',
  /* left */identifier,
  /* right */callExpression));
}

/**
 * It creates a manipulation assigment expression for an identifier node, by comparing it's flow
 * type with typeNodeValidator.
 *
 * The key feature is that if the node is an Object or an Array, and the object's property or
 * the array's item matches given flow type according to node's flow type definition, the
 * creator could handle it and create correct assignment expression. As long as the flow type of
 * the node is a valid json object, this creator could create the expected assignment
 * expression.
 *
 * For example, say we are intersted in flow type `fooType` and we want to manipulate the
 * object with `fooType` by `object = bar(object)`. Following the expected result of created
 * assignmentExpression:
 *
 * `object: fooType` => `object = bar(object)`.
 *
 * `object: {a: fooType, b: number}` => `object.a = bar(object.a)`.
 *
 * `object: Array<fooType>` => 'object = object.map((arg) => {return bar(arg)})`.
 *
 */

var ManipulationAssignmentExpressionCreator = (function () {

  /**
   * Initialize the creator.
   * @param typeNodeValidator A function who take a FlowTypeNode as argument and return true
   *    if it is the type we want to manipulate.
   * @param identifierToAssignmentExpression A function who take an idnentifier as argument and
   *    create an manipulation assignment expression.
   */

  function ManipulationAssignmentExpressionCreator(typeNodeValidator, identifierToAssignmentExpression) {
    _classCallCheck(this, ManipulationAssignmentExpressionCreator);

    this._typeNodeValidator = typeNodeValidator;
    this._identifierToAssignmentExpression = identifierToAssignmentExpression;
  }

  /**
   * Create the manipulation assignment expression for the identifier if the flowTypeNode or the
   * flowTypeNode's nested node matches the typeNodeValidator. If nothing matches, just return
   * null.
   */

  _createClass(ManipulationAssignmentExpressionCreator, [{
    key: 'create',
    value: function create(flowTypeNode, identifier) {
      return this._visit(flowTypeNode, identifier);
    }
  }, {
    key: '_visit',
    value: function _visit(flowTypeNode, identifier) {
      if (this._typeNodeValidator(flowTypeNode)) {
        return this._identifierToAssignmentExpression(identifier);
      }

      if (flowTypeNode.type === 'GenericTypeAnnotation') {
        return this._visitGenericTypeAnnotationNode(flowTypeNode, identifier);
      } else if (flowTypeNode.type === 'ObjectTypeAnnotation') {
        return this._visitObjectTypeAnnotationNode(flowTypeNode, identifier);
      } else if (flowTypeNode.type === 'NullableTypeAnnotation') {
        return this._visitNullableTypeAnnotationNode(flowTypeNode, identifier);
      } else {
        return null;
      }
    }
  }, {
    key: '_visitGenericTypeAnnotationNode',
    value: function _visitGenericTypeAnnotationNode(flowTypeNode, identifier) {
      if (flowTypeNode.id && flowTypeNode.id.type === 'Identifier' && flowTypeNode.id.name === 'Array') {
        return this._visitArrayTypeAnnotationNode(flowTypeNode, identifier);
      } else {
        return null;
      }
    }

    /**
     * Visit the node typed as `Array<$nestedFlowType>` and create the manipulation
     * expression if nestedFlowType should be manipulate.
     *
     * For example, if the nestedFlowType should be manipuated,  the generated expression will be
     * in following form:
     * ```
     * identifier = identifier.map(arg0 => {
     *   arg0 = manipulation(arg0);
     *   return arg0;
     * });
     * ```
     */
  }, {
    key: '_visitArrayTypeAnnotationNode',
    value: function _visitArrayTypeAnnotationNode(flowTypeNode, identifier) {
      // Skip if there is either no nested flow type or more than one.
      if (!flowTypeNode.typeParameters || flowTypeNode.typeParameters.params.length !== 1) {
        return null;
      }

      var nestedFlowType = flowTypeNode.typeParameters.params[0];
      var arrowFunctionParam = t.identifier('item');
      var assignmentExpression = this._visit(nestedFlowType, arrowFunctionParam);

      if (!assignmentExpression) {
        return null;
      }

      var arrowFunction = t.arrowFunctionExpression(
      /* params */[arrowFunctionParam],
      /* body */t.blockStatement([assignmentExpression, t.returnStatement(arrowFunctionParam)]));

      var callArrayMapExpression = t.callExpression(
      /* callee */t.memberExpression(identifier, t.identifier('map')),
      /* arguments */[arrowFunction]);

      return t.expressionStatement(t.assignmentExpression(
      /* operator */'=',
      /* left */identifier,
      /* right */callArrayMapExpression));
    }

    /**
     * Visit the node typed as `{property0: flowType0, property1: flowtype1... }` and create the
     * manipulation expression if any of its properties should be manipulated.
     *
     * For example, if `identifier.property0` should be manipuated,  the generated expression will be
     * in following form:
     * ```
     * identifier = ((obj) => {
     *  obj = require('nuclide-commons').object.assign({}, obj);
     *  obj.property0 = manipulation(obj.property0);
     * }) (identifier);
     *
     * ```
     */
  }, {
    key: '_visitObjectTypeAnnotationNode',
    value: function _visitObjectTypeAnnotationNode(flowTypeNode, identifier) {
      var _this = this;

      var objectIdentifier = t.identifier('obj');
      var assignmentExpressions = [];

      flowTypeNode.properties.forEach(function (property) {
        var key = property.key;
        if (key.type !== 'Identifier') {
          return;
        }

        var propertyExpression = t.memberExpression(objectIdentifier, t.identifier(key.name));
        var assignmentExpression = _this._visit(property.value, propertyExpression);

        if (assignmentExpression) {
          assignmentExpressions.push(assignmentExpression);
        }
      });

      // Skip if the the properties don't need to be manipuated.
      if (assignmentExpressions.length === 0) {
        return null;
      }

      // Create expression of `obj = require('nuclide-commons').object.assign({}, obj);`.
      var shallowCopyExpression = t.expressionStatement(t.assignmentExpression(
      /* operator */'=',
      /* left */objectIdentifier,
      /* right */t.callExpression(
      /* callee */t.memberExpression(t.memberExpression(t.callExpression(
      /* callee */t.identifier('require'),
      /* arguments */[t.literal('nuclide-commons')]), t.identifier('object')), t.identifier('assign')),
      /* arguments */[t.objectExpression([]), objectIdentifier])));

      var arrowFunction = t.arrowFunctionExpression(
      /* params */[objectIdentifier],
      /* body */t.blockStatement([shallowCopyExpression].concat(assignmentExpressions, t.returnStatement(objectIdentifier))));

      var callArrowFunctionExpression = t.callExpression(
      /* callee */arrowFunction,
      /* arguments */[identifier]);

      return t.expressionStatement(t.assignmentExpression(
      /* operator */'=',
      /* left */identifier,
      /* right */callArrowFunctionExpression));
    }

    /**
     * Visit the node typed as `?$nestedFlowType` (nullable) and create the if statement
     * manipulation expression if the nested flow type should be manipulated.
     *
     * For example, if `identifier: ?$nestedFlowType` should be manipuated, the generated expression
     * will be in the following form:
     * ```
     * if (identifier !== null) {
     *   identifier = manipulation(identifier);
     * }
     * ```
     */
  }, {
    key: '_visitNullableTypeAnnotationNode',
    value: function _visitNullableTypeAnnotationNode(flowTypeNode, identifier) {
      if (!flowTypeNode.typeAnnotation) {
        return null;
      }

      var assignmentExpression = this._visit(flowTypeNode.typeAnnotation, identifier);

      if (!assignmentExpression) {
        return null;
      }

      return t.ifStatement(
      /* test */t.binaryExpression('!==', identifier, t.literal(null)),
      /* consequent */t.blockStatement([assignmentExpression]));
    }
  }]);

  return ManipulationAssignmentExpressionCreator;
})();

module.exports = {
  ManipulationAssignmentExpressionCreator: ManipulationAssignmentExpressionCreator,

  createGetPathOfUriAssignmentExpression: function createGetPathOfUriAssignmentExpression(flowTypeNode, identifier) {
    var creator = new ManipulationAssignmentExpressionCreator(isNuclideUriFlowTypeAnnotation, _createGetPathOfUriAssignmentExpression);
    return creator.create(flowTypeNode, identifier);
  },

  createGetUriOfRemotePathAssignmentExpression: function createGetUriOfRemotePathAssignmentExpression(flowTypeNode, identifier) {
    var creator = new ManipulationAssignmentExpressionCreator(isNuclideUriFlowTypeAnnotation, _createGetUriOfRemotePathAssignmentExpression);
    return creator.create(flowTypeNode, identifier);
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXIvbGliL251Y2xpZGUtdXJpLXRyYW5zZm9ybWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7ZUFXNkIsT0FBTyxDQUFDLG1CQUFtQixDQUFDOztJQUE5RCw4QkFBOEIsWUFBOUIsOEJBQThCOztBQUNyQyxJQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDOzs7Ozs7QUFVdEMsU0FBUyx1Q0FBc0MsQ0FBQyxVQUFzQixFQUF3QjtBQUM1RixNQUFNLGNBQWMsR0FBRyxDQUFDLENBQUMsY0FBYztjQUN4QixDQUFDLENBQUMsZ0JBQWdCLENBQzdCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FDaEIsQ0FBQyxDQUFDLGNBQWMsRUFBRSxFQUNsQixDQUFDLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUM1QixFQUNELENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQzdCO2lCQUNlLENBQUMsVUFBVSxDQUFDLENBQzdCLENBQUM7O0FBRUYsU0FBTyxDQUFDLENBQUMsbUJBQW1CLENBQzFCLENBQUMsQ0FBQyxvQkFBb0I7Z0JBQ0wsR0FBRztZQUNQLFVBQVU7YUFDVCxjQUFjLENBQzNCLENBQ0YsQ0FBQztDQUNIOzs7Ozs7QUFNRCxTQUFTLDZDQUE0QyxDQUNuRCxVQUFzQixFQUNBO0FBQ3RCLE1BQU0sY0FBYyxHQUFHLENBQUMsQ0FBQyxjQUFjO2NBQ3hCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FDN0IsQ0FBQyxDQUFDLGdCQUFnQixDQUNoQixDQUFDLENBQUMsY0FBYyxFQUFFLEVBQ2xCLENBQUMsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQzVCLEVBQ0QsQ0FBQyxDQUFDLFVB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QztPQUNiOztBQUVELFVBQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxDQUFDOztBQUVsRixVQUFJLENBQUMsb0JBQW9CLEVBQUU7QUFDekIsZUFBTyxJQUFJLENBQUM7T0FDYjs7QUFFRCxhQUFPLENBQUMsQ0FBQyxXQUFXO2dCQUNQLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7c0JBQ2hELENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQzFELENBQUM7S0FDSDs7O1NBdk9HLHVDQUF1Qzs7O0FBME83QyxNQUFNLENBQUMsT0FBTyxHQUFHO0FBQ2YseUNBQXVDLEVBQXZDLHVDQUF1Qzs7QUFFdkMsd0NBQXNDLEVBQUEsZ0RBQ3BDLFlBQTBCLEVBQzFCLFVBQXNCLEVBQ0M7QUFDdkIsUUFBTSxPQUFPLEdBQUcsSUFBSSx1Q0FBdUMsQ0FDdkQsOEJBQThCLEVBQzlCLHVDQUFzQyxDQUFDLENBQUM7QUFDNUMsV0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQztHQUNqRDs7QUFFRCw4Q0FBNEMsRUFBQSxzREFDMUMsWUFBMEIsRUFDMUIsVUFBc0IsRUFDQztBQUN2QixRQUFNLE9BQU8sR0FBRyxJQUFJLHVDQUF1QyxDQUN6RCw4QkFBOEIsRUFDOUIsNkNBQTRDLENBQzdDLENBQUM7QUFDRixXQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0dBQ2pEO0NBQ0YsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1zZXJ2aWNlLXRyYW5zZm9ybWVyL2xpYi9udWNsaWRlLXVyaS10cmFuc2Zvcm1lci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IHtpc051Y2xpZGVVcmlGbG93VHlwZUFubm90YXRpb259ID0gcmVxdWlyZSgnLi9mbG93LWFubm90YXRpb24nKTtcbmNvbnN0IHQgPSByZXF1aXJlKCdiYWJlbC1jb3JlJykudHlwZXM7XG5cbnR5cGUgSWRlbnRpZmllciA9IGFueTtcbnR5cGUgQXNzaWdubWVudEV4cHJlc3Npb24gPSBhbnk7XG50eXBlIEZsb3dUeXBlTm9kZSA9IGFueTtcblxuLyoqXG4gKiBHaXZlbiB0aGUgaWRlbnRpZmllciwgY3JlYXRlIGZvbGxvd2luZyBhc3NpZ25tZW50IGV4cHJlc3Npb246XG4gKiBgJGlkZW50aWZpZXIgID0gdGhpcy5fY29ubmVjdGlvbi5nZXRQYXRoT2ZVcmkoJGlkZW50aWZpZXIpO2BcbiAqL1xuZnVuY3Rpb24gY3JlYXRlR2V0UGF0aE9mVXJpQXNzaWdubWVudEV4cHJlc3Npb24oaWRlbnRpZmllcjogSWRlbnRpZmllcik6IEFzc2lnbm1lbnRFeHByZXNzaW9uIHtcbiAgY29uc3QgY2FsbEV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKFxuICAgIC8qIGNhbGxlZSAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgdC5pZGVudGlmaWVyKCdfY29ubmVjdGlvbicpXG4gICAgICApLFxuICAgICAgdC5pZGVudGlmaWVyKCdnZXRQYXRoT2ZVcmknKVxuICAgICksXG4gICAgLyogYXJndW1lbnRzICovIFtpZGVudGlmaWVyXSxcbiAgKTtcblxuICByZXR1cm4gdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAvKiBvcGVyYXRvciAqLyAnPScsXG4gICAgICAvKiBsZWZ0ICovIGlkZW50aWZpZXIsXG4gICAgICAvKiByaWdodCAqLyBjYWxsRXhwcmVzc2lvbixcbiAgICApXG4gICk7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGlkZW50aWZpZXIsIGNyZWF0ZSBmb2xsb3dpbmcgYXNzaWdubWVudCBleHByZXNzaW9uOlxuICogYCRpZGVudGlmaWVyICA9IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0VXJpT2ZSZW1vdGVQYXRoKCRpZGVudGlmaWVyKTtgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdldFVyaU9mUmVtb3RlUGF0aEFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICBpZGVudGlmaWVyOiBJZGVudGlmaWVyLFxuKTogQXNzaWdubWVudEV4cHJlc3Npb24ge1xuICBjb25zdCBjYWxsRXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oXG4gICAgLyogY2FsbGVlICovIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICB0LmlkZW50aWZpZXIoJ19jb25uZWN0aW9uJylcbiAgICAgICksXG4gICAgICB0LmlkZW50aWZpZXIoJ2dldFVyaU9mUmVtb3RlUGF0aCcpXG4gICAgKSxcbiAgICAvKiBhcmd1bWVudHMgKi8gW2lkZW50aWZpZXJdLFxuICApO1xuXG4gIHJldHVybiB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgIC8qIG9wZXJhdG9yICovICc9JyxcbiAgICAgIC8qIGxlZnQgKi8gaWRlbnRpZmllcixcbiAgICAgIC8qIHJpZ2h0ICovIGNhbGxFeHByZXNzaW9uLFxuICAgIClcbiAgKTtcbn1cblxuLyoqXG4gKiBJdCBjcmVhdGVzIGEgbWFuaXB1bGF0aW9uIGFzc2lnbWVudCBleHByZXNzaW9uIGZvciBhbiBpZGVudGlmaWVyIG5vZGUsIGJ5IGNvbXBhcmluZyBpdCdzIGZsb3dcbiAqIHR5cGUgd2l0aCB0eXBlTm9kZVZhbGlkYXRvci5cbiAqXG4gKiBUaGUga2V5IGZlYXR1cmUgaXMgdGhhdCBpZiB0aGUgbm9kZSBpcyBhbiBPYmplY3Qgb3IgYW4gQXJyYXksIGFuZCB0aGUgb2JqZWN0J3MgcHJvcGVydHkgb3JcbiAqIHRoZSBhcnJheSdzIGl0ZW0gbWF0Y2hlcyBnaXZlbiBmbG93IHR5cGUgYWNjb3JkaW5nIHRvIG5vZGUncyBmbG93IHR5cGUgZGVmaW5pdGlvbiwgdGhlXG4gKiBjcmVhdG9yIGNvdWxkIGhhbmRsZSBpdCBhbmQgY3JlYXRlIGNvcnJlY3QgYXNzaWdubWVudCBleHByZXNzaW9uLiBBcyBsb25nIGFzIHRoZSBmbG93IHR5cGUgb2ZcbiAqIHRoZSBub2RlIGlzIGEgdmFsaWQganNvbiBvYmplY3QsIHRoaXMgY3JlYXRvciBjb3VsZCBjcmVhdGUgdGhlIGV4cGVjdGVkIGFzc2lnbm1lbnRcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogRm9yIGV4YW1wbGUsIHNheSB3ZSBhcmUgaW50ZXJzdGVkIGluIGZsb3cgdHlwZSBgZm9vVHlwZWAgYW5kIHdlIHdhbnQgdG8gbWFuaXB1bGF0ZSB0aGVcbiAqIG9iamVjdCB3aXRoIGBmb29UeXBlYCBieSBgb2JqZWN0ID0gYmFyKG9iamVjdClgLiBGb2xsb3dpbmcgdGhlIGV4cGVjdGVkIHJlc3VsdCBvZiBjcmVhdGVkXG4gKiBhc3NpZ25tZW50RXhwcmVzc2lvbjpcbiAqXG4gKiBgb2JqZWN0OiBmb29UeXBlYCA9PiBgb2JqZWN0ID0gYmFyKG9iamVjdClgLlxuICpcbiAqIGBvYmplY3Q6IHthOiBmb29UeXBlLCBiOiBudW1iZXJ9YCA9PiBgb2JqZWN0LmEgPSBiYXIob2JqZWN0LmEpYC5cbiAqXG4gKiBgb2JqZWN0OiBBcnJheTxmb29UeXBlPmAgPT4gJ29iamVjdCA9IG9iamVjdC5tYXAoKGFyZykgPT4ge3JldHVybiBiYXIoYXJnKX0pYC5cbiAqXG4gKi9cbmNsYXNzIE1hbmlwdWxhdGlvbkFzc2lnbm1lbnRFeHByZXNzaW9uQ3JlYXRvciB7XG5cbiAgX3R5cGVOb2RlVmFsaWRhdG9yOiAodHlwZU5vZGU6IEZsb3dUeXBlTm9kZSkgPT4gYm9vbGVhbjtcbiAgX2lkZW50aWZpZXJUb0Fzc2lnbm1lbnRFeHByZXNzaW9uOiAoaWRlbnRpZmllcjogSWRlbnRpZmllcikgPT4gQXNzaWdubWVudEV4cHJlc3Npb247XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGNyZWF0b3IuXG4gICAqIEBwYXJhbSB0eXBlTm9kZVZhbGlkYXRvciBBIGZ1bmN0aW9uIHdobyB0YWtlIGEgRmxvd1R5cGVOb2RlIGFzIGFyZ3VtZW50IGFuZCByZXR1cm4gdHJ1ZVxuICAgKiAgICBpZiBpdCBpcyB0aGUgdHlwZSB3ZSB3YW50IHRvIG1hbmlwdWxhdGUuXG4gICAqIEBwYXJhbSBpZGVudGlmaWVyVG9Bc3NpZ25tZW50RXhwcmVzc2lvbiBBIGZ1bmN0aW9uIHdobyB0YWtlIGFuIGlkbmVudGlmaWVyIGFzIGFyZ3VtZW50IGFuZFxuICAgKiAgICBjcmVhdGUgYW4gbWFuaXB1bGF0aW9uIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGVOb2RlVmFsaWRhdG9yOiAodHlwZU5vZGU6IEZsb3dUeXBlTm9kZSkgPT4gYm9vbGVhbixcbiAgICBpZGVudGlmaWVyVG9Bc3NpZ25tZW50RXhwcmVzc2lvbjogKGlkZW50aWZpZXI6IElkZW50aWZpZXIpID0+IEFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICApIHtcbiAgICB0aGlzLl90eXBlTm9kZVZhbGlkYXRvciA9IHR5cGVOb2RlVmFsaWRhdG9yO1xuICAgIHRoaXMuX2lkZW50aWZpZXJUb0Fzc2lnbm1lbnRFeHByZXNzaW9uID0gaWRlbnRpZmllclRvQXNzaWdubWVudEV4cHJlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBtYW5pcHVsYXRpb24gYXNzaWdubWVudCBleHByZXNzaW9uIGZvciB0aGUgaWRlbnRpZmllciBpZiB0aGUgZmxvd1R5cGVOb2RlIG9yIHRoZVxuICAgKiBmbG93VHlwZU5vZGUncyBuZXN0ZWQgbm9kZSBtYXRjaGVzIHRoZSB0eXBlTm9kZVZhbGlkYXRvci4gSWYgbm90aGluZyBtYXRjaGVzLCBqdXN0IHJldHVyblxuICAgKiBudWxsLlxuICAgKi9cbiAgY3JlYXRlKGZsb3dUeXBlTm9kZTogRmxvd1R5cGVOb2RlLCBpZGVudGlmaWVyOiBJZGVudGlmaWVyKTogP0Fzc2lnbm1lbnRFeHByZXNzaW9uIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaXQoZmxvd1R5cGVOb2RlLCBpZGVudGlmaWVyKTtcbiAgfVxuXG4gIF92aXNpdChmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcjogSWRlbnRpZmllcik6ID9Bc3NpZ25tZW50RXhwcmVzc2lvbiB7XG4gICAgaWYgKHRoaXMuX3R5cGVOb2RlVmFsaWRhdG9yKGZsb3dUeXBlTm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pZGVudGlmaWVyVG9Bc3NpZ25tZW50RXhwcmVzc2lvbihpZGVudGlmaWVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmxvd1R5cGVOb2RlLnR5cGUgPT09ICdHZW5lcmljVHlwZUFubm90YXRpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlzaXRHZW5lcmljVHlwZUFubm90YXRpb25Ob2RlKGZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChmbG93VHlwZU5vZGUudHlwZSA9PT0gJ09iamVjdFR5cGVBbm5vdGF0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0T2JqZWN0VHlwZUFubm90YXRpb25Ob2RlKGZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChmbG93VHlwZU5vZGUudHlwZSA9PT0gJ051bGxhYmxlVHlwZUFubm90YXRpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlzaXROdWxsYWJsZVR5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGUsIGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfdmlzaXRHZW5lcmljVHlwZUFubm90YXRpb25Ob2RlKFxuICAgIGZsb3dUeXBlTm9kZTogRmxvd1R5cGVOb2RlLFxuICAgIGlkZW50aWZpZXI6IElkZW50aWZpZXIsXG4gICk6ID9Bc3NpZ25tZW50RXhwcmVzc2lvbiB7XG4gICAgaWYgKGZsb3dUeXBlTm9kZS5pZCAmJlxuICAgICAgICBmbG93VHlwZU5vZGUuaWQudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICAgIGZsb3dUeXBlTm9kZS5pZC5uYW1lID09PSAnQXJyYXknKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlzaXRBcnJheVR5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGUsIGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmlzaXQgdGhlIG5vZGUgdHlwZWQgYXMgYEFycmF5PCRuZXN0ZWRGbG93VHlwZT5gIGFuZCBjcmVhdGUgdGhlIG1hbmlwdWxhdGlvblxuICAgKiBleHByZXNzaW9uIGlmIG5lc3RlZEZsb3dUeXBlIHNob3VsZCBiZSBtYW5pcHVsYXRlLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG5lc3RlZEZsb3dUeXBlIHNob3VsZCBiZSBtYW5pcHVhdGVkLCAgdGhlIGdlbmVyYXRlZCBleHByZXNzaW9uIHdpbGwgYmVcbiAgICogaW4gZm9sbG93aW5nIGZvcm06XG4gICAqIGBgYFxuICAgKiBpZGVudGlmaWVyID0gaWRlbnRpZmllci5tYXAoYXJnMCA9PiB7XG4gICAqICAgYXJnMCA9IG1hbmlwdWxhdGlvbihhcmcwKTtcbiAgICogICByZXR1cm4gYXJnMDtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgX3Zpc2l0QXJyYXlUeXBlQW5ub3RhdGlvbk5vZGUoXG4gICAgZmxvd1R5cGVOb2RlOiBGbG93VHlwZU5vZGUsXG4gICAgaWRlbnRpZmllcjogSWRlbnRpZmllcixcbiAgKTogP0Fzc2lnbm1lbnRFeHByZXNzaW9uIHtcbiAgICAvLyBTa2lwIGlmIHRoZXJlIGlzIGVpdGhlciBubyBuZXN0ZWQgZmxvdyB0eXBlIG9yIG1vcmUgdGhhbiBvbmUuXG4gICAgaWYgKCFmbG93VHlwZU5vZGUudHlwZVBhcmFtZXRlcnMgfHxcbiAgICAgICAgZmxvd1R5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5lc3RlZEZsb3dUeXBlID0gZmxvd1R5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzLnBhcmFtc1swXTtcbiAgICBjb25zdCBhcnJvd0Z1bmN0aW9uUGFyYW0gPSB0LmlkZW50aWZpZXIoJ2l0ZW0nKTtcbiAgICBjb25zdCBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IHRoaXMuX3Zpc2l0KG5lc3RlZEZsb3dUeXBlLCBhcnJvd0Z1bmN0aW9uUGFyYW0pO1xuXG4gICAgaWYgKCFhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYXJyb3dGdW5jdGlvbiA9IHQuYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgICAvKiBwYXJhbXMgKi8gW2Fycm93RnVuY3Rpb25QYXJhbV0sXG4gICAgICAvKiBib2R5ICovIHQuYmxvY2tTdGF0ZW1lbnQoXG4gICAgICAgIFtcbiAgICAgICAgICBhc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgICAgICB0LnJldHVyblN0YXRlbWVudChhcnJvd0Z1bmN0aW9uUGFyYW0pLFxuICAgICAgICBdXG4gICAgICApXG4gICAgKTtcblxuICAgIGNvbnN0IGNhbGxBcnJheU1hcEV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgLyogY2FsbGVlICovIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgdC5pZGVudGlmaWVyKCdtYXAnKSxcbiAgICAgICksXG4gICAgICAvKiBhcmd1bWVudHMgKi8gW2Fycm93RnVuY3Rpb25dLFxuICAgICk7XG5cbiAgICByZXR1cm4gdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgLyogb3BlcmF0b3IgKi8gJz0nLFxuICAgICAgICAvKiBsZWZ0ICovIGlkZW50aWZpZXIsXG4gICAgICAgIC8qIHJpZ2h0ICovIGNhbGxBcnJheU1hcEV4cHJlc3Npb24sXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWaXNpdCB0aGUgbm9kZSB0eXBlZCBhcyBge3Byb3BlcnR5MDogZmxvd1R5cGUwLCBwcm9wZXJ0eTE6IGZsb3d0eXBlMS4uLiB9YCBhbmQgY3JlYXRlIHRoZVxuICAgKiBtYW5pcHVsYXRpb24gZXhwcmVzc2lvbiBpZiBhbnkgb2YgaXRzIHByb3BlcnRpZXMgc2hvdWxkIGJlIG1hbmlwdWxhdGVkLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgYGlkZW50aWZpZXIucHJvcGVydHkwYCBzaG91bGQgYmUgbWFuaXB1YXRlZCwgIHRoZSBnZW5lcmF0ZWQgZXhwcmVzc2lvbiB3aWxsIGJlXG4gICAqIGluIGZvbGxvd2luZyBmb3JtOlxuICAgKiBgYGBcbiAgICogaWRlbnRpZmllciA9ICgob2JqKSA9PiB7XG4gICAqICBvYmogPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKS5vYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgKiAgb2JqLnByb3BlcnR5MCA9IG1hbmlwdWxhdGlvbihvYmoucHJvcGVydHkwKTtcbiAgICogfSkgKGlkZW50aWZpZXIpO1xuICAgKlxuICAgKiBgYGBcbiAgICovXG4gIF92aXNpdE9iamVjdFR5cGVBbm5vdGF0aW9uTm9kZShcbiAgICBmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSxcbiAgICBpZGVudGlmaWVyOiBJZGVudGlmaWVyLFxuICApOiA/QXNzaWdubWVudEV4cHJlc3Npb24ge1xuICAgIGNvbnN0IG9iamVjdElkZW50aWZpZXIgPSB0LmlkZW50aWZpZXIoJ29iaicpO1xuICAgIGNvbnN0IGFzc2lnbm1lbnRFeHByZXNzaW9ucyA9IFtdO1xuXG4gICAgZmxvd1R5cGVOb2RlLnByb3BlcnRpZXMuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBwcm9wZXJ0eS5rZXk7XG4gICAgICBpZiAoa2V5LnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnR5RXhwcmVzc2lvbiA9IHQubWVtYmVyRXhwcmVzc2lvbihvYmplY3RJZGVudGlmaWVyLCB0LmlkZW50aWZpZXIoa2V5Lm5hbWUpKTtcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnRFeHByZXNzaW9uID0gdGhpcy5fdmlzaXQocHJvcGVydHkudmFsdWUsIHByb3BlcnR5RXhwcmVzc2lvbik7XG5cbiAgICAgIGlmIChhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgICBhc3NpZ25tZW50RXhwcmVzc2lvbnMucHVzaChhc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTa2lwIGlmIHRoZSB0aGUgcHJvcGVydGllcyBkb24ndCBuZWVkIHRvIGJlIG1hbmlwdWF0ZWQuXG4gICAgaWYgKGFzc2lnbm1lbnRFeHByZXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBleHByZXNzaW9uIG9mIGBvYmogPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKS5vYmplY3QuYXNzaWduKHt9LCBvYmopO2AuXG4gICAgY29uc3Qgc2hhbGxvd0NvcHlFeHByZXNzaW9uID0gdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgLyogb3BlcmF0b3IgKi8gJz0nLFxuICAgICAgICAvKiBsZWZ0ICovIG9iamVjdElkZW50aWZpZXIsXG4gICAgICAgIC8qIHJpZ2h0ICovIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgLyogY2FsbGVlICovIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgICAvKiBjYWxsZWUgKi8gdC5pZGVudGlmaWVyKCdyZXF1aXJlJyksXG4gICAgICAgICAgICAgICAgLyogYXJndW1lbnRzICovIFt0LmxpdGVyYWwoJ251Y2xpZGUtY29tbW9ucycpXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB0LmlkZW50aWZpZXIoJ29iamVjdCcpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKCdhc3NpZ24nKVxuICAgICAgICAgICksXG4gICAgICAgICAgLyogYXJndW1lbnRzICovIFtcbiAgICAgICAgICAgIHQub2JqZWN0RXhwcmVzc2lvbihbXSksXG4gICAgICAgICAgICBvYmplY3RJZGVudGlmaWVyLFxuICAgICAgICAgIF0sXG4gICAgICAgICksXG4gICAgICApXG4gICAgKTtcblxuICAgIGNvbnN0IGFycm93RnVuY3Rpb24gPSB0LmFycm93RnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgLyogcGFyYW1zICovIFtvYmplY3RJZGVudGlmaWVyXSxcbiAgICAgIC8qIGJvZHkgKi8gdC5ibG9ja1N0YXRlbWVudChcbiAgICAgICAgW3NoYWxsb3dDb3B5RXhwcmVzc2lvbl0uY29uY2F0KFxuICAgICAgICAgIGFzc2lnbm1lbnRFeHByZXNzaW9ucyxcbiAgICAgICAgICB0LnJldHVyblN0YXRlbWVudChvYmplY3RJZGVudGlmaWVyKSxcbiAgICAgICAgKSxcbiAgICAgIClcbiAgICApO1xuXG4gICAgY29uc3QgY2FsbEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIC8qIGNhbGxlZSAqLyBhcnJvd0Z1bmN0aW9uLFxuICAgICAgLyogYXJndW1lbnRzICovIFtpZGVudGlmaWVyXSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAgIC8qIG9wZXJhdG9yICovICc9JyxcbiAgICAgICAgLyogbGVmdCAqLyBpZGVudGlmaWVyLFxuICAgICAgICAvKiByaWdodCAqLyBjYWxsQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWaXNpdCB0aGUgbm9kZSB0eXBlZCBhcyBgPyRuZXN0ZWRGbG93VHlwZWAgKG51bGxhYmxlKSBhbmQgY3JlYXRlIHRoZSBpZiBzdGF0ZW1lbnRcbiAgICogbWFuaXB1bGF0aW9uIGV4cHJlc3Npb24gaWYgdGhlIG5lc3RlZCBmbG93IHR5cGUgc2hvdWxkIGJlIG1hbmlwdWxhdGVkLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgYGlkZW50aWZpZXI6ID8kbmVzdGVkRmxvd1R5cGVgIHNob3VsZCBiZSBtYW5pcHVhdGVkLCB0aGUgZ2VuZXJhdGVkIGV4cHJlc3Npb25cbiAgICogd2lsbCBiZSBpbiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAqIGBgYFxuICAgKiBpZiAoaWRlbnRpZmllciAhPT0gbnVsbCkge1xuICAgKiAgIGlkZW50aWZpZXIgPSBtYW5pcHVsYXRpb24oaWRlbnRpZmllcik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBfdmlzaXROdWxsYWJsZVR5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcjogSWRlbnRpZmllcik6ID9hbnkge1xuICAgIGlmICghZmxvd1R5cGVOb2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IHRoaXMuX3Zpc2l0KGZsb3dUeXBlTm9kZS50eXBlQW5ub3RhdGlvbiwgaWRlbnRpZmllcik7XG5cbiAgICBpZiAoIWFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5pZlN0YXRlbWVudChcbiAgICAgIC8qIHRlc3QgKi8gdC5iaW5hcnlFeHByZXNzaW9uKCchPT0nLCBpZGVudGlmaWVyLCB0LmxpdGVyYWwobnVsbCkpLFxuICAgICAgLyogY29uc2VxdWVudCAqLyB0LmJsb2NrU3RhdGVtZW50KFthc3NpZ25tZW50RXhwcmVzc2lvbl0pLFxuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1hbmlwdWxhdGlvbkFzc2lnbm1lbnRFeHByZXNzaW9uQ3JlYXRvcixcblxuICBjcmVhdGVHZXRQYXRoT2ZVcmlBc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICBmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSxcbiAgICBpZGVudGlmaWVyOiBJZGVudGlmaWVyXG4gICk6ID9Bc3NpZ25tZW50RXhwcmVzc2lvbiB7XG4gICAgY29uc3QgY3JlYXRvciA9IG5ldyBNYW5pcHVsYXRpb25Bc3NpZ25tZW50RXhwcmVzc2lvbkNyZWF0b3IoXG4gICAgICAgIGlzTnVjbGlkZVVyaUZsb3dUeXBlQW5ub3RhdGlvbixcbiAgICAgICAgY3JlYXRlR2V0UGF0aE9mVXJpQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgIHJldHVybiBjcmVhdG9yLmNyZWF0ZShmbG93VHlwZU5vZGUsIGlkZW50aWZpZXIpO1xuICB9LFxuXG4gIGNyZWF0ZUdldFVyaU9mUmVtb3RlUGF0aEFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgIGZsb3dUeXBlTm9kZTogRmxvd1R5cGVOb2RlLFxuICAgIGlkZW50aWZpZXI6IElkZW50aWZpZXJcbiAgKTogP0Fzc2lnbm1lbnRFeHByZXNzaW9uIHtcbiAgICBjb25zdCBjcmVhdG9yID0gbmV3IE1hbmlwdWxhdGlvbkFzc2lnbm1lbnRFeHByZXNzaW9uQ3JlYXRvcihcbiAgICAgIGlzTnVjbGlkZVVyaUZsb3dUeXBlQW5ub3RhdGlvbixcbiAgICAgIGNyZWF0ZUdldFVyaU9mUmVtb3RlUGF0aEFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0b3IuY3JlYXRlKGZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcik7XG4gIH0sXG59O1xuIl19
