Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

exports['default'] = search;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

var _rx = require('rx');

var _nuclideCommons = require('nuclide-commons');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _split = require('split');

var _split2 = _interopRequireDefault(_split);

// This pattern is used for parsing the output of grep.
'use babel';
var GREP_PARSE_PATTERN = /(.*):(\d*):(.*)/;

/**
 * Searches for all instances of a pattern in a directory.
 * @param directory - The directory in which to perform a search.
 * @param regex - The pattern to match.
 * @param subdirs - An array of subdirectories to search within `directory`. If subdirs is an
    empty array, then simply search in directory.
 * @returns An observable that emits match events.
 */

function search(directory, regex, subdirs) {
  // Matches are stored in a Map of filename => Array<Match>.
  var matchesByFile = new Map();

  if (!subdirs || subdirs.length === 0) {
    // Since no subdirs were specified, run search on the root directory.
    return searchInSubdir(matchesByFile, directory, '.', regex);
  } else {
    // Run the search on each subdirectory that exists.
    return _rx.Observable.from(subdirs).concatMap(_asyncToGenerator(function* (subdir) {
      try {
        var stat = yield _nuclideCommons.fsPromise.lstat(_path2['default'].join(directory, subdir));
        if (stat.isDirectory()) {
          return searchInSubdir(matchesByFile, directory, subdir, regex);
        }
      } catch (e) {
        return _rx.Observable.empty();
      }
    })).mergeAll();
  }
}

// Helper function that runs the search command on the given directory
// `subdir`, relative to `directory`. The function returns an Observable that emits
// search$FileResult objects.
function searchInSubdir(matchesByFile, directory, subdir, regex) {
  // Try running search commands, falling through to the next if there is an error.
  var vcsargs = (regex.ignoreCase ? ['-i'] : []).concat(['-n', regex.source]);
  var grepargs = (regex.ignoreCase ? ['-i'] : []).concat(['-rHn', '-e', regex.source, '.']);
  var cmdDir = _path2['default'].join(directory, subdir);
  var linesSource = _rx.Observable['catch'](getLinesFromCommand('hg', ['wgrep'].concat(vcsargs), cmdDir), getLinesFromCommand('git', ['grep'].concat(vcsargs), cmdDir), getLinesFromCommand('grep', grepargs, cmdDir), _rx.Observable['throw'](new Error('Failed to execute a grep search.')));

  // Transform lines into file matches.
  return linesSource.map(function (line) {
    // Try to parse the output of grep.
    var grepMatchResult = line.match(GREP_PARSE_PATTERN);
    if (!grepMatchResult) {
      return;
    }

    // Extract the filename, line number, and line text from grep output.
    var lineText = grepMatchResult[3];
    var lineNo = parseInt(grepMatchResult[2], 10) - 1;
    var filePath = _path2['default'].join(subdir, grepMatchResult[1]);

    // Try to extract the actual "matched" text.
    var matchTextResult = regex.exec(lineText);
    if (!matchTextResult) {
      return;
    }
    var matchText = matchTextResult[0];
    var matchIndex = matchTextResult.index;

    // Put this match into lists grouped by files.
    if (!matchesByFile.has(filePath)) {
      matchesByFile.set(filePath, []);
    }
    matchesByFile.get(filePath).push({
      lineText: lineText,
      lineTextOffset: 0,
      matchText: matchText,
      range: [[lineNo, matchIndex], [lineNo, matchIndex + matchText.length]]
    });

    // If a callback was provided, invoke it with the newest update.
    return { matches: matchesByFile.get(filePath), filePath: filePath };
  }).filter(Boolean); // Filters out the falsey events.
}

// Helper function that runs a command in a given directory, invoking a callback
// as each line is written to stdout.
function getLinesFromCommand(command, args, localDirectoryPath) {
  return _rx.Observable.create(function (observer) {
    var proc = null;
    var exited = false;

    // Spawn the search command in the given directory.
    (0, _nuclideCommons.safeSpawn)(command, args, { cwd: localDirectoryPath }).then(function (child) {
      proc = child;

      // Reject on error.
      proc.on('error', observer.onError.bind(observer));

      // Call the callback on each line.
      proc.stdout.pipe((0, _split2['default'])()).on('data', observer.onNext.bind(observer));

      // Keep a running string of stderr, in case we need to throw an error.
      var stderr = '';
      proc.stderr.on('data', function (data) {
        stderr += data;
      });

      // Resolve promise if error code is 0 (found matches) or 1 (found no matches). Otherwise
      // reject. However, if a process was killed with a signal, don't reject, since this was likely
      // to cancel the search.
      proc.on('close', function (code, signal) {
        exited = true;
        if (signal || code <= 1) {
          observer.onCompleted();
        } else {
          observer.onError(new Error(stderr));
        }
      });
    })['catch'](function (error) {
      observer.onError(error);
    });

    // Kill the search process on dispose.
    return function () {
      if (!exited) {
        proc && proc.kill();
      }
    };
  });
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1zZWFyY2gvbGliL3NjYW5oYW5kbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztxQkFvQ3dCLE1BQU07Ozs7OztrQkFwQkwsSUFBSTs7OEJBS3RCLGlCQUFpQjs7b0JBQ1AsTUFBTTs7OztxQkFDTCxPQUFPOzs7OztBQXZCekIsV0FBVyxDQUFDO0FBMEJaLElBQU0sa0JBQWtCLEdBQUcsaUJBQWlCLENBQUM7Ozs7Ozs7Ozs7O0FBVTlCLFNBQVMsTUFBTSxDQUFDLFNBQWlCLEVBQUUsS0FBYSxFQUFFLE9BQXNCLEVBQ3JEOztBQUVoQyxNQUFNLGFBQStDLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7QUFFbEUsTUFBSSxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7QUFFcEMsV0FBTyxjQUFjLENBQUMsYUFBYSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDN0QsTUFBTTs7QUFFTCxXQUFPLElBOUJILFVBQVUsQ0E4QkksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsbUJBQUMsV0FBTSxNQUFNLEVBQUk7QUFDeEQsVUFBSTtBQUNGLFlBQU0sSUFBSSxHQUFHLE1BQU0sZ0JBN0J6QixTQUFTLENBNkIwQixLQUFLLENBQUMsa0JBQUssSUFBSSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ2pFLFlBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO0FBQ3RCLGlCQUFPLGNBQWMsQ0FBQyxhQUFhLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNoRTtPQUNGLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDVixlQUFPLElBckNQLFVBQVUsQ0Fx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TSxDQUFDLENBQUMsQ0FBQztTQUNyQztPQUNGLENBQUMsQ0FBQztLQUNKLENBQUMsU0FBTSxDQUFDLFVBQUEsS0FBSyxFQUFJO0FBQ2hCLGNBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDekIsQ0FBQyxDQUFDOzs7QUFHSCxXQUFPLFlBQU07QUFDWCxVQUFJLENBQUMsTUFBTSxFQUFFO0FBQ1gsWUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztPQUNyQjtLQUNGLENBQUM7R0FDSCxDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1yZW1vdGUtc2VhcmNoL2xpYi9zY2FuaGFuZGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgc2VhcmNoJEZpbGVSZXN1bHQsXG4gIHNlYXJjaCRNYXRjaCxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncngnO1xuXG5pbXBvcnQge1xuICBmc1Byb21pc2UsXG4gIHNhZmVTcGF3bixcbn0gZnJvbSAnbnVjbGlkZS1jb21tb25zJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHNwbGl0IGZyb20gJ3NwbGl0JztcblxuLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgZm9yIHBhcnNpbmcgdGhlIG91dHB1dCBvZiBncmVwLlxuY29uc3QgR1JFUF9QQVJTRV9QQVRURVJOID0gLyguKik6KFxcZCopOiguKikvO1xuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBhbGwgaW5zdGFuY2VzIG9mIGEgcGF0dGVybiBpbiBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBkaXJlY3RvcnkgLSBUaGUgZGlyZWN0b3J5IGluIHdoaWNoIHRvIHBlcmZvcm0gYSBzZWFyY2guXG4gKiBAcGFyYW0gcmVnZXggLSBUaGUgcGF0dGVybiB0byBtYXRjaC5cbiAqIEBwYXJhbSBzdWJkaXJzIC0gQW4gYXJyYXkgb2Ygc3ViZGlyZWN0b3JpZXMgdG8gc2VhcmNoIHdpdGhpbiBgZGlyZWN0b3J5YC4gSWYgc3ViZGlycyBpcyBhblxuICAgIGVtcHR5IGFycmF5LCB0aGVuIHNpbXBseSBzZWFyY2ggaW4gZGlyZWN0b3J5LlxuICogQHJldHVybnMgQW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG1hdGNoIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VhcmNoKGRpcmVjdG9yeTogc3RyaW5nLCByZWdleDogUmVnRXhwLCBzdWJkaXJzOiBBcnJheTxzdHJpbmc+KTpcbiAgICBPYnNlcnZhYmxlPHNlYXJjaCRGaWxlUmVzdWx0PiB7XG4gIC8vIE1hdGNoZXMgYXJlIHN0b3JlZCBpbiBhIE1hcCBvZiBmaWxlbmFtZSA9PiBBcnJheTxNYXRjaD4uXG4gIGNvbnN0IG1hdGNoZXNCeUZpbGU6IE1hcDxzdHJpbmcsIEFycmF5PHNlYXJjaCRNYXRjaD4+ID0gbmV3IE1hcCgpO1xuXG4gIGlmICghc3ViZGlycyB8fCBzdWJkaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFNpbmNlIG5vIHN1YmRpcnMgd2VyZSBzcGVjaWZpZWQsIHJ1biBzZWFyY2ggb24gdGhlIHJvb3QgZGlyZWN0b3J5LlxuICAgIHJldHVybiBzZWFyY2hJblN1YmRpcihtYXRjaGVzQnlGaWxlLCBkaXJlY3RvcnksICcuJywgcmVnZXgpO1xuICB9IGVsc2Uge1xuICAgIC8vIFJ1biB0aGUgc2VhcmNoIG9uIGVhY2ggc3ViZGlyZWN0b3J5IHRoYXQgZXhpc3RzLlxuICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb20oc3ViZGlycykuY29uY2F0TWFwKGFzeW5jIHN1YmRpciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgZnNQcm9taXNlLmxzdGF0KHBhdGguam9pbihkaXJlY3RvcnksIHN1YmRpcikpO1xuICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHNlYXJjaEluU3ViZGlyKG1hdGNoZXNCeUZpbGUsIGRpcmVjdG9yeSwgc3ViZGlyLCByZWdleCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZW1wdHkoKTtcbiAgICAgIH1cbiAgICB9KS5tZXJnZUFsbCgpO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJ1bnMgdGhlIHNlYXJjaCBjb21tYW5kIG9uIHRoZSBnaXZlbiBkaXJlY3Rvcnlcbi8vIGBzdWJkaXJgLCByZWxhdGl2ZSB0byBgZGlyZWN0b3J5YC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4vLyBzZWFyY2gkRmlsZVJlc3VsdCBvYmplY3RzLlxuZnVuY3Rpb24gc2VhcmNoSW5TdWJkaXIoXG4gIG1hdGNoZXNCeUZpbGU6IE1hcDxzdHJpbmcsIEFycmF5PHNlYXJjaCRNYXRjaD4+LFxuICBkaXJlY3Rvcnk6IHN0cmluZyxcbiAgc3ViZGlyOiBzdHJpbmcsXG4gIHJlZ2V4OiBSZWdFeHBcbik6IE9ic2VydmFibGU8c2VhcmNoJEZpbGVSZXN1bHQ+IHtcbiAgLy8gVHJ5IHJ1bm5pbmcgc2VhcmNoIGNvbW1hbmRzLCBmYWxsaW5nIHRocm91Z2ggdG8gdGhlIG5leHQgaWYgdGhlcmUgaXMgYW4gZXJyb3IuXG4gIGNvbnN0IHZjc2FyZ3MgPSAocmVnZXguaWdub3JlQ2FzZSA/IFsnLWknXSA6IFtdKS5jb25jYXQoWyctbicsIHJlZ2V4LnNvdXJjZV0pO1xuICBjb25zdCBncmVwYXJncyA9IChyZWdleC5pZ25vcmVDYXNlID8gWyctaSddIDogW10pLmNvbmNhdChbJy1ySG4nLCAnLWUnLCByZWdleC5zb3VyY2UsICcuJ10pO1xuICBjb25zdCBjbWREaXIgPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBzdWJkaXIpO1xuICBjb25zdCBsaW5lc1NvdXJjZSA9IE9ic2VydmFibGUuY2F0Y2goXG4gICAgZ2V0TGluZXNGcm9tQ29tbWFuZCgnaGcnLCBbJ3dncmVwJ10uY29uY2F0KHZjc2FyZ3MpLCBjbWREaXIpLFxuICAgIGdldExpbmVzRnJvbUNvbW1hbmQoJ2dpdCcsIFsnZ3JlcCddLmNvbmNhdCh2Y3NhcmdzKSwgY21kRGlyKSxcbiAgICBnZXRMaW5lc0Zyb21Db21tYW5kKCdncmVwJywgZ3JlcGFyZ3MsIGNtZERpciksXG4gICAgT2JzZXJ2YWJsZS50aHJvdyhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIGEgZ3JlcCBzZWFyY2guJykpXG4gICk7XG5cbiAgLy8gVHJhbnNmb3JtIGxpbmVzIGludG8gZmlsZSBtYXRjaGVzLlxuICByZXR1cm4gbGluZXNTb3VyY2UubWFwKGxpbmUgPT4ge1xuICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGdyZXAuXG4gICAgY29uc3QgZ3JlcE1hdGNoUmVzdWx0ID0gbGluZS5tYXRjaChHUkVQX1BBUlNFX1BBVFRFUk4pO1xuICAgIGlmICghZ3JlcE1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCB0aGUgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQgbGluZSB0ZXh0IGZyb20gZ3JlcCBvdXRwdXQuXG4gICAgY29uc3QgbGluZVRleHQgPSBncmVwTWF0Y2hSZXN1bHRbM107XG4gICAgY29uc3QgbGluZU5vID0gcGFyc2VJbnQoZ3JlcE1hdGNoUmVzdWx0WzJdLCAxMCkgLSAxO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHN1YmRpciwgZ3JlcE1hdGNoUmVzdWx0WzFdKTtcblxuICAgIC8vIFRyeSB0byBleHRyYWN0IHRoZSBhY3R1YWwgXCJtYXRjaGVkXCIgdGV4dC5cbiAgICBjb25zdCBtYXRjaFRleHRSZXN1bHQgPSByZWdleC5leGVjKGxpbmVUZXh0KTtcbiAgICBpZiAoIW1hdGNoVGV4dFJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaFRleHQgPSBtYXRjaFRleHRSZXN1bHRbMF07XG4gICAgY29uc3QgbWF0Y2hJbmRleCA9IG1hdGNoVGV4dFJlc3VsdC5pbmRleDtcblxuICAgIC8vIFB1dCB0aGlzIG1hdGNoIGludG8gbGlzdHMgZ3JvdXBlZCBieSBmaWxlcy5cbiAgICBpZiAoIW1hdGNoZXNCeUZpbGUuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgbWF0Y2hlc0J5RmlsZS5zZXQoZmlsZVBhdGgsIFtdKTtcbiAgICB9XG4gICAgbWF0Y2hlc0J5RmlsZS5nZXQoZmlsZVBhdGgpLnB1c2goe1xuICAgICAgbGluZVRleHQsXG4gICAgICBsaW5lVGV4dE9mZnNldDogMCxcbiAgICAgIG1hdGNoVGV4dCxcbiAgICAgIHJhbmdlOiBbW2xpbmVObywgbWF0Y2hJbmRleF0sIFtsaW5lTm8sIG1hdGNoSW5kZXggKyBtYXRjaFRleHQubGVuZ3RoXV0sXG4gICAgfSk7XG5cbiAgICAvLyBJZiBhIGNhbGxiYWNrIHdhcyBwcm92aWRlZCwgaW52b2tlIGl0IHdpdGggdGhlIG5ld2VzdCB1cGRhdGUuXG4gICAgcmV0dXJuIHttYXRjaGVzOiBtYXRjaGVzQnlGaWxlLmdldChmaWxlUGF0aCksIGZpbGVQYXRofTtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pOyAvLyBGaWx0ZXJzIG91dCB0aGUgZmFsc2V5IGV2ZW50cy5cbn1cblxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCBydW5zIGEgY29tbWFuZCBpbiBhIGdpdmVuIGRpcmVjdG9yeSwgaW52b2tpbmcgYSBjYWxsYmFja1xuLy8gYXMgZWFjaCBsaW5lIGlzIHdyaXR0ZW4gdG8gc3Rkb3V0LlxuZnVuY3Rpb24gZ2V0TGluZXNGcm9tQ29tbWFuZChjb21tYW5kOiBzdHJpbmcsIGFyZ3M6IEFycmF5PHN0cmluZz4sIGxvY2FsRGlyZWN0b3J5UGF0aDogc3RyaW5nKTpcbiAgICBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xuICAgIGxldCBwcm9jOiA/Y2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MgPSBudWxsO1xuICAgIGxldCBleGl0ZWQgPSBmYWxzZTtcblxuICAgIC8vIFNwYXduIHRoZSBzZWFyY2ggY29tbWFuZCBpbiB0aGUgZ2l2ZW4gZGlyZWN0b3J5LlxuICAgIHNhZmVTcGF3bihjb21tYW5kLCBhcmdzLCB7Y3dkOiBsb2NhbERpcmVjdG9yeVBhdGh9KS50aGVuKGNoaWxkID0+IHtcbiAgICAgIHByb2MgPSBjaGlsZDtcblxuICAgICAgLy8gUmVqZWN0IG9uIGVycm9yLlxuICAgICAgcHJvYy5vbignZXJyb3InLCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpKTtcblxuICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgb24gZWFjaCBsaW5lLlxuICAgICAgcHJvYy5zdGRvdXQucGlwZShzcGxpdCgpKS5vbignZGF0YScsIG9ic2VydmVyLm9uTmV4dC5iaW5kKG9ic2VydmVyKSk7XG5cbiAgICAgIC8vIEtlZXAgYSBydW5uaW5nIHN0cmluZyBvZiBzdGRlcnIsIGluIGNhc2Ugd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGxldCBzdGRlcnIgPSAnJztcbiAgICAgIHByb2Muc3RkZXJyLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlc29sdmUgcHJvbWlzZSBpZiBlcnJvciBjb2RlIGlzIDAgKGZvdW5kIG1hdGNoZXMpIG9yIDEgKGZvdW5kIG5vIG1hdGNoZXMpLiBPdGhlcndpc2VcbiAgICAgIC8vIHJlamVjdC4gSG93ZXZlciwgaWYgYSBwcm9jZXNzIHdhcyBraWxsZWQgd2l0aCBhIHNpZ25hbCwgZG9uJ3QgcmVqZWN0LCBzaW5jZSB0aGlzIHdhcyBsaWtlbHlcbiAgICAgIC8vIHRvIGNhbmNlbCB0aGUgc2VhcmNoLlxuICAgICAgcHJvYy5vbignY2xvc2UnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChzaWduYWwgfHwgY29kZSA8PSAxKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKG5ldyBFcnJvcihzdGRlcnIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICAvLyBLaWxsIHRoZSBzZWFyY2ggcHJvY2VzcyBvbiBkaXNwb3NlLlxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWV4aXRlZCkge1xuICAgICAgICBwcm9jICYmIHByb2Mua2lsbCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuIl19
