var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var isFlowInstalled = _asyncToGenerator(function* () {
  var os = require('os');
  var platform = os.platform();
  if (platform === 'linux' || platform === 'darwin') {
    var flowPath = getPathToFlow();
    if (!flowPathCache.has(flowPath)) {
      flowPathCache.set(flowPath, (yield canFindFlow(flowPath)));
    }

    return flowPathCache.get(flowPath);
  } else {
    // Flow does not currently work in Windows.
    return false;
  }
});

var canFindFlow = _asyncToGenerator(function* (flowPath) {
  try {
    yield asyncExecute('which', [flowPath]);
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * @return The path to Flow on the user's machine. It is recommended not to cache the result of this
 *   function in case the user updates his or her preferences in Atom, in which case the return
 *   value will be stale.
 */
);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

'use babel';

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var path = require('path');

var _require = require('nuclide-commons');

var asyncExecute = _require.asyncExecute;
var findNearestFile = _require.findNearestFile;

var LRU = require('lru-cache');

var flowConfigDirCache = LRU({
  max: 10,
  length: function length(n) {
    return n.length;
  },
  maxAge: 1000 * 30 });
//30 seconds
var flowPathCache = LRU({
  max: 10,
  maxAge: 1000 * 30 });

// 30 seconds
function insertAutocompleteToken(contents, line, col) {
  var lines = contents.split('\n');
  var theLine = lines[line];
  theLine = theLine.substring(0, col) + 'AUTO332' + theLine.substring(col);
  lines[line] = theLine;
  return lines.join('\n');
}

/**
 * Takes an autocomplete item from Flow and returns a valid autocomplete-plus
 * response, as documented here:
 * https://github.com/atom/autocomplete-plus/wiki/Provider-API
 */
function processAutocompleteItem(replacementPrefix, flowItem) {
  // Truncate long types for readability
  var description = flowItem['type'].length < 80 ? flowItem['type'] : flowItem['type'].substring(0, 80) + ' ...';
  var result = {
    description: description,
    displayText: flowItem['name'],
    replacementPrefix: replacementPrefix
  };
  var funcDetails = flowItem['func_details'];
  if (funcDetails) {
    // The parameters in human-readable form for use on the right label.
    var rightParamStrings = funcDetails['params'].map(function (param) {
      return param['name'] + ': ' + param['type'];
    });
    var snippetString = getSnippetString(funcDetails['params'].map(function (param) {
      return param['name'];
    }));
    result = _extends({}, result, {
      leftLabel: funcDetails['return_type'],
      rightLabel: '(' + rightParamStrings.join(', ') + ')',
      snippet: flowItem['name'] + '(' + snippetString + ')',
      type: 'function'
    });
  } else {
    result = _extends({}, result, {
      rightLabel: flowItem['type'],
      text: flowItem['name']
    });
  }
  return result;
}

function getSnippetString(paramNames) {
  var groupedParams = groupParamNames(paramNames);
  // The parameters turned into snippet strings.
  var snippetParamStrings = groupedParams.map(function (params) {
    return params.join(', ');
  }).map(function (param, i) {
    return '${' + (i + 1) + ':' + param + '}';
  });
  return snippetParamStrings.join(', ');
}

/**
 * Group the parameter names so that all of the trailing optional parameters are together with the
 * last non-optional parameter. That makes it easy to ignore the optional parameters, since they
 * will be selected along with the last non-optional parameter and you can just type to overwrite
 * them.
 */
function groupParamNames(paramNames) {
  // Split the parameters into two groups -- all of the trailing optional paramaters, and the rest
  // of the parameters. Trailing optional means all optional parameters that have only optional

  var _paramNames$reduceRight = paramNames.reduceRight(function (_ref, param) {
    var _ref2 = _slicedToArray(_ref, 2);

    var ordinary = _ref2[0];
    var optional = _ref2[1];

    // If there have only been optional params so far, and this one is optional, add it to the
    // list of trailing optional params.
    if (isOptional(param) && ordinary.length === 0) {
      optional.unshift(param);
    } else {
      ordinary.unshift(param);
    }
    return [ordinary, optional];
  }, [[], []]);

  var _paramNames$reduceRight2 = _slicedToArray(_paramNames$reduceRight, 2);

  var ordinaryParams = _paramNames$reduceRight2[0];
  var trailingOptional = _paramNames$reduceRight2[1];

  var groupedParams = ordinaryParams.map(function (param) {
    return [param];
  });
  var lastParam = groupedParams[groupedParams.length - 1];
  if (lastParam != null) {
    lastParam.push.apply(lastParam, _toConsumableArray(trailingOptional));
  } else if (trailingOptional.length > 0) {
    groupedParams.push(trailingOptional);
  }

  return groupedParams;
}

function isOptional(param) {
  (0, _assert2['default'])(param.length > 0);
  var lastChar = param[param.length - 1];
  return lastChar === '?';
}

function getPathToFlow() {
  if (global.atom) {
    return global.atom.config.get('nuclide-flow.pathToFlow');
  } else {
    return 'flow';
  }
}

function findFlowConfigDir(localFile) {
  if (!flowConfigDirCache.has(localFile)) {
    flowConfigDirCache.set(localFile, findNearestFile('.flowconfig', path.dirname(localFile)));
  }
  return flowConfigDirCache.get(localFile);
}

module.exports = {
  findFlowConfigDir: findFlowConfigDir,
  getPathToFlow: getPathToFlow,
  insertAutocompleteToken: insertAutocompleteToken,
  isFlowInstalled: isFlowInstalled,
  processAutocompleteItem: processAutocompleteItem,
  groupParamNames: groupParamNames
};
// parameters after them.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWZsb3ctYmFzZS9saWIvRmxvd0hlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztJQTJIZSxlQUFlLHFCQUE5QixhQUFtRDtBQUNqRCxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDekIsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQy9CLE1BQUksUUFBUSxLQUFLLE9BQU8sSUFBSSxRQUFRLEtBQUssUUFBUSxFQUFFO0FBQ2pELFFBQU0sUUFBUSxHQUFHLGFBQWEsRUFBRSxDQUFDO0FBQ2pDLFFBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQ2hDLG1CQUFhLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRSxNQUFNLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQSxDQUFDLENBQUM7S0FDMUQ7O0FBRUQsV0FBTyxhQUFhLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0dBQ3BDLE1BQU07O0FBRUwsV0FBTyxLQUFLLENBQUM7R0FDZDtDQUNGOztJQUVjLFdBQVcscUJBQTFCLFdBQTJCLFFBQWdCLEVBQW9CO0FBQzdELE1BQUk7QUFDRixVQUFNLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3hDLFdBQU8sSUFBSSxDQUFDO0dBQ2IsQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUNWLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7Q0FDRjs7Ozs7Ozs7Ozs7Ozs7O3NCQW5JcUIsUUFBUTs7OztBQWY5QixXQUFXLENBQUM7Ozs7Ozs7Ozs7QUFXWixJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7O2VBQ1csT0FBTyxDQUFDLGlCQUFpQixDQUFD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cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1mbG93LWJhc2UvbGliL0Zsb3dIZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHthc3luY0V4ZWN1dGUsIGZpbmROZWFyZXN0RmlsZX0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKTtcbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IGZsb3dDb25maWdEaXJDYWNoZSA9IExSVSh7XG4gIG1heDogMTAsXG4gIGxlbmd0aDogZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ubGVuZ3RoOyB9LFxuICBtYXhBZ2U6IDEwMDAgKiAzMCwgLy8zMCBzZWNvbmRzXG59KTtcbmNvbnN0IGZsb3dQYXRoQ2FjaGUgPSBMUlUoe1xuICBtYXg6IDEwLFxuICBtYXhBZ2U6IDEwMDAgKiAzMCwgLy8gMzAgc2Vjb25kc1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydEF1dG9jb21wbGV0ZVRva2VuKGNvbnRlbnRzOiBzdHJpbmcsIGxpbmU6IG51bWJlciwgY29sOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBsaW5lcyA9IGNvbnRlbnRzLnNwbGl0KCdcXG4nKTtcbiAgbGV0IHRoZUxpbmUgPSBsaW5lc1tsaW5lXTtcbiAgdGhlTGluZSA9IHRoZUxpbmUuc3Vic3RyaW5nKDAsIGNvbCkgKyAnQVVUTzMzMicgKyB0aGVMaW5lLnN1YnN0cmluZyhjb2wpO1xuICBsaW5lc1tsaW5lXSA9IHRoZUxpbmU7XG4gIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBhdXRvY29tcGxldGUgaXRlbSBmcm9tIEZsb3cgYW5kIHJldHVybnMgYSB2YWxpZCBhdXRvY29tcGxldGUtcGx1c1xuICogcmVzcG9uc2UsIGFzIGRvY3VtZW50ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9tL2F1dG9jb21wbGV0ZS1wbHVzL3dpa2kvUHJvdmlkZXItQVBJXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NBdXRvY29tcGxldGVJdGVtKHJlcGxhY2VtZW50UHJlZml4OiBzdHJpbmcsIGZsb3dJdGVtOiBPYmplY3QpOiBPYmplY3Qge1xuICAvLyBUcnVuY2F0ZSBsb25nIHR5cGVzIGZvciByZWFkYWJpbGl0eVxuICBjb25zdCBkZXNjcmlwdGlvbiA9IGZsb3dJdGVtWyd0eXBlJ10ubGVuZ3RoIDwgODBcbiAgICA/IGZsb3dJdGVtWyd0eXBlJ11cbiAgICA6IGZsb3dJdGVtWyd0eXBlJ10uc3Vic3RyaW5nKDAsODApICsgJyAuLi4nO1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICBkaXNwbGF5VGV4dDogZmxvd0l0ZW1bJ25hbWUnXSxcbiAgICByZXBsYWNlbWVudFByZWZpeCxcbiAgfTtcbiAgY29uc3QgZnVuY0RldGFpbHMgPSBmbG93SXRlbVsnZnVuY19kZXRhaWxzJ107XG4gIGlmIChmdW5jRGV0YWlscykge1xuICAgIC8vIFRoZSBwYXJhbWV0ZXJzIGluIGh1bWFuLXJlYWRhYmxlIGZvcm0gZm9yIHVzZSBvbiB0aGUgcmlnaHQgbGFiZWwuXG4gICAgY29uc3QgcmlnaHRQYXJhbVN0cmluZ3MgPSBmdW5jRGV0YWlsc1sncGFyYW1zJ11cbiAgICAgIC5tYXAocGFyYW0gPT4gYCR7cGFyYW1bJ25hbWUnXX06ICR7cGFyYW1bJ3R5cGUnXX1gKTtcbiAgICBjb25zdCBzbmlwcGV0U3RyaW5nID0gZ2V0U25pcHBldFN0cmluZyhmdW5jRGV0YWlsc1sncGFyYW1zJ10ubWFwKHBhcmFtID0+IHBhcmFtWyduYW1lJ10pKTtcbiAgICByZXN1bHQgPSB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICBsZWZ0TGFiZWw6IGZ1bmNEZXRhaWxzWydyZXR1cm5fdHlwZSddLFxuICAgICAgcmlnaHRMYWJlbDogYCgke3JpZ2h0UGFyYW1TdHJpbmdzLmpvaW4oJywgJyl9KWAsXG4gICAgICBzbmlwcGV0OiBgJHtmbG93SXRlbVsnbmFtZSddfSgke3NuaXBwZXRTdHJpbmd9KWAsXG4gICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgcmlnaHRMYWJlbDogZmxvd0l0ZW1bJ3R5cGUnXSxcbiAgICAgIHRleHQ6IGZsb3dJdGVtWyduYW1lJ10sXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRTbmlwcGV0U3RyaW5nKHBhcmFtTmFtZXM6IEFycmF5PHN0cmluZz4pOiBzdHJpbmcge1xuICBjb25zdCBncm91cGVkUGFyYW1zID0gZ3JvdXBQYXJhbU5hbWVzKHBhcmFtTmFtZXMpO1xuICAvLyBUaGUgcGFyYW1ldGVycyB0dXJuZWQgaW50byBzbmlwcGV0IHN0cmluZ3MuXG4gIGNvbnN0IHNuaXBwZXRQYXJhbVN0cmluZ3MgPSBncm91cGVkUGFyYW1zXG4gICAgLm1hcChwYXJhbXMgPT4gcGFyYW1zLmpvaW4oJywgJykpXG4gICAgLm1hcCgocGFyYW0sIGkpID0+IGBcXCR7JHtpICsgMX06JHtwYXJhbX19YCk7XG4gIHJldHVybiBzbmlwcGV0UGFyYW1TdHJpbmdzLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogR3JvdXAgdGhlIHBhcmFtZXRlciBuYW1lcyBzbyB0aGF0IGFsbCBvZiB0aGUgdHJhaWxpbmcgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgdG9nZXRoZXIgd2l0aCB0aGVcbiAqIGxhc3Qgbm9uLW9wdGlvbmFsIHBhcmFtZXRlci4gVGhhdCBtYWtlcyBpdCBlYXN5IHRvIGlnbm9yZSB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycywgc2luY2UgdGhleVxuICogd2lsbCBiZSBzZWxlY3RlZCBhbG9uZyB3aXRoIHRoZSBsYXN0IG5vbi1vcHRpb25hbCBwYXJhbWV0ZXIgYW5kIHlvdSBjYW4ganVzdCB0eXBlIHRvIG92ZXJ3cml0ZVxuICogdGhlbS5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBQYXJhbU5hbWVzKHBhcmFtTmFtZXM6IEFycmF5PHN0cmluZz4pOiBBcnJheTxBcnJheTxzdHJpbmc+PiB7XG4gIC8vIFNwbGl0IHRoZSBwYXJhbWV0ZXJzIGludG8gdHdvIGdyb3VwcyAtLSBhbGwgb2YgdGhlIHRyYWlsaW5nIG9wdGlvbmFsIHBhcmFtYXRlcnMsIGFuZCB0aGUgcmVzdFxuICAvLyBvZiB0aGUgcGFyYW1ldGVycy4gVHJhaWxpbmcgb3B0aW9uYWwgbWVhbnMgYWxsIG9wdGlvbmFsIHBhcmFtZXRlcnMgdGhhdCBoYXZlIG9ubHkgb3B0aW9uYWxcbiAgLy8gcGFyYW1ldGVycyBhZnRlciB0aGVtLlxuICBjb25zdCBbb3JkaW5hcnlQYXJhbXMsIHRyYWlsaW5nT3B0aW9uYWxdID1cbiAgICBwYXJhbU5hbWVzLnJlZHVjZVJpZ2h0KChbb3JkaW5hcnksIG9wdGlvbmFsXSwgcGFyYW0pID0+IHtcbiAgICAgIC8vIElmIHRoZXJlIGhhdmUgb25seSBiZWVuIG9wdGlvbmFsIHBhcmFtcyBzbyBmYXIsIGFuZCB0aGlzIG9uZSBpcyBvcHRpb25hbCwgYWRkIGl0IHRvIHRoZVxuICAgICAgLy8gbGlzdCBvZiB0cmFpbGluZyBvcHRpb25hbCBwYXJhbXMuXG4gICAgICBpZiAoaXNPcHRpb25hbChwYXJhbSkgJiYgb3JkaW5hcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9wdGlvbmFsLnVuc2hpZnQocGFyYW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JkaW5hcnkudW5zaGlmdChwYXJhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW29yZGluYXJ5LCBvcHRpb25hbF07XG4gICAgfSxcbiAgICBbW10sIFtdXVxuICApO1xuXG4gIGNvbnN0IGdyb3VwZWRQYXJhbXMgPSBvcmRpbmFyeVBhcmFtcy5tYXAocGFyYW0gPT4gW3BhcmFtXSk7XG4gIGNvbnN0IGxhc3RQYXJhbSA9IGdyb3VwZWRQYXJhbXNbZ3JvdXBlZFBhcmFtcy5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RQYXJhbSAhPSBudWxsKSB7XG4gICAgbGFzdFBhcmFtLnB1c2goLi4udHJhaWxpbmdPcHRpb25hbCk7XG4gIH0gZWxzZSBpZiAodHJhaWxpbmdPcHRpb25hbC5sZW5ndGggPiAwKSB7XG4gICAgZ3JvdXBlZFBhcmFtcy5wdXNoKHRyYWlsaW5nT3B0aW9uYWwpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwZWRQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGlzT3B0aW9uYWwocGFyYW06IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpbnZhcmlhbnQocGFyYW0ubGVuZ3RoID4gMCk7XG4gIGNvbnN0IGxhc3RDaGFyID0gcGFyYW1bcGFyYW0ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBsYXN0Q2hhciA9PT0gJz8nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc0Zsb3dJbnN0YWxsZWQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbiAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xuICBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcgfHwgcGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgY29uc3QgZmxvd1BhdGggPSBnZXRQYXRoVG9GbG93KCk7XG4gICAgaWYgKCFmbG93UGF0aENhY2hlLmhhcyhmbG93UGF0aCkpIHtcbiAgICAgIGZsb3dQYXRoQ2FjaGUuc2V0KGZsb3dQYXRoLCBhd2FpdCBjYW5GaW5kRmxvdyhmbG93UGF0aCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmbG93UGF0aENhY2hlLmdldChmbG93UGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmxvdyBkb2VzIG5vdCBjdXJyZW50bHkgd29yayBpbiBXaW5kb3dzLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYW5GaW5kRmxvdyhmbG93UGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgYXN5bmNFeGVjdXRlKCd3aGljaCcsIFtmbG93UGF0aF0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQHJldHVybiBUaGUgcGF0aCB0byBGbG93IG9uIHRoZSB1c2VyJ3MgbWFjaGluZS4gSXQgaXMgcmVjb21tZW5kZWQgbm90IHRvIGNhY2hlIHRoZSByZXN1bHQgb2YgdGhpc1xuICogICBmdW5jdGlvbiBpbiBjYXNlIHRoZSB1c2VyIHVwZGF0ZXMgaGlzIG9yIGhlciBwcmVmZXJlbmNlcyBpbiBBdG9tLCBpbiB3aGljaCBjYXNlIHRoZSByZXR1cm5cbiAqICAgdmFsdWUgd2lsbCBiZSBzdGFsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aFRvRmxvdygpOiBzdHJpbmcge1xuICBpZiAoZ2xvYmFsLmF0b20pIHtcbiAgICByZXR1cm4gZ2xvYmFsLmF0b20uY29uZmlnLmdldCgnbnVjbGlkZS1mbG93LnBhdGhUb0Zsb3cnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ2Zsb3cnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRGbG93Q29uZmlnRGlyKGxvY2FsRmlsZTogc3RyaW5nKTogUHJvbWlzZTw/c3RyaW5nPiB7XG4gIGlmICghZmxvd0NvbmZpZ0RpckNhY2hlLmhhcyhsb2NhbEZpbGUpKSB7XG4gICAgZmxvd0NvbmZpZ0RpckNhY2hlLnNldChsb2NhbEZpbGUsIGZpbmROZWFyZXN0RmlsZSgnLmZsb3djb25maWcnLCBwYXRoLmRpcm5hbWUobG9jYWxGaWxlKSkpO1xuICB9XG4gIHJldHVybiBmbG93Q29uZmlnRGlyQ2FjaGUuZ2V0KGxvY2FsRmlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaW5kRmxvd0NvbmZpZ0RpcixcbiAgZ2V0UGF0aFRvRmxvdyxcbiAgaW5zZXJ0QXV0b2NvbXBsZXRlVG9rZW4sXG4gIGlzRmxvd0luc3RhbGxlZCxcbiAgcHJvY2Vzc0F1dG9jb21wbGV0ZUl0ZW0sXG4gIGdyb3VwUGFyYW1OYW1lcyxcbn07XG4iXX0=
