Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _assert3 = _interopRequireDefault(_assert);

var _vm = require('vm');

var _vm2 = _interopRequireDefault(_vm);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _nuclideCommons = require('nuclide-commons');

var _builtinTypes = require('./builtin-types');

/*
 * This type represents a Transformer function, which takes in a value, and either serializes
 * or deserializes it. Transformer's are added to a registry and indexed by the name of
 * the type they handle (eg: 'Date'). The second argument is the actual type object that represent
 * the value. Parameterized types like Array, or Object can use this to recursively call other
 * transformers.
 */
'use babel';

function statsToObject(stats) {
  var result = {
    dev: stats.dev,
    mode: stats.mode,
    nlink: stats.nlink,
    uid: stats.uid,
    gid: stats.gid,
    rdev: stats.rdev,
    blksize: stats.blksize,
    ino: stats.ino,
    size: stats.size,
    blocks: stats.blocks,
    atime: stats.atime.toJSON(),
    mtime: stats.mtime.toJSON(),
    ctime: stats.ctime.toJSON()
  };

  if (stats.birthtime) {
    return _extends({}, result, { birthtime: stats.birthtime.toJSON() });
  }

  return result;
}

function objectToStats(jsonStats) {
  var stats = new _fs2['default'].Stats();

  stats.dev = jsonStats.dev;
  stats.mode = jsonStats.mode;
  stats.nlink = jsonStats.nlink;
  stats.uid = jsonStats.uid;
  stats.gid = jsonStats.gid;
  stats.rdev = jsonStats.rdev;
  stats.blksize = jsonStats.blksize;
  stats.ino = jsonStats.ino;
  stats.size = jsonStats.size;
  stats.blocks = jsonStats.blocks;
  stats.atime = new Date(jsonStats.atime);
  stats.mtime = new Date(jsonStats.mtime);
  stats.ctime = new Date(jsonStats.ctime);

  if (jsonStats.birthtime) {
    // $FlowIssue
    stats.birthtime = new Date(jsonStats.birthtime);
  }

  return stats;
}

/*
 * The TypeRegistry is a centralized place to register functions that serialize and deserialize
 * types. This allows for types defined in one service to include types from another service in
 * another file. It also allows the ability to add new primitives, ranging from Buffer to NuclideUri
 * that are not handled at the transport layer. The key concept is that marshalling functions can
 * be recursive, calling other marshalling functions, ending at the primitives.
 */

var TypeRegistry = (function () {
  function TypeRegistry() {
    var _this = this;

    _classCallCheck(this, TypeRegistry);

    this._kindMarshallers = new Map();
    this._namedMarshallers = new Map();

    this._registerPrimitives();
    this._registerSpecialTypes();
    this._registerContainers();
    this._registerLiterals();
    this._registerUnions();

    // Register NullableType and NamedType
    this._registerKind('nullable', _asyncToGenerator(function* (value, type) {
      if (value === null || value === undefined || type.kind !== 'nullable') {
        return null;
      }
      return yield _this.marshal(value, type.type);
    }), _asyncToGenerator(function* (value, type) {
      if (value === null || value === undefined || type.kind !== 'nullable') {
        return null;
      }
      return yield _this.unmarshal(value, type.type);
    }));

    this._registerKind('named', _asyncToGenerator(function* (value, type) {
      (0, _assert3['default'])(type.kind === 'named');
      if (!_this._namedMarshallers.has(type.name)) {
        throw new Error('No marshaller found for named type ' + type.name + '.');
      }
      return yield _this._namedMarshallers.get(type.name).marshaller(value);
    }), _asyncToGenerator(function* (value, type) {
      (0, _assert3['default'])(type.kind === 'named');
      if (!_this._namedMarshallers.get(type.name)) {
        throw new Error('No marshaller found for named type ' + type.name + '.');
      }
      return yield _this._namedMarshallers.get(type.name).unmarshaller(value);
    }));

    this._registerKind('void', function (value, type) {
      return Promise.resolve(null);
    }, function (value, type) {
      return Promise.resolve(null);
    });
  }

  _createClass(TypeRegistry, [{
    key: '_registerKind',
    value: function _registerKind(kind, marshaller, unmarshaller) {
      (0, _assert3['default'])(!this._kindMarshallers.has(kind));
      this._kindMarshallers.set(kind, { marshaller: marshaller, unmarshaller: unmarshaller });
    }

    /**
     * Register a type by providing both a marshaller and an unmarshaller. The marshaller
     * will be called to transform the type before sending it out onto the network, while the
     * unmarshaller will be called on values incoming from the network.
     * @param typeName - The string name of the type that the provided marshallers convert.
     * @param marshaller - Serialize the type.
     * @param unmarshaller - Deserialize the type.
     */
  }, {
    key: 'registerType',
    value: function registerType(typeName, marshaller, unmarshaller) {
      if (this._namedMarshallers.has(typeName)) {
        throw new Error('A type by the name ' + typeName + ' has already been registered.');
      }
      this._namedMarshallers.set(typeName, { marshaller: marshaller, unmarshaller: unmarshaller });
    }

    /**
     * Helper function for registering the marashaller/unmarshaller for a type alias.
     * @param name - The name of the alias type.
     * @param type - The type the the alias represents.
     */
  }, {
    key: 'registerAlias',
    value: function registerAlias(name, type) {
      var _this2 = this;

      this.registerType(name, function (value) {
        return _this2.marshal(value, type);
      }, function (value) {
        return _this2.unmarshal(value, type);
      });
    }

    /**
     * Marshal an object using the appropriate marshal function.
     * @param value - The value to be marshalled.
     * @param type - The type object (used to find the appropriate function).
     */
  }, {
    key: 'marshal',
    value: function marshal(value, type) {
      if (!this._kindMarshallers.has(type.kind)) {
        throw new Error('No marshaller found for type kind ' + type.kind + '.');
      }
      return this._kindMarshallers.get(type.kind).marshaller(value, type);
    }

    /**
     * Unmarshal and object using the appropriate unmarshal function.
     * @param value - The value to be marshalled.
     * @param type - The type object (used to find the appropriate function).
     */
  }, {
    key: 'unmarshal',
    value: function unmarshal(value, type) {
      if (!this._kindMarshallers.has(type.kind)) {
        throw new Error('No unmarshaller found for type kind ' + type.kind + '.');
      }
      return this._kindMarshallers.get(type.kind).unmarshaller(value, type);
    }
  }, {
    key: '_registerPrimitives',
    value: function _registerPrimitives() {
      // Since string, number, and boolean are JSON primitives,
      // they require no marshalling. Instead, simply create wrapped transformers
      // that assert the type of their argument.
      var stringTransformer = _asyncToGenerator(function* (arg) {
        // Unbox argument.
        arg = arg instanceof String ? arg.valueOf() : arg;
        (0, _assert2['default'])(typeof arg === 'string', 'Expected a string argument');
        return arg;
      });
      var numberTransformer = _asyncToGenerator(function* (arg) {
        // Unbox argument.
        if (arg instanceof Number) {
          arg = arg.valueOf();
        }
        (0, _assert2['default'])(typeof arg === 'number', 'Expected a number argument');
        return arg;
      });
      var booleanTransformer = _asyncToGenerator(function* (arg) {
        // Unbox argument
        if (arg instanceof Boolean) {
          arg = arg.valueOf();
        }
        (0, _assert2['default'])(typeof arg === 'boolean', 'Expected a boolean argument');
        return arg;
      });
      // We assume an 'any' and 'mixed' types require no marshalling.
      var identityTransformer = _asyncToGenerator(function* (arg) {
        return arg;
      });

      // Register these transformers
      this._registerKind('string', stringTransformer, stringTransformer);
      this._registerKind('number', numberTransformer, numberTransformer);
      this._registerKind('boolean', booleanTransformer, booleanTransformer);
      this._registerKind('any', identityTransformer, identityTransformer);
      this._registerKind('mixed', identityTransformer, identityTransformer);
    }
  }, {
    key: '_registerLiterals',
    value: function _registerLiterals() {
      var literalTransformer = _asyncToGenerator(function* (arg, type) {
        (0, _assert3['default'])(type.kind === 'string-literal' || type.kind === 'number-literal' || type.kind === 'boolean-literal');
        (0, _assert3['default'])(arg === type.value);
        return arg;
      });
      this._registerKind('string-literal', literalTransformer, literalTransformer);
      this._registerKind('number-literal', literalTransformer, literalTransformer);
      this._registerKind('boolean-literal', literalTransformer, literalTransformer);
    }
  }, {
    key: '_registerUnions',
    value: function _registerUnions() {
      var _this3 = this;

      var unionLiteralTransformer = _asyncToGenerator(function* (arg, type) {
        (0, _assert3['default'])(type.kind === 'union');
        var alternate = _nuclideCommons.array.find(type.types, function (element) {
          (0, _assert3['default'])(element.kind === 'string-literal' || element.kind === 'number-literal' || element.kind === 'boolean-literal');
          return arg === element.value;
        });
        (0, _assert3['default'])(alternate);
        // This is just the literal transformer inlined ...
        return arg;
      });
      var unionObjectMarshaller = function unionObjectMarshaller(arg, type) {
        (0, _assert3['default'])(type.kind === 'union');
        return _this3.marshal(arg, findAlternate(arg, type));
      };
      var unionObjectUnmarshaller = function unionObjectUnmarshaller(arg, type) {
        (0, _assert3['default'])(type.kind === 'union');
        return _this3.unmarshal(arg, findAlternate(arg, type));
      };
      var unionMarshaller = function unionMarshaller(arg, type) {
        (0, _assert3['default'])(type.kind === 'union');
        if (type.discriminantField != null) {
          return unionObjectMarshaller(arg, type);
        } else {
          return unionLiteralTransformer(arg, type);
        }
      };
      var unionUnmarshaller = function unionUnmarshaller(arg, type) {
        (0, _assert3['default'])(type.kind === 'union');
        if (type.discriminantField != null) {
          return unionObjectUnmarshaller(arg, type);
        } else {
          return unionLiteralTransformer(arg, type);
        }
      };
      this._registerKind('union', unionMarshaller, unionUnmarshaller);
    }
  }, {
    key: '_registerSpecialTypes',
    value: function _registerSpecialTypes() {
      // Serialize / Deserialize any Object type
      this.registerType(_builtinTypes.objectType.name, _asyncToGenerator(function* (object) {
        (0, _assert2['default'])(object != null && typeof object === 'object', 'Expected Object argument.');
        return object;
      }), _asyncToGenerator(function* (object) {
        (0, _assert2['default'])(object != null && typeof object === 'object', 'Expected Object argument.');
        return object;
      }));

      // Serialize / Deserialize Javascript Date objects
      this.registerType(_builtinTypes.dateType.name, _asyncToGenerator(function* (date) {
        (0, _assert2['default'])(date instanceof Date, 'Expected date argument.');
        return date.toJSON();
      }), _asyncToGenerator(function* (dateStr) {
        // Unbox argument.
        dateStr = dateStr instanceof String ? dateStr.valueOf() : dateStr;

        (0, _assert2['default'])(typeof dateStr === 'string', 'Expeceted a string argument.');
        return new Date(dateStr);
      }));

      // Serialize / Deserialize RegExp objects
      this.registerType(_builtinTypes.regExpType.name, _asyncToGenerator(function* (regexp) {
        (0, _assert2['default'])(regexp instanceof RegExp, 'Expected a RegExp object as an argument');
        return regexp.toString();
      }), _asyncToGenerator(function* (regStr) {
        // Unbox argument.
        regStr = regStr instanceof String ? regStr.valueOf() : regStr;

        (0, _assert2['default'])(typeof regStr === 'string', 'Expected a string argument.');
        // $FlowIssue - flesh out the vm module.
        return _vm2['default'].runInThisContext(regStr);
      }));

      // Serialize / Deserialize Buffer objects through Base64 strings
      this.registerType(_builtinTypes.bufferType.name, _asyncToGenerator(function* (buffer) {
        (0, _assert2['default'])(buffer instanceof Buffer, 'Expected a buffer argument.');
        return buffer.toString('base64');
      }), _asyncToGenerator(function* (base64string) {
        // Unbox argument.
        base64string = base64string instanceof String ? base64string.valueOf() : base64string;

        (0, _assert2['default'])(typeof base64string === 'string', 'Expected a base64 string. Not ' + typeof base64string);
        return new Buffer(base64string, 'base64');
      }));

      // fs.Stats
      this.registerType(_builtinTypes.fsStatsType.name, _asyncToGenerator(function* (stats) {
        (0, _assert2['default'])(stats instanceof _fs2['default'].Stats);
        return JSON.stringify(statsToObject(stats));
      }), _asyncToGenerator(function* (json) {
        (0, _assert2['default'])(typeof json === 'string');
        return objectToStats(JSON.parse(json));
      }));
    }
  }, {
    key: '_registerContainers',
    value: function _registerContainers() {
      var _this4 = this;

      // Serialize / Deserialize Arrays.
      this._registerKind('array', _asyncToGenerator(function* (value, type) {
        (0, _assert2['default'])(value instanceof Array, 'Expected an object of type Array.');
        (0, _assert3['default'])(type.kind === 'array');
        var elemType = type.type;
        return yield Promise.all(value.map(function (elem) {
          return _this4.marshal(elem, elemType);
        }));
      }), _asyncToGenerator(function* (value, type) {
        (0, _assert2['default'])(value instanceof Array, 'Expected an object of type Array.');
        (0, _assert3['default'])(type.kind === 'array');
        var elemType = type.type;
        return yield Promise.all(value.map(function (elem) {
          return _this4.unmarshal(elem, elemType);
        }));
      }));

      // Serialize and Deserialize Objects.
      this._registerKind('object', _asyncToGenerator(function* (obj, type) {
        (0, _assert2['default'])(typeof obj === 'object', 'Expected an argument of type object.');
        (0, _assert3['default'])(type.kind === 'object');
        var newObj = {}; // Create a new object so we don't mutate the original one.
        yield Promise.all(type.fields.map(_asyncToGenerator(function* (prop) {
          // Check if the source object has this key.
          if (obj.hasOwnProperty(prop.name)) {
            newObj[prop.name] = yield _this4.marshal(obj[prop.name], prop.type);
          } else {
            // If the property is optional, it's okay for it to be missing.
            if (!prop.optional) {
              throw new Error('Source object is missing property ' + prop.name + '.');
            }
          }
        })));
        return newObj;
      }), _asyncToGenerator(function* (obj, type) {
        (0, _assert2['default'])(typeof obj === 'object', 'Expected an argument of type object.');
        (0, _assert3['default'])(type.kind === 'object');
        var newObj = {}; // Create a new object so we don't mutate the original one.
        yield Promise.all(type.fields.map(_asyncToGenerator(function* (prop) {
          // Check if the source object has this key.
          if (obj.hasOwnProperty(prop.name)) {
            newObj[prop.name] = yield _this4.unmarshal(obj[prop.name], prop.type);
          } else {
            // If the property is optional, it's okay for it to be missing.
            if (!prop.optional) {
              throw new Error('Source object is missing property ' + prop.name + '.');
            }
          }
        })));
        return newObj;
      }));

      // Serialize / Deserialize Sets.
      this._registerKind('set', _asyncToGenerator(function* (value, type) {
        (0, _assert3['default'])(type.kind === 'set');
        (0, _assert2['default'])(value instanceof Set, 'Expected an object of type Set.');
        var serializePromises = [];
        for (var elem of value) {
          serializePromises.push(_this4.marshal(elem, type.type));
        }
        return yield Promise.all(serializePromises);
      }), _asyncToGenerator(function* (value, type) {
        (0, _assert2['default'])(value instanceof Array, 'Expected an object of type Array.');
        (0, _assert3['default'])(type.kind === 'set');
        var elemType = type.type;
        var elements = yield Promise.all(value.map(function (elem) {
          return _this4.unmarshal(elem, elemType);
        }));
        return new Set(elements);
      }));

      // Serialize / Deserialize Maps.
      this._registerKind('map', _asyncToGenerator(function* (map, type) {
        (0, _assert2['default'])(map instanceof Map, 'Expected an object of type Set.');
        (0, _assert3['default'])(type.kind === 'map');
        var serializePromises = [];
        for (var _ref3 of map) {
          var _ref2 = _slicedToArray(_ref3, 2);

          var key = _ref2[0];
          var _value = _ref2[1];

          serializePromises.push(Promise.all([_this4.marshal(key, type.keyType), _this4.marshal(_value, type.valueType)]));
        }
        return yield Promise.all(serializePromises);
      }), _asyncToGenerator(function* (serialized, type) {
        (0, _assert2['default'])(serialized instanceof Array, 'Expected an object of type Array.');
        (0, _assert3['default'])(type.kind === 'map');
        var keyType = type.keyType;
        var valueType = type.valueType;
        var entries = yield Promise.all(serialized.map(function (entry) {
          return Promise.all([_this4.unmarshal(entry[0], keyType), _this4.unmarshal(entry[1], valueType)]);
        }));
        return new Map(entries);
      }));

      // Serialize / Deserialize Tuples.
      this._registerKind('tuple', _asyncToGenerator(function* (value, type) {
        // Assert the length of the array.
        (0, _assert2['default'])(Array.isArray(value), 'Expected an object of type Array.');
        (0, _assert3['default'])(type.kind === 'tuple');
        var types = type.types;
        (0, _assert2['default'])(value.length === types.length, 'Expected tuple of length ' + types.length + '.');

        // Convert all of the elements through the correct marshaller.
        return yield Promise.all(value.map(function (elem, i) {
          return _this4.marshal(elem, types[i]);
        }));
      }), _asyncToGenerator(function* (value, type) {
        // Assert the length of the array.
        (0, _assert2['default'])(Array.isArray(value), 'Expected an object of type Array.');
        (0, _assert3['default'])(type.kind === 'tuple');
        var types = type.types;
        (0, _assert2['default'])(value.length === types.length, 'Expected tuple of length ' + types.length + '.');

        // Convert all of the elements through the correct unmarshaller.
        return yield Promise.all(value.map(function (elem, i) {
          return _this4.unmarshal(elem, types[i]);
        }));
      }));
    }
  }]);

  return TypeRegistry;
})();

exports['default'] = TypeRegistry;

function getObjectFieldByName(type, fieldName) {
  var result = _nuclideCommons.array.find(type.fields, function (field) {
    return field.name === fieldName;
  });
  (0, _assert3['default'])(result != null);
  return result;
}

function findAlternate(arg, type) {
  var discriminantField = type.discriminantField;
  (0, _assert3['default'])(discriminantField != null);
  var discriminant = arg[discriminantField];
  (0, _assert3['default'])(discriminant != null);
  var alternates = type.types;
  var result = _nuclideCommons.array.find(alternates, function (alternate) {
    (0, _assert3['default'])(alternate.kind === 'object');
    var alternateType = getObjectFieldByName(alternate, discriminantField).type;
    (0, _assert3['default'])(alternateType.kind === 'string-literal' || alternateType.kind === 'number-literal' || alternateType.kind === 'boolean-literal');
    return alternateType.value === discriminant;
  });
  (0, _assert3['default'])(result != null);
  return result;
}
module.exports = exports['default'];

/** Store marhsallers and and unmarshallers, index by the kind of the type. */

/** Store marhsallers and and unmarshallers, index by the name of the type. */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtcGFyc2VyL2xpYi9UeXBlUmVnaXN0cnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQVdtQixRQUFROzs7Ozs7a0JBRVosSUFBSTs7OztrQkFDSixJQUFJOzs7OzhCQUVDLGlCQUFpQjs7NEJBUW1DLGlCQUFpQjs7Ozs7Ozs7O0FBeEJ6RixXQUFXLENBQUM7O0FBb0NaLFNBQVMsYUFBYSxDQUFDLEtBQWUsRUFBVTtBQUM5QyxNQUFNLE1BQU0sR0FBRztBQUNiLE9BQUcsRUFBRSxLQUFLLENBQUMsR0FBRztBQUNkLFFBQUksRUFBRSxLQUFLLENBQUMsSUFBSTtBQUNoQixTQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7QUFDbEIsT0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFHO0FBQ2QsT0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFHO0FBQ2QsUUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO0FBQ2hCLFdBQU8sRUFBRSxLQUFLLENBQUMsT0FBTztBQUN0QixPQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUc7QUFDZCxRQUFJLEVBQUUsS0FBSyxDQUFDLElBQUk7QUFDaEIsVUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO0FBQ3BCLFNBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtBQUMzQixTQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7QUFDM0IsU0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO0dBQzVCLENBQUM7O0FBRUYsTUFBSSxLQUFLLENBQUMsU0FBUyxFQUFFO0FBQ25CLHdCQUFXLE1BQU0sSUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBRztH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QUcsZ0JBL2NULEtBQUssQ0ErY1UsSUFBSSxDQUFDLFVBQVUsRUFBRSxVQUFBLFNBQVMsRUFBSTtBQUNqRCw2QkFBVSxTQUFTLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDO0FBQ3ZDLFFBQU0sYUFBYSxHQUFHLG9CQUFvQixDQUFDLFNBQVMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUM5RSw2QkFBVSxhQUFhLENBQUMsSUFBSSxLQUFLLGdCQUFnQixJQUFJLGFBQWEsQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLElBQ3JGLGFBQWEsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLENBQUMsQ0FBQztBQUNqRCxXQUFPLGFBQWEsQ0FBQyxLQUFLLEtBQUssWUFBWSxDQUFDO0dBQzdDLENBQUMsQ0FBQztBQUNILDJCQUFVLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQztBQUMxQixTQUFPLE1BQU0sQ0FBQztDQUNmIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtcGFyc2VyL2xpYi9UeXBlUmVnaXN0cnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgdm0gZnJvbSAndm0nO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcblxuaW1wb3J0IHthcnJheX0gZnJvbSAnbnVjbGlkZS1jb21tb25zJztcblxuaW1wb3J0IHR5cGUge1xuICBUeXBlLFxuICBPYmplY3RUeXBlLFxuICBPYmplY3RGaWVsZCxcbiAgVW5pb25UeXBlLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7b2JqZWN0VHlwZSwgZGF0ZVR5cGUsIHJlZ0V4cFR5cGUsIGJ1ZmZlclR5cGUsIGZzU3RhdHNUeXBlfSBmcm9tICcuL2J1aWx0aW4tdHlwZXMnO1xuXG5cbi8qXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhIFRyYW5zZm9ybWVyIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBpbiBhIHZhbHVlLCBhbmQgZWl0aGVyIHNlcmlhbGl6ZXNcbiAqIG9yIGRlc2VyaWFsaXplcyBpdC4gVHJhbnNmb3JtZXIncyBhcmUgYWRkZWQgdG8gYSByZWdpc3RyeSBhbmQgaW5kZXhlZCBieSB0aGUgbmFtZSBvZlxuICogdGhlIHR5cGUgdGhleSBoYW5kbGUgKGVnOiAnRGF0ZScpLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBhY3R1YWwgdHlwZSBvYmplY3QgdGhhdCByZXByZXNlbnRcbiAqIHRoZSB2YWx1ZS4gUGFyYW1ldGVyaXplZCB0eXBlcyBsaWtlIEFycmF5LCBvciBPYmplY3QgY2FuIHVzZSB0aGlzIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgb3RoZXJcbiAqIHRyYW5zZm9ybWVycy5cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNmb3JtZXIgPSAodmFsdWU6IGFueSwgdHlwZTogVHlwZSkgPT4gUHJvbWlzZTxhbnk+O1xuXG5mdW5jdGlvbiBzdGF0c1RvT2JqZWN0KHN0YXRzOiBmcy5TdGF0cyk6IE9iamVjdCB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkZXY6IHN0YXRzLmRldixcbiAgICBtb2RlOiBzdGF0cy5tb2RlLFxuICAgIG5saW5rOiBzdGF0cy5ubGluayxcbiAgICB1aWQ6IHN0YXRzLnVpZCxcbiAgICBnaWQ6IHN0YXRzLmdpZCxcbiAgICByZGV2OiBzdGF0cy5yZGV2LFxuICAgIGJsa3NpemU6IHN0YXRzLmJsa3NpemUsXG4gICAgaW5vOiBzdGF0cy5pbm8sXG4gICAgc2l6ZTogc3RhdHMuc2l6ZSxcbiAgICBibG9ja3M6IHN0YXRzLmJsb2NrcyxcbiAgICBhdGltZTogc3RhdHMuYXRpbWUudG9KU09OKCksXG4gICAgbXRpbWU6IHN0YXRzLm10aW1lLnRvSlNPTigpLFxuICAgIGN0aW1lOiBzdGF0cy5jdGltZS50b0pTT04oKSxcbiAgfTtcblxuICBpZiAoc3RhdHMuYmlydGh0aW1lKSB7XG4gICAgcmV0dXJuIHsuLi5yZXN1bHQsIGJpcnRodGltZTogc3RhdHMuYmlydGh0aW1lLnRvSlNPTigpIH07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0YXRzKGpzb25TdGF0czogT2JqZWN0KTogZnMuU3RhdHMge1xuICBjb25zdCBzdGF0cyA9IG5ldyBmcy5TdGF0cygpO1xuXG4gIHN0YXRzLmRldiA9IGpzb25TdGF0cy5kZXY7XG4gIHN0YXRzLm1vZGUgPSBqc29uU3RhdHMubW9kZTtcbiAgc3RhdHMubmxpbmsgPSBqc29uU3RhdHMubmxpbms7XG4gIHN0YXRzLnVpZCA9IGpzb25TdGF0cy51aWQ7XG4gIHN0YXRzLmdpZCA9IGpzb25TdGF0cy5naWQ7XG4gIHN0YXRzLnJkZXYgPSBqc29uU3RhdHMucmRldjtcbiAgc3RhdHMuYmxrc2l6ZSA9IGpzb25TdGF0cy5ibGtzaXplO1xuICBzdGF0cy5pbm8gPSBqc29uU3RhdHMuaW5vO1xuICBzdGF0cy5zaXplID0ganNvblN0YXRzLnNpemU7XG4gIHN0YXRzLmJsb2NrcyA9IGpzb25TdGF0cy5ibG9ja3M7XG4gIHN0YXRzLmF0aW1lID0gbmV3IERhdGUoanNvblN0YXRzLmF0aW1lKTtcbiAgc3RhdHMubXRpbWUgPSBuZXcgRGF0ZShqc29uU3RhdHMubXRpbWUpO1xuICBzdGF0cy5jdGltZSA9IG5ldyBEYXRlKGpzb25TdGF0cy5jdGltZSk7XG5cbiAgaWYgKGpzb25TdGF0cy5iaXJ0aHRpbWUpIHtcbiAgICAvLyAkRmxvd0lzc3VlXG4gICAgc3RhdHMuYmlydGh0aW1lID0gbmV3IERhdGUoanNvblN0YXRzLmJpcnRodGltZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdHM7XG59XG5cbi8qXG4gKiBUaGUgVHlwZVJlZ2lzdHJ5IGlzIGEgY2VudHJhbGl6ZWQgcGxhY2UgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIHRoYXQgc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZVxuICogdHlwZXMuIFRoaXMgYWxsb3dzIGZvciB0eXBlcyBkZWZpbmVkIGluIG9uZSBzZXJ2aWNlIHRvIGluY2x1ZGUgdHlwZXMgZnJvbSBhbm90aGVyIHNlcnZpY2UgaW5cbiAqIGFub3RoZXIgZmlsZS4gSXQgYWxzbyBhbGxvd3MgdGhlIGFiaWxpdHkgdG8gYWRkIG5ldyBwcmltaXRpdmVzLCByYW5naW5nIGZyb20gQnVmZmVyIHRvIE51Y2xpZGVVcmlcbiAqIHRoYXQgYXJlIG5vdCBoYW5kbGVkIGF0IHRoZSB0cmFuc3BvcnQgbGF5ZXIuIFRoZSBrZXkgY29uY2VwdCBpcyB0aGF0IG1hcnNoYWxsaW5nIGZ1bmN0aW9ucyBjYW5cbiAqIGJlIHJlY3Vyc2l2ZSwgY2FsbGluZyBvdGhlciBtYXJzaGFsbGluZyBmdW5jdGlvbnMsIGVuZGluZyBhdCB0aGUgcHJpbWl0aXZlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVJlZ2lzdHJ5IHtcbiAgLyoqIFN0b3JlIG1hcmhzYWxsZXJzIGFuZCBhbmQgdW5tYXJzaGFsbGVycywgaW5kZXggYnkgdGhlIGtpbmQgb2YgdGhlIHR5cGUuICovXG4gIF9raW5kTWFyc2hhbGxlcnM6IE1hcDxzdHJpbmcsIHtcbiAgICAgIG1hcnNoYWxsZXI6IFRyYW5zZm9ybWVyO1xuICAgICAgdW5tYXJzaGFsbGVyOiBUcmFuc2Zvcm1lcjtcbiAgICB9PjtcblxuICAvKiogU3RvcmUgbWFyaHNhbGxlcnMgYW5kIGFuZCB1bm1hcnNoYWxsZXJzLCBpbmRleCBieSB0aGUgbmFtZSBvZiB0aGUgdHlwZS4gKi9cbiAgX25hbWVkTWFyc2hhbGxlcnM6IE1hcDxzdHJpbmcsIHtcbiAgICAgIG1hcnNoYWxsZXI6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPGFueT47XG4gICAgICB1bm1hcnNoYWxsZXI6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPGFueT47XG4gICAgfT47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fa2luZE1hcnNoYWxsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX25hbWVkTWFyc2hhbGxlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLl9yZWdpc3RlclByaW1pdGl2ZXMoKTtcbiAgICB0aGlzLl9yZWdpc3RlclNwZWNpYWxUeXBlcygpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQ29udGFpbmVycygpO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGl0ZXJhbHMoKTtcbiAgICB0aGlzLl9yZWdpc3RlclVuaW9ucygpO1xuXG4gICAgLy8gUmVnaXN0ZXIgTnVsbGFibGVUeXBlIGFuZCBOYW1lZFR5cGVcbiAgICB0aGlzLl9yZWdpc3RlcktpbmQoJ251bGxhYmxlJywgYXN5bmMgKHZhbHVlOiBhbnksIHR5cGU6IFR5cGUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUua2luZCAhPT0gJ251bGxhYmxlJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1hcnNoYWwodmFsdWUsIHR5cGUudHlwZSk7XG4gICAgfSwgYXN5bmMgKHZhbHVlOiBhbnksIHR5cGU6IFR5cGUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUua2luZCAhPT0gJ251bGxhYmxlJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVubWFyc2hhbCh2YWx1ZSwgdHlwZS50eXBlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlZ2lzdGVyS2luZCgnbmFtZWQnLCBhc3luYyAodmFsdWU6IGFueSwgdHlwZTogVHlwZSkgPT4ge1xuICAgICAgaW52YXJpYW50KHR5cGUua2luZCA9PT0gJ25hbWVkJyk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVkTWFyc2hhbGxlcnMuaGFzKHR5cGUubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtYXJzaGFsbGVyIGZvdW5kIGZvciBuYW1lZCB0eXBlICR7dHlwZS5uYW1lfS5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9uYW1lZE1hcnNoYWxsZXJzLmdldCh0eXBlLm5hbWUpLm1hcnNoYWxsZXIodmFsdWUpO1xuICAgIH0sIGFzeW5jICh2YWx1ZTogYW55LCB0eXBlOiBUeXBlKSA9PiB7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAnbmFtZWQnKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZWRNYXJzaGFsbGVycy5nZXQodHlwZS5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1hcnNoYWxsZXIgZm91bmQgZm9yIG5hbWVkIHR5cGUgJHt0eXBlLm5hbWV9LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX25hbWVkTWFyc2hhbGxlcnMuZ2V0KHR5cGUubmFtZSkudW5tYXJzaGFsbGVyKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlZ2lzdGVyS2luZChcbiAgICAgICd2b2lkJyxcbiAgICAgICh2YWx1ZSwgdHlwZSkgPT4gUHJvbWlzZS5yZXNvbHZlKG51bGwpLFxuICAgICAgKHZhbHVlLCB0eXBlKSA9PiBQcm9taXNlLnJlc29sdmUobnVsbCkpO1xuICB9XG5cbiAgX3JlZ2lzdGVyS2luZChraW5kOiBzdHJpbmcsIG1hcnNoYWxsZXI6IFRyYW5zZm9ybWVyLCB1bm1hcnNoYWxsZXI6IFRyYW5zZm9ybWVyKTogdm9pZCB7XG4gICAgaW52YXJpYW50KCF0aGlzLl9raW5kTWFyc2hhbGxlcnMuaGFzKGtpbmQpKTtcbiAgICB0aGlzLl9raW5kTWFyc2hhbGxlcnMuc2V0KGtpbmQsIHttYXJzaGFsbGVyLCB1bm1hcnNoYWxsZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHR5cGUgYnkgcHJvdmlkaW5nIGJvdGggYSBtYXJzaGFsbGVyIGFuZCBhbiB1bm1hcnNoYWxsZXIuIFRoZSBtYXJzaGFsbGVyXG4gICAqIHdpbGwgYmUgY2FsbGVkIHRvIHRyYW5zZm9ybSB0aGUgdHlwZSBiZWZvcmUgc2VuZGluZyBpdCBvdXQgb250byB0aGUgbmV0d29yaywgd2hpbGUgdGhlXG4gICAqIHVubWFyc2hhbGxlciB3aWxsIGJlIGNhbGxlZCBvbiB2YWx1ZXMgaW5jb21pbmcgZnJvbSB0aGUgbmV0d29yay5cbiAgICogQHBhcmFtIHR5cGVOYW1lIC0gVGhlIHN0cmluZyBuYW1lIG9mIHRoZSB0eXBlIHRoYXQgdGhlIHByb3ZpZGVkIG1hcnNoYWxsZXJzIGNvbnZlcnQuXG4gICAqIEBwYXJhbSBtYXJzaGFsbGVyIC0gU2VyaWFsaXplIHRoZSB0eXBlLlxuICAgKiBAcGFyYW0gdW5tYXJzaGFsbGVyIC0gRGVzZXJpYWxpemUgdGhlIHR5cGUuXG4gICAqL1xuICByZWdpc3RlclR5cGUodHlwZU5hbWU6IHN0cmluZywgbWFyc2hhbGxlcjogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55PixcbiAgICAgIHVubWFyc2hhbGxlcjogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9uYW1lZE1hcnNoYWxsZXJzLmhhcyh0eXBlTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQSB0eXBlIGJ5IHRoZSBuYW1lICR7dHlwZU5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC5gKTtcbiAgICB9XG4gICAgdGhpcy5fbmFtZWRNYXJzaGFsbGVycy5zZXQodHlwZU5hbWUsIHttYXJzaGFsbGVyLCB1bm1hcnNoYWxsZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIHRoZSBtYXJhc2hhbGxlci91bm1hcnNoYWxsZXIgZm9yIGEgdHlwZSBhbGlhcy5cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYWxpYXMgdHlwZS5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0aGUgdGhlIGFsaWFzIHJlcHJlc2VudHMuXG4gICAqL1xuICByZWdpc3RlckFsaWFzKG5hbWU6IHN0cmluZywgdHlwZTogVHlwZSk6IHZvaWQge1xuICAgIHRoaXMucmVnaXN0ZXJUeXBlKG5hbWUsIHZhbHVlID0+IHRoaXMubWFyc2hhbCh2YWx1ZSwgdHlwZSksXG4gICAgICB2YWx1ZSA9PiB0aGlzLnVubWFyc2hhbCh2YWx1ZSwgdHlwZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcnNoYWwgYW4gb2JqZWN0IHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBtYXJzaGFsIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgbWFyc2hhbGxlZC5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvYmplY3QgKHVzZWQgdG8gZmluZCB0aGUgYXBwcm9wcmlhdGUgZnVuY3Rpb24pLlxuICAgKi9cbiAgbWFyc2hhbCh2YWx1ZTogYW55LCB0eXBlOiBUeXBlKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuX2tpbmRNYXJzaGFsbGVycy5oYXModHlwZS5raW5kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtYXJzaGFsbGVyIGZvdW5kIGZvciB0eXBlIGtpbmQgJHt0eXBlLmtpbmR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2luZE1hcnNoYWxsZXJzLmdldCh0eXBlLmtpbmQpLm1hcnNoYWxsZXIodmFsdWUsIHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubWFyc2hhbCBhbmQgb2JqZWN0IHVzaW5nIHRoZSBhcHByb3ByaWF0ZSB1bm1hcnNoYWwgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBtYXJzaGFsbGVkLlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9iamVjdCAodXNlZCB0byBmaW5kIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvbikuXG4gICAqL1xuICB1bm1hcnNoYWwodmFsdWU6IGFueSwgdHlwZTogVHlwZSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9raW5kTWFyc2hhbGxlcnMuaGFzKHR5cGUua2luZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdW5tYXJzaGFsbGVyIGZvdW5kIGZvciB0eXBlIGtpbmQgJHt0eXBlLmtpbmR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2luZE1hcnNoYWxsZXJzLmdldCh0eXBlLmtpbmQpLnVubWFyc2hhbGxlcih2YWx1ZSwgdHlwZSk7XG4gIH1cblxuICBfcmVnaXN0ZXJQcmltaXRpdmVzKCk6IHZvaWQge1xuICAgIC8vIFNpbmNlIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhbiBhcmUgSlNPTiBwcmltaXRpdmVzLFxuICAgIC8vIHRoZXkgcmVxdWlyZSBubyBtYXJzaGFsbGluZy4gSW5zdGVhZCwgc2ltcGx5IGNyZWF0ZSB3cmFwcGVkIHRyYW5zZm9ybWVyc1xuICAgIC8vIHRoYXQgYXNzZXJ0IHRoZSB0eXBlIG9mIHRoZWlyIGFyZ3VtZW50LlxuICAgIGNvbnN0IHN0cmluZ1RyYW5zZm9ybWVyID0gYXN5bmMgYXJnID0+IHtcbiAgICAgIC8vIFVuYm94IGFyZ3VtZW50LlxuICAgICAgYXJnID0gKGFyZyBpbnN0YW5jZW9mIFN0cmluZykgPyBhcmcudmFsdWVPZigpIDogYXJnO1xuICAgICAgYXNzZXJ0KHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnLCAnRXhwZWN0ZWQgYSBzdHJpbmcgYXJndW1lbnQnKTtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgICBjb25zdCBudW1iZXJUcmFuc2Zvcm1lciA9IGFzeW5jIGFyZyA9PiB7XG4gICAgICAvLyBVbmJveCBhcmd1bWVudC5cbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgYXJnID0gYXJnLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydCh0eXBlb2YgYXJnID09PSAnbnVtYmVyJywgJ0V4cGVjdGVkIGEgbnVtYmVyIGFyZ3VtZW50Jyk7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gICAgY29uc3QgYm9vbGVhblRyYW5zZm9ybWVyID0gYXN5bmMgYXJnID0+IHtcbiAgICAgIC8vIFVuYm94IGFyZ3VtZW50XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICBhcmcgPSBhcmcudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHR5cGVvZiBhcmcgPT09ICdib29sZWFuJywgJ0V4cGVjdGVkIGEgYm9vbGVhbiBhcmd1bWVudCcpO1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICAgIC8vIFdlIGFzc3VtZSBhbiAnYW55JyBhbmQgJ21peGVkJyB0eXBlcyByZXF1aXJlIG5vIG1hcnNoYWxsaW5nLlxuICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtZXIgPSBhc3luYyBhcmcgPT4gYXJnO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlc2UgdHJhbnNmb3JtZXJzXG4gICAgdGhpcy5fcmVnaXN0ZXJLaW5kKCdzdHJpbmcnLCBzdHJpbmdUcmFuc2Zvcm1lciwgc3RyaW5nVHJhbnNmb3JtZXIpO1xuICAgIHRoaXMuX3JlZ2lzdGVyS2luZCgnbnVtYmVyJywgbnVtYmVyVHJhbnNmb3JtZXIsIG51bWJlclRyYW5zZm9ybWVyKTtcbiAgICB0aGlzLl9yZWdpc3RlcktpbmQoJ2Jvb2xlYW4nLCBib29sZWFuVHJhbnNmb3JtZXIsIGJvb2xlYW5UcmFuc2Zvcm1lcik7XG4gICAgdGhpcy5fcmVnaXN0ZXJLaW5kKCdhbnknLCBpZGVudGl0eVRyYW5zZm9ybWVyLCBpZGVudGl0eVRyYW5zZm9ybWVyKTtcbiAgICB0aGlzLl9yZWdpc3RlcktpbmQoJ21peGVkJywgaWRlbnRpdHlUcmFuc2Zvcm1lciwgaWRlbnRpdHlUcmFuc2Zvcm1lcik7XG4gIH1cblxuICBfcmVnaXN0ZXJMaXRlcmFscygpOiB2b2lkIHtcbiAgICBjb25zdCBsaXRlcmFsVHJhbnNmb3JtZXIgPSBhc3luYyAoYXJnLCB0eXBlKSA9PiB7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAnc3RyaW5nLWxpdGVyYWwnIHx8IHR5cGUua2luZCA9PT0gJ251bWJlci1saXRlcmFsJyB8fFxuICAgICAgICAgIHR5cGUua2luZCA9PT0gJ2Jvb2xlYW4tbGl0ZXJhbCcpO1xuICAgICAgaW52YXJpYW50KGFyZyA9PT0gdHlwZS52YWx1ZSk7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gICAgdGhpcy5fcmVnaXN0ZXJLaW5kKCdzdHJpbmctbGl0ZXJhbCcsIGxpdGVyYWxUcmFuc2Zvcm1lciwgbGl0ZXJhbFRyYW5zZm9ybWVyKTtcbiAgICB0aGlzLl9yZWdpc3RlcktpbmQoJ251bWJlci1saXRlcmFsJywgbGl0ZXJhbFRyYW5zZm9ybWVyLCBsaXRlcmFsVHJhbnNmb3JtZXIpO1xuICAgIHRoaXMuX3JlZ2lzdGVyS2luZCgnYm9vbGVhbi1saXRlcmFsJywgbGl0ZXJhbFRyYW5zZm9ybWVyLCBsaXRlcmFsVHJhbnNmb3JtZXIpO1xuICB9XG5cbiAgX3JlZ2lzdGVyVW5pb25zKCk6IHZvaWQge1xuICAgIGNvbnN0IHVuaW9uTGl0ZXJhbFRyYW5zZm9ybWVyID0gYXN5bmMgKGFyZywgdHlwZSkgPT4ge1xuICAgICAgaW52YXJpYW50KHR5cGUua2luZCA9PT0gJ3VuaW9uJyk7XG4gICAgICBjb25zdCBhbHRlcm5hdGUgPSBhcnJheS5maW5kKHR5cGUudHlwZXMsIGVsZW1lbnQgPT4ge1xuICAgICAgICBpbnZhcmlhbnQoZWxlbWVudC5raW5kID09PSAnc3RyaW5nLWxpdGVyYWwnIHx8IGVsZW1lbnQua2luZCA9PT0gJ251bWJlci1saXRlcmFsJ1xuICAgICAgICAgICAgfHwgZWxlbWVudC5raW5kID09PSAnYm9vbGVhbi1saXRlcmFsJyk7XG4gICAgICAgIHJldHVybiAoYXJnID09PSBlbGVtZW50LnZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgaW52YXJpYW50KGFsdGVybmF0ZSk7XG4gICAgICAvLyBUaGlzIGlzIGp1c3QgdGhlIGxpdGVyYWwgdHJhbnNmb3JtZXIgaW5saW5lZCAuLi5cbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgICBjb25zdCB1bmlvbk9iamVjdE1hcnNoYWxsZXIgPSAoYXJnLCB0eXBlKSA9PiB7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAndW5pb24nKTtcbiAgICAgIHJldHVybiB0aGlzLm1hcnNoYWwoYXJnLCBmaW5kQWx0ZXJuYXRlKGFyZywgdHlwZSkpO1xuICAgIH07XG4gICAgY29uc3QgdW5pb25PYmplY3RVbm1hcnNoYWxsZXIgPSAoYXJnLCB0eXBlKSA9PiB7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAndW5pb24nKTtcbiAgICAgIHJldHVybiB0aGlzLnVubWFyc2hhbChhcmcsIGZpbmRBbHRlcm5hdGUoYXJnLCB0eXBlKSk7XG4gICAgfTtcbiAgICBjb25zdCB1bmlvbk1hcnNoYWxsZXIgPSAoYXJnLCB0eXBlKSA9PiB7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAndW5pb24nKTtcbiAgICAgIGlmICh0eXBlLmRpc2NyaW1pbmFudEZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuaW9uT2JqZWN0TWFyc2hhbGxlcihhcmcsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuaW9uTGl0ZXJhbFRyYW5zZm9ybWVyKGFyZywgdHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bmlvblVubWFyc2hhbGxlciA9IChhcmcsIHR5cGUpID0+IHtcbiAgICAgIGludmFyaWFudCh0eXBlLmtpbmQgPT09ICd1bmlvbicpO1xuICAgICAgaWYgKHR5cGUuZGlzY3JpbWluYW50RmllbGQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5pb25PYmplY3RVbm1hcnNoYWxsZXIoYXJnLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmlvbkxpdGVyYWxUcmFuc2Zvcm1lcihhcmcsIHR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fcmVnaXN0ZXJLaW5kKCd1bmlvbicsIHVuaW9uTWFyc2hhbGxlciwgdW5pb25Vbm1hcnNoYWxsZXIpO1xuICB9XG5cbiAgX3JlZ2lzdGVyU3BlY2lhbFR5cGVzKCk6IHZvaWQge1xuICAgIC8vIFNlcmlhbGl6ZSAvIERlc2VyaWFsaXplIGFueSBPYmplY3QgdHlwZVxuICAgIHRoaXMucmVnaXN0ZXJUeXBlKG9iamVjdFR5cGUubmFtZSwgYXN5bmMgb2JqZWN0ID0+IHtcbiAgICAgIGFzc2VydChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JywgJ0V4cGVjdGVkIE9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSwgYXN5bmMgb2JqZWN0ID0+IHtcbiAgICAgIGFzc2VydChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JywgJ0V4cGVjdGVkIE9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvLyBTZXJpYWxpemUgLyBEZXNlcmlhbGl6ZSBKYXZhc2NyaXB0IERhdGUgb2JqZWN0c1xuICAgIHRoaXMucmVnaXN0ZXJUeXBlKGRhdGVUeXBlLm5hbWUsIGFzeW5jIGRhdGUgPT4ge1xuICAgICAgYXNzZXJ0KGRhdGUgaW5zdGFuY2VvZiBEYXRlLCAnRXhwZWN0ZWQgZGF0ZSBhcmd1bWVudC4nKTtcbiAgICAgIHJldHVybiBkYXRlLnRvSlNPTigpO1xuICAgIH0sIGFzeW5jIGRhdGVTdHIgPT4ge1xuICAgICAgLy8gVW5ib3ggYXJndW1lbnQuXG4gICAgICBkYXRlU3RyID0gKGRhdGVTdHIgaW5zdGFuY2VvZiBTdHJpbmcpID8gZGF0ZVN0ci52YWx1ZU9mKCkgOiBkYXRlU3RyO1xuXG4gICAgICBhc3NlcnQodHlwZW9mIGRhdGVTdHIgPT09ICdzdHJpbmcnLCAnRXhwZWNldGVkIGEgc3RyaW5nIGFyZ3VtZW50LicpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgIH0pO1xuXG4gICAgLy8gU2VyaWFsaXplIC8gRGVzZXJpYWxpemUgUmVnRXhwIG9iamVjdHNcbiAgICB0aGlzLnJlZ2lzdGVyVHlwZShyZWdFeHBUeXBlLm5hbWUsIGFzeW5jIHJlZ2V4cCA9PiB7XG4gICAgICBhc3NlcnQocmVnZXhwIGluc3RhbmNlb2YgUmVnRXhwLCAnRXhwZWN0ZWQgYSBSZWdFeHAgb2JqZWN0IGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICByZXR1cm4gcmVnZXhwLnRvU3RyaW5nKCk7XG4gICAgfSwgYXN5bmMgcmVnU3RyID0+IHtcbiAgICAgIC8vIFVuYm94IGFyZ3VtZW50LlxuICAgICAgcmVnU3RyID0gKHJlZ1N0ciBpbnN0YW5jZW9mIFN0cmluZykgPyByZWdTdHIudmFsdWVPZigpIDogcmVnU3RyO1xuXG4gICAgICBhc3NlcnQodHlwZW9mIHJlZ1N0ciA9PT0gJ3N0cmluZycsICdFeHBlY3RlZCBhIHN0cmluZyBhcmd1bWVudC4nKTtcbiAgICAgIC8vICRGbG93SXNzdWUgLSBmbGVzaCBvdXQgdGhlIHZtIG1vZHVsZS5cbiAgICAgIHJldHVybiB2bS5ydW5JblRoaXNDb250ZXh0KHJlZ1N0cik7XG4gICAgfSk7XG5cbiAgICAvLyBTZXJpYWxpemUgLyBEZXNlcmlhbGl6ZSBCdWZmZXIgb2JqZWN0cyB0aHJvdWdoIEJhc2U2NCBzdHJpbmdzXG4gICAgdGhpcy5yZWdpc3RlclR5cGUoYnVmZmVyVHlwZS5uYW1lLCBhc3luYyBidWZmZXIgPT4ge1xuICAgICAgYXNzZXJ0KGJ1ZmZlciBpbnN0YW5jZW9mIEJ1ZmZlciwgJ0V4cGVjdGVkIGEgYnVmZmVyIGFyZ3VtZW50LicpO1xuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSwgYXN5bmMgYmFzZTY0c3RyaW5nID0+IHtcbiAgICAgIC8vIFVuYm94IGFyZ3VtZW50LlxuICAgICAgYmFzZTY0c3RyaW5nID0gKGJhc2U2NHN0cmluZyBpbnN0YW5jZW9mIFN0cmluZykgPyBiYXNlNjRzdHJpbmcudmFsdWVPZigpIDogYmFzZTY0c3RyaW5nO1xuXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiBiYXNlNjRzdHJpbmcgPT09ICdzdHJpbmcnLFxuICAgICAgICBgRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLiBOb3QgJHt0eXBlb2YgYmFzZTY0c3RyaW5nfWApO1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYmFzZTY0c3RyaW5nLCAnYmFzZTY0Jyk7XG4gICAgfSk7XG5cbiAgICAvLyBmcy5TdGF0c1xuICAgIHRoaXMucmVnaXN0ZXJUeXBlKGZzU3RhdHNUeXBlLm5hbWUsIGFzeW5jIHN0YXRzID0+IHtcbiAgICAgIGFzc2VydChzdGF0cyBpbnN0YW5jZW9mIGZzLlN0YXRzKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0c1RvT2JqZWN0KHN0YXRzKSk7XG4gICAgfSwgYXN5bmMganNvbiA9PiB7XG4gICAgICBhc3NlcnQodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKTtcbiAgICAgIHJldHVybiBvYmplY3RUb1N0YXRzKEpTT04ucGFyc2UoanNvbikpO1xuICAgIH0pO1xuICB9XG5cbiAgX3JlZ2lzdGVyQ29udGFpbmVycygpOiB2b2lkIHtcbiAgICAvLyBTZXJpYWxpemUgLyBEZXNlcmlhbGl6ZSBBcnJheXMuXG4gICAgdGhpcy5fcmVnaXN0ZXJLaW5kKCdhcnJheScsIGFzeW5jICh2YWx1ZTogYW55LCB0eXBlOiBUeXBlKSA9PiB7XG4gICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheSwgJ0V4cGVjdGVkIGFuIG9iamVjdCBvZiB0eXBlIEFycmF5LicpO1xuICAgICAgaW52YXJpYW50KHR5cGUua2luZCA9PT0gJ2FycmF5Jyk7XG4gICAgICBjb25zdCBlbGVtVHlwZSA9IHR5cGUudHlwZTtcbiAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoZWxlbSA9PiB0aGlzLm1hcnNoYWwoZWxlbSwgZWxlbVR5cGUpKSk7XG4gICAgfSwgYXN5bmMgKHZhbHVlOiBhbnksIHR5cGU6IFR5cGUpID0+IHtcbiAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5LCAnRXhwZWN0ZWQgYW4gb2JqZWN0IG9mIHR5cGUgQXJyYXkuJyk7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAnYXJyYXknKTtcbiAgICAgIGNvbnN0IGVsZW1UeXBlID0gdHlwZS50eXBlO1xuICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcChlbGVtID0+IHRoaXMudW5tYXJzaGFsKGVsZW0sIGVsZW1UeXBlKSkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2VyaWFsaXplIGFuZCBEZXNlcmlhbGl6ZSBPYmplY3RzLlxuICAgIHRoaXMuX3JlZ2lzdGVyS2luZCgnb2JqZWN0JywgYXN5bmMgKG9iajogYW55LCB0eXBlOiBUeXBlKSA9PiB7XG4gICAgICBhc3NlcnQodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcsICdFeHBlY3RlZCBhbiBhcmd1bWVudCBvZiB0eXBlIG9iamVjdC4nKTtcbiAgICAgIGludmFyaWFudCh0eXBlLmtpbmQgPT09ICdvYmplY3QnKTtcbiAgICAgIGNvbnN0IG5ld09iaiA9IHt9OyAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgb3JpZ2luYWwgb25lLlxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodHlwZS5maWVsZHMubWFwKGFzeW5jIHByb3AgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc291cmNlIG9iamVjdCBoYXMgdGhpcyBrZXkuXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcC5uYW1lKSkge1xuICAgICAgICAgIG5ld09ialtwcm9wLm5hbWVdID0gYXdhaXQgdGhpcy5tYXJzaGFsKG9ialtwcm9wLm5hbWVdLCBwcm9wLnR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBvcHRpb25hbCwgaXQncyBva2F5IGZvciBpdCB0byBiZSBtaXNzaW5nLlxuICAgICAgICAgIGlmICghcHJvcC5vcHRpb25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3VyY2Ugb2JqZWN0IGlzIG1pc3NpbmcgcHJvcGVydHkgJHtwcm9wLm5hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9LCBhc3luYyAob2JqOiBhbnksIHR5cGU6IFR5cGUpID0+IHtcbiAgICAgIGFzc2VydCh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JywgJ0V4cGVjdGVkIGFuIGFyZ3VtZW50IG9mIHR5cGUgb2JqZWN0LicpO1xuICAgICAgaW52YXJpYW50KHR5cGUua2luZCA9PT0gJ29iamVjdCcpO1xuICAgICAgY29uc3QgbmV3T2JqID0ge307IC8vIENyZWF0ZSBhIG5ldyBvYmplY3Qgc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBvbmUuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh0eXBlLmZpZWxkcy5tYXAoYXN5bmMgcHJvcCA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzb3VyY2Ugb2JqZWN0IGhhcyB0aGlzIGtleS5cbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgbmV3T2JqW3Byb3AubmFtZV0gPSBhd2FpdCB0aGlzLnVubWFyc2hhbChvYmpbcHJvcC5uYW1lXSwgcHJvcC50eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgb3B0aW9uYWwsIGl0J3Mgb2theSBmb3IgaXQgdG8gYmUgbWlzc2luZy5cbiAgICAgICAgICBpZiAoIXByb3Aub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIG9iamVjdCBpcyBtaXNzaW5nIHByb3BlcnR5ICR7cHJvcC5uYW1lfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSk7XG5cbiAgICAvLyBTZXJpYWxpemUgLyBEZXNlcmlhbGl6ZSBTZXRzLlxuICAgIHRoaXMuX3JlZ2lzdGVyS2luZCgnc2V0JywgYXN5bmMgKHZhbHVlOiBhbnksIHR5cGU6IFR5cGUpID0+IHtcbiAgICAgIGludmFyaWFudCh0eXBlLmtpbmQgPT09ICdzZXQnKTtcbiAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFNldCwgJ0V4cGVjdGVkIGFuIG9iamVjdCBvZiB0eXBlIFNldC4nKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZVByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgc2VyaWFsaXplUHJvbWlzZXMucHVzaCh0aGlzLm1hcnNoYWwoZWxlbSwgdHlwZS50eXBlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoc2VyaWFsaXplUHJvbWlzZXMpO1xuICAgIH0sIGFzeW5jICh2YWx1ZTogYW55LCB0eXBlOiBUeXBlKSA9PiB7XG4gICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheSwgJ0V4cGVjdGVkIGFuIG9iamVjdCBvZiB0eXBlIEFycmF5LicpO1xuICAgICAgaW52YXJpYW50KHR5cGUua2luZCA9PT0gJ3NldCcpO1xuICAgICAgY29uc3QgZWxlbVR5cGUgPSB0eXBlLnR5cGU7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcChlbGVtID0+IHRoaXMudW5tYXJzaGFsKGVsZW0sIGVsZW1UeXBlKSkpO1xuICAgICAgcmV0dXJuIG5ldyBTZXQoZWxlbWVudHMpO1xuICAgIH0pO1xuXG4gICAgLy8gU2VyaWFsaXplIC8gRGVzZXJpYWxpemUgTWFwcy5cbiAgICB0aGlzLl9yZWdpc3RlcktpbmQoJ21hcCcsIGFzeW5jIChtYXA6IE1hcCwgdHlwZTogVHlwZSkgPT4ge1xuICAgICAgYXNzZXJ0KG1hcCBpbnN0YW5jZW9mIE1hcCwgJ0V4cGVjdGVkIGFuIG9iamVjdCBvZiB0eXBlIFNldC4nKTtcbiAgICAgIGludmFyaWFudCh0eXBlLmtpbmQgPT09ICdtYXAnKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZVByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICAgICAgc2VyaWFsaXplUHJvbWlzZXMucHVzaChQcm9taXNlLmFsbChbXG4gICAgICAgICAgdGhpcy5tYXJzaGFsKGtleSwgdHlwZS5rZXlUeXBlKSxcbiAgICAgICAgICB0aGlzLm1hcnNoYWwodmFsdWUsIHR5cGUudmFsdWVUeXBlKSxcbiAgICAgICAgXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHNlcmlhbGl6ZVByb21pc2VzKTtcbiAgICB9LCBhc3luYyAoc2VyaWFsaXplZDogYW55LCB0eXBlOiBUeXBlKSA9PiB7XG4gICAgICBhc3NlcnQoc2VyaWFsaXplZCBpbnN0YW5jZW9mIEFycmF5LCAnRXhwZWN0ZWQgYW4gb2JqZWN0IG9mIHR5cGUgQXJyYXkuJyk7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAnbWFwJyk7XG4gICAgICBjb25zdCBrZXlUeXBlID0gdHlwZS5rZXlUeXBlO1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZS52YWx1ZVR5cGU7XG4gICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHNlcmlhbGl6ZWQubWFwKGVudHJ5ID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgICB0aGlzLnVubWFyc2hhbChlbnRyeVswXSwga2V5VHlwZSksXG4gICAgICAgICAgdGhpcy51bm1hcnNoYWwoZW50cnlbMV0sIHZhbHVlVHlwZSksXG4gICAgICAgIF0pKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgTWFwKGVudHJpZXMpO1xuICAgIH0pO1xuXG4gICAgLy8gU2VyaWFsaXplIC8gRGVzZXJpYWxpemUgVHVwbGVzLlxuICAgIHRoaXMuX3JlZ2lzdGVyS2luZCgndHVwbGUnLCBhc3luYyAodmFsdWU6IGFueSwgdHlwZTogVHlwZSkgPT4ge1xuICAgICAgLy8gQXNzZXJ0IHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpLCAnRXhwZWN0ZWQgYW4gb2JqZWN0IG9mIHR5cGUgQXJyYXkuJyk7XG4gICAgICBpbnZhcmlhbnQodHlwZS5raW5kID09PSAndHVwbGUnKTtcbiAgICAgIGNvbnN0IHR5cGVzID0gdHlwZS50eXBlcztcbiAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IHR5cGVzLmxlbmd0aCwgYEV4cGVjdGVkIHR1cGxlIG9mIGxlbmd0aCAke3R5cGVzLmxlbmd0aH0uYCk7XG5cbiAgICAgIC8vIENvbnZlcnQgYWxsIG9mIHRoZSBlbGVtZW50cyB0aHJvdWdoIHRoZSBjb3JyZWN0IG1hcnNoYWxsZXIuXG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwodmFsdWUubWFwKChlbGVtLCBpKSA9PlxuICAgICAgICB0aGlzLm1hcnNoYWwoZWxlbSwgdHlwZXNbaV0pKSk7XG4gICAgfSwgYXN5bmMgKHZhbHVlOiBhbnksIHR5cGU6IFR5cGUpID0+IHtcbiAgICAgIC8vIEFzc2VydCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSwgJ0V4cGVjdGVkIGFuIG9iamVjdCBvZiB0eXBlIEFycmF5LicpO1xuICAgICAgaW52YXJpYW50KHR5cGUua2luZCA9PT0gJ3R1cGxlJyk7XG4gICAgICBjb25zdCB0eXBlcyA9IHR5cGUudHlwZXM7XG4gICAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSB0eXBlcy5sZW5ndGgsIGBFeHBlY3RlZCB0dXBsZSBvZiBsZW5ndGggJHt0eXBlcy5sZW5ndGh9LmApO1xuXG4gICAgICAvLyBDb252ZXJ0IGFsbCBvZiB0aGUgZWxlbWVudHMgdGhyb3VnaCB0aGUgY29ycmVjdCB1bm1hcnNoYWxsZXIuXG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwodmFsdWUubWFwKChlbGVtLCBpKSA9PlxuICAgICAgICB0aGlzLnVubWFyc2hhbChlbGVtLCB0eXBlc1tpXSkpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPYmplY3RGaWVsZEJ5TmFtZSh0eXBlOiBPYmplY3RUeXBlLCBmaWVsZE5hbWU6IHN0cmluZyk6IE9iamVjdEZpZWxkIHtcbiAgY29uc3QgcmVzdWx0ID0gYXJyYXkuZmluZCh0eXBlLmZpZWxkcywgZmllbGQgPT4gZmllbGQubmFtZSA9PT0gZmllbGROYW1lKTtcbiAgaW52YXJpYW50KHJlc3VsdCAhPSBudWxsKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZEFsdGVybmF0ZShhcmc6IE9iamVjdCwgdHlwZTogVW5pb25UeXBlKTogT2JqZWN0VHlwZSB7XG4gIGNvbnN0IGRpc2NyaW1pbmFudEZpZWxkID0gdHlwZS5kaXNjcmltaW5hbnRGaWVsZDtcbiAgaW52YXJpYW50KGRpc2NyaW1pbmFudEZpZWxkICE9IG51bGwpO1xuICBjb25zdCBkaXNjcmltaW5hbnQgPSBhcmdbZGlzY3JpbWluYW50RmllbGRdO1xuICBpbnZhcmlhbnQoZGlzY3JpbWluYW50ICE9IG51bGwpO1xuICBjb25zdCBhbHRlcm5hdGVzOiBBcnJheTxPYmplY3RUeXBlPiA9ICh0eXBlLnR5cGVzOiBhbnkpO1xuICBjb25zdCByZXN1bHQgPSBhcnJheS5maW5kKGFsdGVybmF0ZXMsIGFsdGVybmF0ZSA9PiB7XG4gICAgaW52YXJpYW50KGFsdGVybmF0ZS5raW5kID09PSAnb2JqZWN0Jyk7XG4gICAgY29uc3QgYWx0ZXJuYXRlVHlwZSA9IGdldE9iamVjdEZpZWxkQnlOYW1lKGFsdGVybmF0ZSwgZGlzY3JpbWluYW50RmllbGQpLnR5cGU7XG4gICAgaW52YXJpYW50KGFsdGVybmF0ZVR5cGUua2luZCA9PT0gJ3N0cmluZy1saXRlcmFsJyB8fCBhbHRlcm5hdGVUeXBlLmtpbmQgPT09ICdudW1iZXItbGl0ZXJhbCdcbiAgICAgICAgfHwgYWx0ZXJuYXRlVHlwZS5raW5kID09PSAnYm9vbGVhbi1saXRlcmFsJyk7XG4gICAgcmV0dXJuIGFsdGVybmF0ZVR5cGUudmFsdWUgPT09IGRpc2NyaW1pbmFudDtcbiAgfSk7XG4gIGludmFyaWFudChyZXN1bHQgIT0gbnVsbCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=
