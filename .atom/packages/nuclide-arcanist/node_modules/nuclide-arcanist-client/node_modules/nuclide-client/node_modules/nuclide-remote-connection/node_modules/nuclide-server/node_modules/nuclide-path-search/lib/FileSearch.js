Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

/**
 * FileSearch is an object with a query() method. Currently, this is visible only for testing.
 * @param directoryUri The directory to get the FileSearch for.
 * @param pathSetUpdater Exposed for testing purposes. The pathSetUpdater to use
 *   in this method--likely a mock.
 */

var fileSearchForDirectory = _asyncToGenerator(function* (directoryUri, pathSetUpdater) {
  var fileSearch = fileSearchForDirectoryUri[directoryUri];
  if (fileSearch) {
    return fileSearch;
  }

  var realpath = yield _nuclideCommons.fsPromise.realpath((0, _nuclideRemoteUri.parse)(directoryUri).path);
  var pathSet = yield (0, _PathSetFactory.createPathSet)(realpath);

  var thisPathSetUpdater = pathSetUpdater || getPathSetUpdater();
  yield thisPathSetUpdater.startUpdatingPathSet(pathSet, realpath);

  // TODO: Stop updating the pathSet when the fileSearch is torn down. But
  // currently the fileSearch is never torn down.

  var pathSearch = new _PathSearch2['default'](pathSet);
  fileSearch = new FileSearch(realpath, directoryUri, pathSearch);
  fileSearchForDirectoryUri[directoryUri] = fileSearch;
  return fileSearch;
});

exports.fileSearchForDirectory = fileSearchForDirectory;

// The return values of the following functions must be JSON-serializable so they
// can be sent across a process boundary.

var initFileSearchForDirectory = _asyncToGenerator(function* (directoryUri) {
  yield fileSearchForDirectory(directoryUri);
});

exports.initFileSearchForDirectory = initFileSearchForDirectory;

var doSearch = _asyncToGenerator(function* (directoryUri, query) {
  var fileSearch = yield fileSearchForDirectory(directoryUri);
  return fileSearch.query(query);
});

exports.doSearch = doSearch;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _urlJoin = require('url-join');

var _urlJoin2 = _interopRequireDefault(_urlJoin);

var _nuclideRemoteUri = require('nuclide-remote-uri');

var _nuclideCommons = require('nuclide-commons');

var _PathSetFactory = require('./PathSetFactory');

var _PathSearch = require('./PathSearch');

var _PathSearch2 = _interopRequireDefault(_PathSearch);

var _PathSetUpdater = require('./PathSetUpdater');

var _PathSetUpdater2 = _interopRequireDefault(_PathSetUpdater);

'use babel';

/**
 * Utility to search the set of files under `localDirectory`. It attempts to use
 * source control to populate the search space quickly, as well as to exclude
 * source control metadata files from search.
 *
 * @param localDirectory the directory whose files should be searched
 * @param fullUri is the original path provided to `fileSearchForDirectory`,
 *     which is prepended to all results.
 * @param pathSearch delegate to use for the actual searching.
 */

var FileSearch = (function () {
  function FileSearch(localDirectory, fullUri, pathSearch) {
    _classCallCheck(this, FileSearch);

    this._localDirectory = localDirectory;
    this._originalUri = fullUri;
    this._pathSearch = pathSearch;
  }

  _createClass(FileSearch, [{
    key: 'query',
    value: _asyncToGenerator(function* (_query) {
      var _this = this;

      var resultSet = yield this._pathSearch.doQuery(_query);
      // TODO: Cache the result of this call to map().
      var results = resultSet.results.map(function (result) {
        var mappedResult = {
          score: result.score,
          path: (0, _urlJoin2['default'])(_this._originalUri, '/', result.value),
          matchIndexes: []
        };
        if (result.matchIndexes) {
          mappedResult.matchIndexes = result.matchIndexes.map(function (index) {
            return index + _this._originalUri.length + 1;
          });
        }
        return mappedResult;
      });
      return results;
    })
  }, {
    key: 'getLocalDirectory',
    value: function getLocalDirectory() {
      return this._localDirectory;
    }
  }, {
    key: 'getFullBaseUri',
    value: function getFullBaseUri() {
      return this._originalUri;
    }
  }]);

  return FileSearch;
})();

var fileSearchForDirectoryUri = {};

var pathSetUpdater = undefined;

function getPathSetUpdater() {
  if (!pathSetUpdater) {
    pathSetUpdater = new _PathSetUpdater2['default']();
  }
  return pathSetUpdater;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXBhdGgtc2VhcmNoL2xpYi9GaWxlU2VhcmNoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7SUFrRnNCLHNCQUFzQixxQkFBckMsV0FDTCxZQUFvQixFQUNwQixjQUErQixFQUNWO0FBQ3JCLE1BQUksVUFBVSxHQUFHLHlCQUF5QixDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3pELE1BQUksVUFBVSxFQUFFO0FBQ2QsV0FBTyxVQUFVLENBQUM7R0FDbkI7O0FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxnQkE3RWpCLFNBQVMsQ0E2RWtCLFFBQVEsQ0FBQyxzQkE5RXBDLEtBQUssRUE4RXFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BFLE1BQU0sT0FBTyxHQUFHLE1BQU0sb0JBNUVoQixhQUFhLEVBNEVpQixRQUFRLENBQUMsQ0FBQzs7QUFFOUMsTUFBTSxrQkFBa0IsR0FBRyxjQUFjLElBQUksaUJBQWlCLEVBQUUsQ0FBQztBQUNqRSxRQUFNLGtCQUFrQixDQUFDLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQzs7Ozs7QUFLakUsTUFBTSxVQUFVLEdBQUcsNEJBQWUsT0FBTyxDQUFDLENBQUM7QUFDM0MsWUFBVSxHQUFHLElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRSxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDaEUsMkJBQXlCLENBQUMsWUFBWSxDQUFDLEdBQUcsVUFBVSxDQUFDO0FBQ3JELFNBQU8sVUFBVSxDQUFDO0NBQ25COzs7Ozs7O0lBY3FCLDBCQUEwQixxQkFBekMsV0FBMEMsWUFBb0IsRUFBaUI7QUFDcEYsUUFBTSxzQkFBc0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztDQUM1Qzs7OztJQUVxQixRQUFRLHFCQUF2QixXQUNMLFlBQW9CLEVBQ3BCLEtBQWEsRUFDcUI7QUFDbEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxzQkFBc0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUM5RCxTQUFPLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFySG1CLFVBQVU7Ozs7Z0NBRVYsb0JBQW9COzs4QkFDaEIsaUJBQWlCOzs4QkFFYixrQkFBa0I7OzBCQUN2QixjQUFjOzs7OzhCQUNWLGtCQUFrQjs7OztBQWxCN0MsV0FBVyxDQUFDOzs7Ozs7Ozs7Ozs7O0lBb0NOLFVBQVU7QUFLSCxXQUxQLFVBQVUsQ0FLRixjQUFzQixFQUFFLE9BQWUsRUFBRSxVQUFzQixFQUFFOzBCQUx6RSxVQUFVOztBQU1aLFFBQUksQ0FBQyxlQUFlLEdBQUcsY0FBYyxDQUFDO0FBQ3RDLFFBQUksQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDO0FBQzVCLFFBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDO0dBQy9COztlQVRHLFVBQVU7OzZCQVdILFdBQUMsTUFBYSxFQUFvQzs7O0FBQzNELFVBQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsTUFBSyxDQUFDLENBQUM7O0FBRXhELFVBQU0sT0FBZ0MsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFBLE1BQU0sRUFBSTtBQUN2RSxZQUFNLFlBQVksR0FBRztBQUNuQixlQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUs7QUFDbkIsY0FBSSxFQUFFLDBCQUFRLE1BQUssWUFBWSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQ25ELHNCQUFZLEVBQUUsRUFBRTtTQUNqQixDQUFDO0FBQ0YsWUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFO0FBQ3ZCLHNCQUFZLENBQUMsWUFBWSxHQUN2QixNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxVQUFDLEtBQUs7bUJBQUssS0FBSyxHQUFHLE1BQUssWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDO1dBQUEsQ0FBQyxDQUFDO1NBQzVFO0FBQ0QsZUFBTyxZQUFZLENBQUM7T0FDckIsQ0FBQyxDQUFDO0FBQ0gsYUFBTyxPQUFPLENBQUM7S0FDaEI7OztXQUVnQiw2QkFBVztBQUMxQixhQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7S0FDN0I7OztXQUVhLDBCQUFXO0FBQ3ZCLGFBQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztLQUMxQjs7O1NBbkNHLFVBQVU7OztBQXNDaEIsSUFBTSx5QkFBeUIsR0FBRyxFQUFFLENBQUM7O0FBZ0NyQyxJQUFJLGNBQWMsWUFBQSxDQUFDOztBQUVuQixTQUFTLGlCQUFpQixHQUFHO0FBQzNCLE1BQUksQ0FBQyxjQUFjLEVBQUU7QUFDbkIsa0JBQWMsR0FBRyxpQ0FBb0IsQ0FBQztHQUN2QztBQUNELFNBQU8sY0FBYyxDQUFDO0NBQ3ZCIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXBhdGgtc2VhcmNoL2xpYi9GaWxlU2VhcmNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHVybEpvaW4gZnJvbSAndXJsLWpvaW4nO1xuXG5pbXBvcnQge3BhcnNlfSBmcm9tICdudWNsaWRlLXJlbW90ZS11cmknO1xuaW1wb3J0IHtmc1Byb21pc2V9IGZyb20gJ251Y2xpZGUtY29tbW9ucyc7XG5cbmltcG9ydCB7Y3JlYXRlUGF0aFNldH0gZnJvbSAnLi9QYXRoU2V0RmFjdG9yeSc7XG5pbXBvcnQgUGF0aFNlYXJjaCBmcm9tICcuL1BhdGhTZWFyY2gnO1xuaW1wb3J0IFBhdGhTZXRVcGRhdGVyIGZyb20gJy4vUGF0aFNldFVwZGF0ZXInO1xuXG5leHBvcnQgdHlwZSBGaWxlU2VhcmNoUmVzdWx0ID0ge1xuICBzY29yZTogbnVtYmVyO1xuICBwYXRoOiBzdHJpbmc7XG4gIG1hdGNoSW5kZXhlczogQXJyYXk8bnVtYmVyPjtcbn07XG5cbi8qKlxuICogVXRpbGl0eSB0byBzZWFyY2ggdGhlIHNldCBvZiBmaWxlcyB1bmRlciBgbG9jYWxEaXJlY3RvcnlgLiBJdCBhdHRlbXB0cyB0byB1c2VcbiAqIHNvdXJjZSBjb250cm9sIHRvIHBvcHVsYXRlIHRoZSBzZWFyY2ggc3BhY2UgcXVpY2tseSwgYXMgd2VsbCBhcyB0byBleGNsdWRlXG4gKiBzb3VyY2UgY29udHJvbCBtZXRhZGF0YSBmaWxlcyBmcm9tIHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gbG9jYWxEaXJlY3RvcnkgdGhlIGRpcmVjdG9yeSB3aG9zZSBmaWxlcyBzaG91bGQgYmUgc2VhcmNoZWRcbiAqIEBwYXJhbSBmdWxsVXJpIGlzIHRoZSBvcmlnaW5hbCBwYXRoIHByb3ZpZGVkIHRvIGBmaWxlU2VhcmNoRm9yRGlyZWN0b3J5YCxcbiAqICAgICB3aGljaCBpcyBwcmVwZW5kZWQgdG8gYWxsIHJlc3VsdHMuXG4gKiBAcGFyYW0gcGF0aFNlYXJjaCBkZWxlZ2F0ZSB0byB1c2UgZm9yIHRoZSBhY3R1YWwgc2VhcmNoaW5nLlxuICovXG5jbGFzcyBGaWxlU2VhcmNoIHtcbiAgX2xvY2FsRGlyZWN0b3J5OiBzdHJpbmc7XG4gIF9vcmlnaW5hbFVyaTogc3RyaW5nO1xuICBfcGF0aFNlYXJjaDogUGF0aFNlYXJjaDtcblxuICBjb25zdHJ1Y3Rvcihsb2NhbERpcmVjdG9yeTogc3RyaW5nLCBmdWxsVXJpOiBzdHJpbmcsIHBhdGhTZWFyY2g6IFBhdGhTZWFyY2gpIHtcbiAgICB0aGlzLl9sb2NhbERpcmVjdG9yeSA9IGxvY2FsRGlyZWN0b3J5O1xuICAgIHRoaXMuX29yaWdpbmFsVXJpID0gZnVsbFVyaTtcbiAgICB0aGlzLl9wYXRoU2VhcmNoID0gcGF0aFNlYXJjaDtcbiAgfVxuXG4gIGFzeW5jIHF1ZXJ5KHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PEZpbGVTZWFyY2hSZXN1bHQ+PiB7XG4gICAgY29uc3QgcmVzdWx0U2V0ID0gYXdhaXQgdGhpcy5fcGF0aFNlYXJjaC5kb1F1ZXJ5KHF1ZXJ5KTtcbiAgICAvLyBUT0RPOiBDYWNoZSB0aGUgcmVzdWx0IG9mIHRoaXMgY2FsbCB0byBtYXAoKS5cbiAgICBjb25zdCByZXN1bHRzOiBBcnJheTxGaWxlU2VhcmNoUmVzdWx0PiA9IHJlc3VsdFNldC5yZXN1bHRzLm1hcChyZXN1bHQgPT4ge1xuICAgICAgY29uc3QgbWFwcGVkUmVzdWx0ID0ge1xuICAgICAgICBzY29yZTogcmVzdWx0LnNjb3JlLFxuICAgICAgICBwYXRoOiB1cmxKb2luKHRoaXMuX29yaWdpbmFsVXJpLCAnLycsIHJlc3VsdC52YWx1ZSksXG4gICAgICAgIG1hdGNoSW5kZXhlczogW10sXG4gICAgICB9O1xuICAgICAgaWYgKHJlc3VsdC5tYXRjaEluZGV4ZXMpIHtcbiAgICAgICAgbWFwcGVkUmVzdWx0Lm1hdGNoSW5kZXhlcyA9XG4gICAgICAgICAgcmVzdWx0Lm1hdGNoSW5kZXhlcy5tYXAoKGluZGV4KSA9PiBpbmRleCArIHRoaXMuX29yaWdpbmFsVXJpLmxlbmd0aCArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZFJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGdldExvY2FsRGlyZWN0b3J5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsRGlyZWN0b3J5O1xuICB9XG5cbiAgZ2V0RnVsbEJhc2VVcmkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxVcmk7XG4gIH1cbn1cblxuY29uc3QgZmlsZVNlYXJjaEZvckRpcmVjdG9yeVVyaSA9IHt9O1xuXG4vKipcbiAqIEZpbGVTZWFyY2ggaXMgYW4gb2JqZWN0IHdpdGggYSBxdWVyeSgpIG1ldGhvZC4gQ3VycmVudGx5LCB0aGlzIGlzIHZpc2libGUgb25seSBmb3IgdGVzdGluZy5cbiAqIEBwYXJhbSBkaXJlY3RvcnlVcmkgVGhlIGRpcmVjdG9yeSB0byBnZXQgdGhlIEZpbGVTZWFyY2ggZm9yLlxuICogQHBhcmFtIHBhdGhTZXRVcGRhdGVyIEV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuIFRoZSBwYXRoU2V0VXBkYXRlciB0byB1c2VcbiAqICAgaW4gdGhpcyBtZXRob2QtLWxpa2VseSBhIG1vY2suXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaWxlU2VhcmNoRm9yRGlyZWN0b3J5KFxuICBkaXJlY3RvcnlVcmk6IHN0cmluZyxcbiAgcGF0aFNldFVwZGF0ZXI6ID9QYXRoU2V0VXBkYXRlcixcbik6IFByb21pc2U8RmlsZVNlYXJjaD4ge1xuICBsZXQgZmlsZVNlYXJjaCA9IGZpbGVTZWFyY2hGb3JEaXJlY3RvcnlVcmlbZGlyZWN0b3J5VXJpXTtcbiAgaWYgKGZpbGVTZWFyY2gpIHtcbiAgICByZXR1cm4gZmlsZVNlYXJjaDtcbiAgfVxuXG4gIGNvbnN0IHJlYWxwYXRoID0gYXdhaXQgZnNQcm9taXNlLnJlYWxwYXRoKHBhcnNlKGRpcmVjdG9yeVVyaSkucGF0aCk7XG4gIGNvbnN0IHBhdGhTZXQgPSBhd2FpdCBjcmVhdGVQYXRoU2V0KHJlYWxwYXRoKTtcblxuICBjb25zdCB0aGlzUGF0aFNldFVwZGF0ZXIgPSBwYXRoU2V0VXBkYXRlciB8fCBnZXRQYXRoU2V0VXBkYXRlcigpO1xuICBhd2FpdCB0aGlzUGF0aFNldFVwZGF0ZXIuc3RhcnRVcGRhdGluZ1BhdGhTZXQocGF0aFNldCwgcmVhbHBhdGgpO1xuXG4gIC8vIFRPRE86IFN0b3AgdXBkYXRpbmcgdGhlIHBhdGhTZXQgd2hlbiB0aGUgZmlsZVNlYXJjaCBpcyB0b3JuIGRvd24uIEJ1dFxuICAvLyBjdXJyZW50bHkgdGhlIGZpbGVTZWFyY2ggaXMgbmV2ZXIgdG9ybiBkb3duLlxuXG4gIGNvbnN0IHBhdGhTZWFyY2ggPSBuZXcgUGF0aFNlYXJjaChwYXRoU2V0KTtcbiAgZmlsZVNlYXJjaCA9IG5ldyBGaWxlU2VhcmNoKHJlYWxwYXRoLCBkaXJlY3RvcnlVcmksIHBhdGhTZWFyY2gpO1xuICBmaWxlU2VhcmNoRm9yRGlyZWN0b3J5VXJpW2RpcmVjdG9yeVVyaV0gPSBmaWxlU2VhcmNoO1xuICByZXR1cm4gZmlsZVNlYXJjaDtcbn1cblxubGV0IHBhdGhTZXRVcGRhdGVyO1xuXG5mdW5jdGlvbiBnZXRQYXRoU2V0VXBkYXRlcigpIHtcbiAgaWYgKCFwYXRoU2V0VXBkYXRlcikge1xuICAgIHBhdGhTZXRVcGRhdGVyID0gbmV3IFBhdGhTZXRVcGRhdGVyKCk7XG4gIH1cbiAgcmV0dXJuIHBhdGhTZXRVcGRhdGVyO1xufVxuXG4vLyBUaGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IGJlIEpTT04tc2VyaWFsaXphYmxlIHNvIHRoZXlcbi8vIGNhbiBiZSBzZW50IGFjcm9zcyBhIHByb2Nlc3MgYm91bmRhcnkuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0RmlsZVNlYXJjaEZvckRpcmVjdG9yeShkaXJlY3RvcnlVcmk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBmaWxlU2VhcmNoRm9yRGlyZWN0b3J5KGRpcmVjdG9yeVVyaSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkb1NlYXJjaChcbiAgZGlyZWN0b3J5VXJpOiBzdHJpbmcsXG4gIHF1ZXJ5OiBzdHJpbmcsXG4pOiBQcm9taXNlPEFycmF5PEZpbGVTZWFyY2hSZXN1bHQ+PiB7XG4gIGNvbnN0IGZpbGVTZWFyY2ggPSBhd2FpdCBmaWxlU2VhcmNoRm9yRGlyZWN0b3J5KGRpcmVjdG9yeVVyaSk7XG4gIHJldHVybiBmaWxlU2VhcmNoLnF1ZXJ5KHF1ZXJ5KTtcbn1cbiJdfQ==
