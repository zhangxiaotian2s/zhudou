Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = createServiceTransformer;

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/*
 * Babel's plugin who auto generate remote service implementation based on service definition class.
 * If the method name starts with 'on' (assuming a camel-cased method), we will generate the event
 * registration method, otherwise, rpc call method will be generated.
 *
 * It is common that a remote service api take a file path as parameter or return a file path as
 * result. However, the same path has different forms locally and remotely.
 * In client a remote file's uri is in form of 'nuclide://$host:$port/$path', while in the server
 * we only need $path.
 *
 * To address this problem, we support flow type `NuclideUri` for parameter and
 * `Promise<NuclideUri>` for return value in RPC method definition:
 *   a) If a parameter is typed as `NuclideUri`, the generated method in remote service assumes
 *      the parameter is a remote file uri ('nuclide://$host:$post/$path'). So it parses the
 *      parameter and calls to rpc with the parsed path.
 *   b) If the return value is typed as `Promise<NuclideUri>`, the generated method treats result
 *      from rpc call as a path. It assembles the path with remote host/port to a remote file uri
 *      and return the uri to caller.
 *   c) For event method definition, if the callback's parameter is typed as `NuclideUri`, the
 *      generated method assembles the parameter with remote host/port information as well.
 *   d) We also support nested flow type definition for parameter and return value like
 *      `Array<NuclideUri>` or `{file: NuclideUri, sizeInByte: number}` etc, as it will be properly
 *      transformed. For more information, please read comments in 'nuclide-uri-transformer.js'.
 *
 * As an example, for a service definition:
 *
 * ```
 *  class TestService {
 *    getStatus(includeIgnored: boolean): Promise<any> {
 *      return Promise.reject('not implemented');
 *    }
 *
 *    getFileStatus(fileUri: NuclideUri): Promise<any> {
 *      return Promise.reject('not implemented');
 *    }
 *
 *    getLastOpenedFile(): Promise<NucideUri> {
 *      return Promise.reject('not implemented');
 *    }
 *
 *    onFileChanged(callback: (payload: any) => void): Disposable {
 *      return Promise.reject('not implemented');
 *    }
 *  }
 *
 * module.exports = TestService;
 * ```
 *
 * it will generate following code:
 *
 * ```
 *  var TestService = require(...);
 *
 *  // Auto-generated: DO NOT MODIFY.
 *
 *  class RemoteTestService extends TestService {
 *    constructor(connection, options) {
 *      super();
 *      this._connection = connection;
 *      this._options = options;
 *    }
 *    getStatus(includeIgnored) {
 *      return this._connection.makeRpc('TestService/getStatus', [includeIgnored], this._options);
 *    }
 *    getFileStatus(fileUri) {
 *      fileUri = this._connection.getPathOfUri(fileUri);
 *      return this._connection.makeRpc('TestService/getFileStatus', [fileUri], this._options);
 *    }
 *    getLastOpenedFile() {
 *      return this._connection.makeRpc('TestService/getLastOpenedFile', [], this._options)
 *        .then(arg0 => {
 *          arg0 = this._connection.getUriOfRemotePath(arg0);
 *          return arg0;
 *        });
 *    }
 *    onFileChanged(callback) {
 *      return this._connection.registerEventListener(
 *        'TestService/onFileChanged',
 *        callback,
 *        this._options,
 *      );
 *    }
 *  }
 *
 * module.exports = RemoteTestService;
 * ```
 */

var _classPrefix = require('./class-prefix');

'use babel';

var _require = require('babel-core');

var Transformer = _require.Transformer;

var t = require('babel-core').types;

var _require2 = require('./method-name-parser');

var isEventMethodName = _require2.isEventMethodName;

var _require3 = require('./flow-annotation');

var isGenericFlowTypeAnnotation = _require3.isGenericFlowTypeAnnotation;

var _require4 = require('./nuclide-uri-transformer');

var createGetUriOfRemotePathAssignmentExpression = _require4.createGetUriOfRemotePathAssignmentExpression;
var createGetPathOfUriAssignmentExpression = _require4.createGetPathOfUriAssignmentExpression;

/**
 * Create ast expression of `var $baseClassName = require('$baseClassFilePath')
 * .$baseClassName || require('$baseClassFilePath');`.
 */
function createBaseClassRequireExpression(baseClassName, baseClassFilePath) {
  // Create a require expression that loads the file of the service definition.
  var requireExpression = t.callExpression(t.identifier('require'), [t.literal(baseClassFilePath)]);
  // First try to access the service as a property of the module - if not,
  // the service is the module itself.
  var orExpression = t.binaryExpression('||', t.memberExpression(requireExpression, t.identifier(baseClassName)), requireExpression);

  return t.variableDeclaration(
  /* kind */'var',
  /* declarations */[t.variableDeclarator(
  /* id */t.identifier(baseClassName),
  /* init */orExpression)]);
}

/**
 * Create ast expression of `var analytics = require('nuclide-analytics');`.
 */
function createAnalyticsRequireExpression() {
  return t.variableDeclaration(
  /* kind */'var',
  /* declarations */[t.variableDeclarator(
  /* id */t.identifier('analytics'),
  /* init */t.callExpression(
  /* callee */t.identifier('require'),
  /* arguments */[t.literal('nuclide-analytics')]))]);
}

function createRemoteClassDeclaration(classDeclaration, isDecorator) {
  var remoteMethodDefinitions = classDeclaration.body.body.map(function (bodyPart) {
    // Create remote method definition for each class method. The part type must be checked because
    // ES7 class properties are also part of the `body` array and have type `ClassProperty`.
    if (bodyPart.type === 'MethodDefinition') {
      if (isEventMethodName(bodyPart.key.name) && !isDecorator) {
        return createRemoteEventMethodDefinition(classDeclaration, bodyPart);
      } else {
        return createRemoteRpcMethodDefinition(classDeclaration, bodyPart, isDecorator);
      }
    }
  });

  var classPrefix = (0, _classPrefix.getClassPrefix)(isDecorator);
  var remoteClassDeclaration = t.classDeclaration(
  /* id */t.identifier(classPrefix + classDeclaration.id.name),
  /* body */t.classBody([createConstructorDefinition(isDecorator)].concat(remoteMethodDefinitions)),
  /* superClass */classDeclaration.id);

  // There is no such function to create comment node in babel, so use following
  // hack to walk around for now.
  remoteClassDeclaration.leadingComments = [{
    type: 'Line',
    value: ' Auto-generated: DO NOT MODIFY.'
  }];

  return remoteClassDeclaration;
}

function createConstructorDefinition(isDecorator) {
  var constructorFunctionExpression = undefined;
  if (isDecorator) {
    constructorFunctionExpression = t.functionExpression(
    /* id */null,
    /* params */[t.identifier('delegate'), t.identifier('serviceLogger')],
    /* body */t.blockStatement([
    // AST node of `super()`.
    t.expressionStatement(t.callExpression( /* callee */t['super'](), /* arguments */[])),
    // AST node of `this._delegate = delegate`.
    t.expressionStatement(t.assignmentExpression(
    /* operator */'=',
    /* left */t.memberExpression(t.thisExpression(), t.identifier('_delegate')),
    /* right */t.identifier('delegate'))),
    // AST node of `this._serviceLogger = serviceLogger`.
    t.expressionStatement(t.assignmentExpression(
    /* operator */'=',
    /* left */t.memberExpression(t.thisExpression(), t.identifier('_serviceLogger')),
    /* right */t.identifier('serviceLogger')))]));
  } else {
    constructorFunctionExpression = t.functionExpression(
    /* id */null,
    /* params */[t.identifier('connection'), t.identifier('options')],
    /* body */t.blockStatement([
    // AST node of `super()`.
    t.expressionStatement(t.callExpression( /* callee */t['super'](), /* arguments */[])),
    // AST node of `this._connection = connection`.
    t.expressionStatement(t.assignmentExpression(
    /* operator */'=',
    /* left */t.memberExpression(t.thisExpression(), t.identifier('_connection')),
    /* right */t.identifier('connection'))),
    // AST node of `this._options = options`.
    t.expressionStatement(t.assignmentExpression(
    /* operator */'=',
    /* left */t.memberExpression(t.thisExpression(), t.identifier('_options')),
    /* right */t.identifier('options')))]));
  }

  return t.methodDefinition(
  /* key */t.identifier('constructor'),
  /* value */constructorFunctionExpression,
  /* kind */'constructor');
}

/**
 * Generate call expression of
 * `$promiseNode.then(arg0 => {manipulate(arg0); return arg0;})` if nestedflowTypeNodeOfPromise
 * or its child flow type node matches NuclideUri.
 */
function createGetUriFromPathPromiseExpression(promiseNode, nestedflowTypeNodeOfPromise) {

  var arrowFunctionParameter = t.identifier('result');
  var assignmentExpression = createGetUriOfRemotePathAssignmentExpression(nestedflowTypeNodeOfPromise, arrowFunctionParameter);

  if (!assignmentExpression) {
    return promiseNode;
  }

  var arrowFunction = t.arrowFunctionExpression(
  /* params */[arrowFunctionParameter],
  /* body */t.blockStatement([assignmentExpression, t.returnStatement(arrowFunctionParameter)]));

  return t.callExpression(
  /* callee */t.memberExpression(promiseNode, t.identifier('then')),
  /* arguments */[arrowFunction]);
}

function createRemoteRpcMethodDefinition(classDeclaration, methodDefinition, isDecorator) {
  // For each parameter of the method, check its flow type and create manipulation expression if
  // the flow type matches or contains `NuclideUri`.
  var parametersManipulationExpressions = [];
  if (!isDecorator) {
    methodDefinition.value.params.forEach(function (param) {
      var assignmentExpression = createGetPathOfUriAssignmentExpression(param.typeAnnotation.typeAnnotation, param);
      if (assignmentExpression) {
        parametersManipulationExpressions.push(assignmentExpression);
      }
    });
  }

  var remoteFunctionExpression = undefined;
  if (isDecorator) {
    var argsAsIdentifiers = methodDefinition.value.params.map(function (param) {
      return t.identifier(param.name);
    });

    // AST node of
    // `this._serviceLogger.logServiceCall(
    //   '$className',
    //   '$methodName',
    //   true,
    //   $methodParam0,
    //   $methodParam1,
    //   ...);
    // );`
    var logServiceCallExpression = t.callExpression(
    /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_serviceLogger')), t.identifier('logServiceCall')),
    /* arguments */[t.literal(classDeclaration.id.name), t.literal(methodDefinition.key.name), t.literal(true)].concat(argsAsIdentifiers));

    // AST node of
    // `this._delegate.$methodName(
    //   $methodParam0,
    //   $methodParam1,
    //   ...);
    // );`
    var delegateExpression = t.callExpression(
    /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_delegate')), t.identifier(methodDefinition.key.name)),
    /* arguments */argsAsIdentifiers);
    remoteFunctionExpression = t.functionExpression(
    /* id */null,
    /* params */methodDefinition.value.params,
    /* body */t.blockStatement([t.expressionStatement(logServiceCallExpression), t.returnStatement(delegateExpression)]));
  } else {
    // AST node of
    // `this._connection.makeRpc(
    //   '$className/$methodName',
    //   [$methodParam0,
    //    $methodParam1,
    //    ....],
    //   this._options);
    // );`
    var rpcCallExpression = t.callExpression(
    /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('makeRpc')),
    /* arguments */[t.literal(classDeclaration.id.name + '/' + methodDefinition.key.name), t.arrayExpression(methodDefinition.value.params), t.memberExpression(t.thisExpression(), t.identifier('_options'))]);

    // If the method's return value is typed as Promise<..> and has nested `NuclideUri`, append
    // manipulation code in `returnValue.then(...)` block.
    var methodReturnType = methodDefinition.value.returnType;
    if (methodReturnType !== undefined && isGenericFlowTypeAnnotation(methodReturnType.typeAnnotation, 'Promise')) {

      var typeParameters = methodReturnType.typeAnnotation.typeParameters;

      if (typeParameters && typeParameters.params.length === 1) {
        rpcCallExpression = createGetUriFromPathPromiseExpression(rpcCallExpression, typeParameters.params[0]);
      }
    }

    remoteFunctionExpression = t.functionExpression(
    /* id */null,
    /* params */methodDefinition.value.params,
    /* body */t.blockStatement(parametersManipulationExpressions.concat([t.returnStatement(rpcCallExpression)])));
  }

  // Create the method defintion AST node.
  var remoteMethodDefinition = t.methodDefinition(
  /* key */t.identifier(methodDefinition.key.name),
  /* value */remoteFunctionExpression,
  /* kind */'method');

  if (!isDecorator) {
    // Annotate this node with the analytics.trackTiming decorator.
    remoteMethodDefinition.decorators = [t.decorator(t.callExpression(t.memberExpression(t.identifier('analytics'), t.identifier('trackTiming')), []))];
  }

  return remoteMethodDefinition;
}

/**
 * If the callback function's parameter is typed as `NuclideUri` or has nested type of `NuclideUri`,
 * create a new callback function which transform the paramter's NuclideUri first then call to the
 * original callback.
 *
 * For example, given callback `callback: (payload: NuclideUri) => void`, it returns a new arrow
 * function:
 * ```
 * payload => {
 *   payload = this._connection.getUriOfRemotePath(payload);
 *   return callback(payload);
 * }
 * ```
 */
function createManipulatedCallbackArrowFunction(callbackAstNode) {
  if (!callbackAstNode.typeAnnotation.typeAnnotation.params) {
    return null;
  }

  var parameterManipulateExpressions = [];

  callbackAstNode.typeAnnotation.typeAnnotation.params.forEach(function (callbackParameterFlowtypeNode) {
    var identifier = callbackParameterFlowtypeNode.name;
    var manipulateCallbackParameterAssignmentExpression = createGetUriOfRemotePathAssignmentExpression(callbackParameterFlowtypeNode.typeAnnotation, identifier);
    if (manipulateCallbackParameterAssignmentExpression) {
      parameterManipulateExpressions.push(manipulateCallbackParameterAssignmentExpression);
    }
  });

  if (parameterManipulateExpressions.length === 0) {
    return null;
  }

  var parameterIdentifiers = callbackAstNode.typeAnnotation.typeAnnotation.params.map(function (node) {
    return node.name;
  });

  return t.arrowFunctionExpression(
  /* params */parameterIdentifiers,
  /* body */t.blockStatement(parameterManipulateExpressions.concat([t.returnStatement(t.callExpression(t.identifier(callbackAstNode.name), parameterIdentifiers))])));
}

function createRemoteEventMethodDefinition(classDeclaration, methodDefinition) {
  var remoteEventMethodBody = [];
  var callbackParameter = methodDefinition.value.params[0];

  var manipulatedCallback = createManipulatedCallbackArrowFunction(methodDefinition.value.params[0]);

  if (manipulatedCallback) {
    callbackParameter = t.identifier('_' + callbackParameter.name);

    remoteEventMethodBody.push(t.variableDeclaration(
    /* kind */'var',
    /* declarations */[t.variableDeclarator(
    /* id */callbackParameter,
    /* init */manipulatedCallback)]));
  }

  remoteEventMethodBody.push(
  // AST node of
  // `return this._connection.registerEventListener(
  //   '$className/$methodName',
  //   callback,
  //   this._options,
  // );`
  t.returnStatement(t.callExpression(
  /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('registerEventListener')),
  /* arguments */[t.literal(classDeclaration.id.name + '/' + methodDefinition.key.name), callbackParameter, t.memberExpression(t.thisExpression(), t.identifier('_options'))])));

  var remoteFunctionExpression = t.functionExpression(
  /* id */null,
  /* params */methodDefinition.value.params,
  /* body */t.blockStatement(remoteEventMethodBody));

  return t.methodDefinition(
  /* key */t.identifier(methodDefinition.key.name),
  /* value */remoteFunctionExpression,
  /* kind */'method');
}

function createServiceTransformer(baseClassFilePath, isDecorator) {
  var classPrefix = (0, _classPrefix.getClassPrefix)(isDecorator);
  return new Transformer('remote-service', {
    ClassDeclaration: function ClassDeclaration(node, parent) {
      // Skip classes with `Remote` prefix as it's generated.
      if ((0, _classPrefix.hasGeneratedClassPrefix)(node.id.name)) {
        return;
      }

      // Make sure block comment `/* flow */` generated at the beginning of the file.
      // The way babel deal with comments is buggy, if we switch following two lines:
      // ```
      //   this.insertBefore(createBaseClassRequireExpression(...));
      //   return createRemoteClassDeclaration(...);
      // ```
      // The generated code will look like:
      // ```
      //   'use babel';
      //   var TestService = require('...');
      //   /* flow */
      //   class RemoteTestService extends TestService {
      //   ...
      // ```
      // which is not what we expect.
      this.insertAfter(createRemoteClassDeclaration(node, isDecorator));

      // Require the analytics package.
      if (!isDecorator) {
        this.insertAfter(createAnalyticsRequireExpression());
      }

      return createBaseClassRequireExpression(node.id.name, baseClassFilePath);
    },

    // Update `module.exports` to export generated remote class.
    ExpressionStatement: function ExpressionStatement(node, parent) {
      // Ignore expression not in form of `module.exports = ...`.
      if (!t.isAssignmentExpression(node.expression) || node.expression.operator !== '=' || !t.isMemberExpression(node.expression.left) || !t.isIdentifier(node.expression.left.object) || !t.isIdentifier(node.expression.left.property) || node.expression.left.object.name !== 'module' || node.expression.left.property.name !== 'exports') {
        return;
      }
      var right = node.expression.right;

      // If expression takes form `module.exports = $identifier`, then we are exporting
      // only one class.
      if (t.isIdentifier(right)) {
        node.expression.right = t.identifier(classPrefix + node.expression.right.name);
        return;
      }

      // If expression takes form `module.exports = { $identifier, ..., $identifer }`, then
      // we are exporting multiple classes.
      if (t.isObjectExpression(right)) {
        // Ensure that all the properties in this object are all identifier : identifier mappins.
        var identifiers = right.properties.every(function (prop) {
          return t.isIdentifier(prop.key) && t.isIdentifier(prop.value);
        });
        if (!identifiers) {
          return;
        }
        // Prepend the class prefix to every key and value.
        right.properties.forEach(function (prop) {
          prop.value = t.identifier(classPrefix + prop.value.name);
        });
      }
    }
  });
}

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXIvbGliL3JlbW90ZS1zZXJ2aWNlLXRyYW5zZm9ybWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztxQkFvakJ3Qix3QkFBd0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQWxkTSxnQkFBZ0I7O0FBbEd0RSxXQUFXLENBQUM7O2VBb0dVLE9BQU8sQ0FBQyxZQUFZLENBQUM7O0lBQXBDLFdBQVcsWUFBWCxXQUFXOztBQUNsQixJQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDOztnQkFDVixPQUFPLENBQUMsc0JBQXNCLENBQUM7O0lBQXBELGlCQUFpQixhQUFqQixpQkFBaUI7O2dCQUNjLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQzs7SUFBM0QsMkJBQTJCLGFBQTNCLDJCQUEyQjs7Z0JBRTVCLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQzs7SUFEbkMsNENBQTRDLGFBQTVDLDRDQUE0QztJQUFFLHNDQUFzQyxhQUF0QyxzQ0FBc0M7Ozs7OztBQU8zRixTQUFTLGdDQUFnQyxDQUFDLGFBQXFCLEVBQUUsaUJBQXlCLEVBQU87O0FBRS9GLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUNoRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7OztBQUdsQyxNQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxp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X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtc2VydmljZS10cmFuc2Zvcm1lci9saWIvcmVtb3RlLXNlcnZpY2UtdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKlxuICogQmFiZWwncyBwbHVnaW4gd2hvIGF1dG8gZ2VuZXJhdGUgcmVtb3RlIHNlcnZpY2UgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gc2VydmljZSBkZWZpbml0aW9uIGNsYXNzLlxuICogSWYgdGhlIG1ldGhvZCBuYW1lIHN0YXJ0cyB3aXRoICdvbicgKGFzc3VtaW5nIGEgY2FtZWwtY2FzZWQgbWV0aG9kKSwgd2Ugd2lsbCBnZW5lcmF0ZSB0aGUgZXZlbnRcbiAqIHJlZ2lzdHJhdGlvbiBtZXRob2QsIG90aGVyd2lzZSwgcnBjIGNhbGwgbWV0aG9kIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICpcbiAqIEl0IGlzIGNvbW1vbiB0aGF0IGEgcmVtb3RlIHNlcnZpY2UgYXBpIHRha2UgYSBmaWxlIHBhdGggYXMgcGFyYW1ldGVyIG9yIHJldHVybiBhIGZpbGUgcGF0aCBhc1xuICogcmVzdWx0LiBIb3dldmVyLCB0aGUgc2FtZSBwYXRoIGhhcyBkaWZmZXJlbnQgZm9ybXMgbG9jYWxseSBhbmQgcmVtb3RlbHkuXG4gKiBJbiBjbGllbnQgYSByZW1vdGUgZmlsZSdzIHVyaSBpcyBpbiBmb3JtIG9mICdudWNsaWRlOi8vJGhvc3Q6JHBvcnQvJHBhdGgnLCB3aGlsZSBpbiB0aGUgc2VydmVyXG4gKiB3ZSBvbmx5IG5lZWQgJHBhdGguXG4gKlxuICogVG8gYWRkcmVzcyB0aGlzIHByb2JsZW0sIHdlIHN1cHBvcnQgZmxvdyB0eXBlIGBOdWNsaWRlVXJpYCBmb3IgcGFyYW1ldGVyIGFuZFxuICogYFByb21pc2U8TnVjbGlkZVVyaT5gIGZvciByZXR1cm4gdmFsdWUgaW4gUlBDIG1ldGhvZCBkZWZpbml0aW9uOlxuICogICBhKSBJZiBhIHBhcmFtZXRlciBpcyB0eXBlZCBhcyBgTnVjbGlkZVVyaWAsIHRoZSBnZW5lcmF0ZWQgbWV0aG9kIGluIHJlbW90ZSBzZXJ2aWNlIGFzc3VtZXNcbiAqICAgICAgdGhlIHBhcmFtZXRlciBpcyBhIHJlbW90ZSBmaWxlIHVyaSAoJ251Y2xpZGU6Ly8kaG9zdDokcG9zdC8kcGF0aCcpLiBTbyBpdCBwYXJzZXMgdGhlXG4gKiAgICAgIHBhcmFtZXRlciBhbmQgY2FsbHMgdG8gcnBjIHdpdGggdGhlIHBhcnNlZCBwYXRoLlxuICogICBiKSBJZiB0aGUgcmV0dXJuIHZhbHVlIGlzIHR5cGVkIGFzIGBQcm9taXNlPE51Y2xpZGVVcmk+YCwgdGhlIGdlbmVyYXRlZCBtZXRob2QgdHJlYXRzIHJlc3VsdFxuICogICAgICBmcm9tIHJwYyBjYWxsIGFzIGEgcGF0aC4gSXQgYXNzZW1ibGVzIHRoZSBwYXRoIHdpdGggcmVtb3RlIGhvc3QvcG9ydCB0byBhIHJlbW90ZSBmaWxlIHVyaVxuICogICAgICBhbmQgcmV0dXJuIHRoZSB1cmkgdG8gY2FsbGVyLlxuICogICBjKSBGb3IgZXZlbnQgbWV0aG9kIGRlZmluaXRpb24sIGlmIHRoZSBjYWxsYmFjaydzIHBhcmFtZXRlciBpcyB0eXBlZCBhcyBgTnVjbGlkZVVyaWAsIHRoZVxuICogICAgICBnZW5lcmF0ZWQgbWV0aG9kIGFzc2VtYmxlcyB0aGUgcGFyYW1ldGVyIHdpdGggcmVtb3RlIGhvc3QvcG9ydCBpbmZvcm1hdGlvbiBhcyB3ZWxsLlxuICogICBkKSBXZSBhbHNvIHN1cHBvcnQgbmVzdGVkIGZsb3cgdHlwZSBkZWZpbml0aW9uIGZvciBwYXJhbWV0ZXIgYW5kIHJldHVybiB2YWx1ZSBsaWtlXG4gKiAgICAgIGBBcnJheTxOdWNsaWRlVXJpPmAgb3IgYHtmaWxlOiBOdWNsaWRlVXJpLCBzaXplSW5CeXRlOiBudW1iZXJ9YCBldGMsIGFzIGl0IHdpbGwgYmUgcHJvcGVybHlcbiAqICAgICAgdHJhbnNmb3JtZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBwbGVhc2UgcmVhZCBjb21tZW50cyBpbiAnbnVjbGlkZS11cmktdHJhbnNmb3JtZXIuanMnLlxuICpcbiAqIEFzIGFuIGV4YW1wbGUsIGZvciBhIHNlcnZpY2UgZGVmaW5pdGlvbjpcbiAqXG4gKiBgYGBcbiAqICBjbGFzcyBUZXN0U2VydmljZSB7XG4gKiAgICBnZXRTdGF0dXMoaW5jbHVkZUlnbm9yZWQ6IGJvb2xlYW4pOiBQcm9taXNlPGFueT4ge1xuICogICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICogICAgfVxuICpcbiAqICAgIGdldEZpbGVTdGF0dXMoZmlsZVVyaTogTnVjbGlkZVVyaSk6IFByb21pc2U8YW55PiB7XG4gKiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnbm90IGltcGxlbWVudGVkJyk7XG4gKiAgICB9XG4gKlxuICogICAgZ2V0TGFzdE9wZW5lZEZpbGUoKTogUHJvbWlzZTxOdWNpZGVVcmk+IHtcbiAqICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdub3QgaW1wbGVtZW50ZWQnKTtcbiAqICAgIH1cbiAqXG4gKiAgICBvbkZpbGVDaGFuZ2VkKGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkKTogRGlzcG9zYWJsZSB7XG4gKiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnbm90IGltcGxlbWVudGVkJyk7XG4gKiAgICB9XG4gKiAgfVxuICpcbiAqIG1vZHVsZS5leHBvcnRzID0gVGVzdFNlcnZpY2U7XG4gKiBgYGBcbiAqXG4gKiBpdCB3aWxsIGdlbmVyYXRlIGZvbGxvd2luZyBjb2RlOlxuICpcbiAqIGBgYFxuICogIHZhciBUZXN0U2VydmljZSA9IHJlcXVpcmUoLi4uKTtcbiAqXG4gKiAgLy8gQXV0by1nZW5lcmF0ZWQ6IERPIE5PVCBNT0RJRlkuXG4gKlxuICogIGNsYXNzIFJlbW90ZVRlc3RTZXJ2aWNlIGV4dGVuZHMgVGVzdFNlcnZpY2Uge1xuICogICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICogICAgICBzdXBlcigpO1xuICogICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAqICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gKiAgICB9XG4gKiAgICBnZXRTdGF0dXMoaW5jbHVkZUlnbm9yZWQpIHtcbiAqICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24ubWFrZVJwYygnVGVzdFNlcnZpY2UvZ2V0U3RhdHVzJywgW2luY2x1ZGVJZ25vcmVkXSwgdGhpcy5fb3B0aW9ucyk7XG4gKiAgICB9XG4gKiAgICBnZXRGaWxlU3RhdHVzKGZpbGVVcmkpIHtcbiAqICAgICAgZmlsZVVyaSA9IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0UGF0aE9mVXJpKGZpbGVVcmkpO1xuICogICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbi5tYWtlUnBjKCdUZXN0U2VydmljZS9nZXRGaWxlU3RhdHVzJywgW2ZpbGVVcmldLCB0aGlzLl9vcHRpb25zKTtcbiAqICAgIH1cbiAqICAgIGdldExhc3RPcGVuZWRGaWxlKCkge1xuICogICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbi5tYWtlUnBjKCdUZXN0U2VydmljZS9nZXRMYXN0T3BlbmVkRmlsZScsIFtdLCB0aGlzLl9vcHRpb25zKVxuICogICAgICAgIC50aGVuKGFyZzAgPT4ge1xuICogICAgICAgICAgYXJnMCA9IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0VXJpT2ZSZW1vdGVQYXRoKGFyZzApO1xuICogICAgICAgICAgcmV0dXJuIGFyZzA7XG4gKiAgICAgICAgfSk7XG4gKiAgICB9XG4gKiAgICBvbkZpbGVDaGFuZ2VkKGNhbGxiYWNrKSB7XG4gKiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihcbiAqICAgICAgICAnVGVzdFNlcnZpY2Uvb25GaWxlQ2hhbmdlZCcsXG4gKiAgICAgICAgY2FsbGJhY2ssXG4gKiAgICAgICAgdGhpcy5fb3B0aW9ucyxcbiAqICAgICAgKTtcbiAqICAgIH1cbiAqICB9XG4gKlxuICogbW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVUZXN0U2VydmljZTtcbiAqIGBgYFxuICovXG5pbXBvcnQge2dldENsYXNzUHJlZml4LCBoYXNHZW5lcmF0ZWRDbGFzc1ByZWZpeH0gZnJvbSAnLi9jbGFzcy1wcmVmaXgnO1xuXG5jb25zdCB7VHJhbnNmb3JtZXJ9ID0gcmVxdWlyZSgnYmFiZWwtY29yZScpO1xuY29uc3QgdCA9IHJlcXVpcmUoJ2JhYmVsLWNvcmUnKS50eXBlcztcbmNvbnN0IHtpc0V2ZW50TWV0aG9kTmFtZX0gPSByZXF1aXJlKCcuL21ldGhvZC1uYW1lLXBhcnNlcicpO1xuY29uc3Qge2lzR2VuZXJpY0Zsb3dUeXBlQW5ub3RhdGlvbn0gPSByZXF1aXJlKCcuL2Zsb3ctYW5ub3RhdGlvbicpO1xuY29uc3Qge2NyZWF0ZUdldFVyaU9mUmVtb3RlUGF0aEFzc2lnbm1lbnRFeHByZXNzaW9uLCBjcmVhdGVHZXRQYXRoT2ZVcmlBc3NpZ25tZW50RXhwcmVzc2lvbn1cbiAgICA9IHJlcXVpcmUoJy4vbnVjbGlkZS11cmktdHJhbnNmb3JtZXInKTtcblxuLyoqXG4gKiBDcmVhdGUgYXN0IGV4cHJlc3Npb24gb2YgYHZhciAkYmFzZUNsYXNzTmFtZSA9IHJlcXVpcmUoJyRiYXNlQ2xhc3NGaWxlUGF0aCcpXG4gKiAuJGJhc2VDbGFzc05hbWUgfHwgcmVxdWlyZSgnJGJhc2VDbGFzc0ZpbGVQYXRoJyk7YC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNsYXNzUmVxdWlyZUV4cHJlc3Npb24oYmFzZUNsYXNzTmFtZTogc3RyaW5nLCBiYXNlQ2xhc3NGaWxlUGF0aDogc3RyaW5nKTogYW55IHtcbiAgLy8gQ3JlYXRlIGEgcmVxdWlyZSBleHByZXNzaW9uIHRoYXQgbG9hZHMgdGhlIGZpbGUgb2YgdGhlIHNlcnZpY2UgZGVmaW5pdGlvbi5cbiAgY29uc3QgcmVxdWlyZUV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKHQuaWRlbnRpZmllcigncmVxdWlyZScpLFxuICAgIFt0LmxpdGVyYWwoYmFzZUNsYXNzRmlsZVBhdGgpXSk7XG4gIC8vIEZpcnN0IHRyeSB0byBhY2Nlc3MgdGhlIHNlcnZpY2UgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgbW9kdWxlIC0gaWYgbm90LFxuICAvLyB0aGUgc2VydmljZSBpcyB0aGUgbW9kdWxlIGl0c2VsZi5cbiAgY29uc3Qgb3JFeHByZXNzaW9uID0gdC5iaW5hcnlFeHByZXNzaW9uKCd8fCcsIHQubWVtYmVyRXhwcmVzc2lvbihyZXF1aXJlRXhwcmVzc2lvbixcbiAgICB0LmlkZW50aWZpZXIoYmFzZUNsYXNzTmFtZSkpLCByZXF1aXJlRXhwcmVzc2lvbik7XG5cbiAgcmV0dXJuIHQudmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAvKiBraW5kICovICd2YXInLFxuICAgIC8qIGRlY2xhcmF0aW9ucyAqLyBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgLyogaWQgKi8gdC5pZGVudGlmaWVyKGJhc2VDbGFzc05hbWUpLFxuICAgICAgICAvKiBpbml0ICovIG9yRXhwcmVzc2lvblxuICAgICAgKSxcbiAgICBdXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFzdCBleHByZXNzaW9uIG9mIGB2YXIgYW5hbHl0aWNzID0gcmVxdWlyZSgnbnVjbGlkZS1hbmFseXRpY3MnKTtgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBbmFseXRpY3NSZXF1aXJlRXhwcmVzc2lvbigpOiBhbnkge1xuICByZXR1cm4gdC52YXJpYWJsZURlY2xhcmF0aW9uKFxuICAgIC8qIGtpbmQgKi8gJ3ZhcicsXG4gICAgLyogZGVjbGFyYXRpb25zICovIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKFxuICAgICAgICAvKiBpZCAqLyB0LmlkZW50aWZpZXIoJ2FuYWx5dGljcycpLFxuICAgICAgICAvKiBpbml0ICovIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgLyogY2FsbGVlICovIHQuaWRlbnRpZmllcigncmVxdWlyZScpLFxuICAgICAgICAgIC8qIGFyZ3VtZW50cyAqLyBbdC5saXRlcmFsKCdudWNsaWRlLWFuYWx5dGljcycpXVxuICAgICAgICApXG4gICAgICApLFxuICAgIF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlQ2xhc3NEZWNsYXJhdGlvbihjbGFzc0RlY2xhcmF0aW9uOiBhbnksIGlzRGVjb3JhdG9yOiBib29sZWFuKTogYW55IHtcbiAgY29uc3QgcmVtb3RlTWV0aG9kRGVmaW5pdGlvbnMgPSBjbGFzc0RlY2xhcmF0aW9uLmJvZHkuYm9keS5tYXAoYm9keVBhcnQgPT4ge1xuICAgIC8vIENyZWF0ZSByZW1vdGUgbWV0aG9kIGRlZmluaXRpb24gZm9yIGVhY2ggY2xhc3MgbWV0aG9kLiBUaGUgcGFydCB0eXBlIG11c3QgYmUgY2hlY2tlZCBiZWNhdXNlXG4gICAgLy8gRVM3IGNsYXNzIHByb3BlcnRpZXMgYXJlIGFsc28gcGFydCBvZiB0aGUgYGJvZHlgIGFycmF5IGFuZCBoYXZlIHR5cGUgYENsYXNzUHJvcGVydHlgLlxuICAgIGlmIChib2R5UGFydC50eXBlID09PSAnTWV0aG9kRGVmaW5pdGlvbicpIHtcbiAgICAgIGlmIChpc0V2ZW50TWV0aG9kTmFtZShib2R5UGFydC5rZXkubmFtZSkgJiYgIWlzRGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdGVFdmVudE1ldGhvZERlZmluaXRpb24oY2xhc3NEZWNsYXJhdGlvbiwgYm9keVBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW90ZVJwY01ldGhvZERlZmluaXRpb24oY2xhc3NEZWNsYXJhdGlvbiwgYm9keVBhcnQsIGlzRGVjb3JhdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGNsYXNzUHJlZml4ID0gZ2V0Q2xhc3NQcmVmaXgoaXNEZWNvcmF0b3IpO1xuICBjb25zdCByZW1vdGVDbGFzc0RlY2xhcmF0aW9uID0gdC5jbGFzc0RlY2xhcmF0aW9uKFxuICAgIC8qIGlkICovIHQuaWRlbnRpZmllcihjbGFzc1ByZWZpeCArIGNsYXNzRGVjbGFyYXRpb24uaWQubmFtZSksXG4gICAgLyogYm9keSAqLyB0LmNsYXNzQm9keShcbiAgICAgIFtjcmVhdGVDb25zdHJ1Y3RvckRlZmluaXRpb24oaXNEZWNvcmF0b3IpXS5jb25jYXQocmVtb3RlTWV0aG9kRGVmaW5pdGlvbnMpXG4gICAgKSxcbiAgICAvKiBzdXBlckNsYXNzICovIGNsYXNzRGVjbGFyYXRpb24uaWRcbiAgKTtcblxuICAvLyBUaGVyZSBpcyBubyBzdWNoIGZ1bmN0aW9uIHRvIGNyZWF0ZSBjb21tZW50IG5vZGUgaW4gYmFiZWwsIHNvIHVzZSBmb2xsb3dpbmdcbiAgLy8gaGFjayB0byB3YWxrIGFyb3VuZCBmb3Igbm93LlxuICByZW1vdGVDbGFzc0RlY2xhcmF0aW9uLmxlYWRpbmdDb21tZW50cyA9IFtcbiAgICB7XG4gICAgICB0eXBlOiAnTGluZScsXG4gICAgICB2YWx1ZTogJyBBdXRvLWdlbmVyYXRlZDogRE8gTk9UIE1PRElGWS4nLFxuICAgIH0sXG4gIF07XG5cbiAgcmV0dXJuIHJlbW90ZUNsYXNzRGVjbGFyYXRpb247XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN0cnVjdG9yRGVmaW5pdGlvbihpc0RlY29yYXRvcjogYm9vbGVhbik6IGFueSB7XG4gIGxldCBjb25zdHJ1Y3RvckZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgaWYgKGlzRGVjb3JhdG9yKSB7XG4gICAgY29uc3RydWN0b3JGdW5jdGlvbkV4cHJlc3Npb24gPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihcbiAgICAgIC8qIGlkICovIG51bGwsXG4gICAgICAvKiBwYXJhbXMgKi8gW3QuaWRlbnRpZmllcignZGVsZWdhdGUnKSwgdC5pZGVudGlmaWVyKCdzZXJ2aWNlTG9nZ2VyJyldLFxuICAgICAgLyogYm9keSAqLyB0LmJsb2NrU3RhdGVtZW50KFxuICAgICAgICBbXG4gICAgICAgICAgLy8gQVNUIG5vZGUgb2YgYHN1cGVyKClgLlxuICAgICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICAgIHQuY2FsbEV4cHJlc3Npb24oLyogY2FsbGVlICovIHQuc3VwZXIoKSwgLyogYXJndW1lbnRzICovIFtdKVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gQVNUIG5vZGUgb2YgYHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGVgLlxuICAgICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIC8qIG9wZXJhdG9yICovICc9JyxcbiAgICAgICAgICAgICAgLyogbGVmdCAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICAgICAgICAgIHQuaWRlbnRpZmllcignX2RlbGVnYXRlJylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLyogcmlnaHQgKi8gdC5pZGVudGlmaWVyKCdkZWxlZ2F0ZScpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBBU1Qgbm9kZSBvZiBgdGhpcy5fc2VydmljZUxvZ2dlciA9IHNlcnZpY2VMb2dnZXJgLlxuICAgICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIC8qIG9wZXJhdG9yICovICc9JyxcbiAgICAgICAgICAgICAgLyogbGVmdCAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICAgICAgICAgIHQuaWRlbnRpZmllcignX3NlcnZpY2VMb2dnZXInKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvKiByaWdodCAqLyB0LmlkZW50aWZpZXIoJ3NlcnZpY2VMb2dnZXInKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgIF1cbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0cnVjdG9yRnVuY3Rpb25FeHByZXNzaW9uID0gdC5mdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgICAvKiBpZCAqLyBudWxsLFxuICAgICAgLyogcGFyYW1zICovIFt0LmlkZW50aWZpZXIoJ2Nvbm5lY3Rpb24nKSwgdC5pZGVudGlmaWVyKCdvcHRpb25zJyldLFxuICAgICAgLyogYm9keSAqLyB0LmJsb2NrU3RhdGVtZW50KFxuICAgICAgICBbXG4gICAgICAgICAgLy8gQVNUIG5vZGUgb2YgYHN1cGVyKClgLlxuICAgICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICAgIHQuY2FsbEV4cHJlc3Npb24oLyogY2FsbGVlICovIHQuc3VwZXIoKSwgLyogYXJndW1lbnRzICovIFtdKVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gQVNUIG5vZGUgb2YgYHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uYC5cbiAgICAgICAgICB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICAgICAgICB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAvKiBvcGVyYXRvciAqLyAnPScsXG4gICAgICAgICAgICAgIC8qIGxlZnQgKi8gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgICB0LmlkZW50aWZpZXIoJ19jb25uZWN0aW9uJylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLyogcmlnaHQgKi8gdC5pZGVudGlmaWVyKCdjb25uZWN0aW9uJylcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIEFTVCBub2RlIG9mIGB0aGlzLl9vcHRpb25zID0gb3B0aW9uc2AuXG4gICAgICAgICAgdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICAgICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgLyogb3BlcmF0b3IgKi8gJz0nLFxuICAgICAgICAgICAgICAvKiBsZWZ0ICovIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgICB0LnRoaXNFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgdC5pZGVudGlmaWVyKCdfb3B0aW9ucycpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIC8qIHJpZ2h0ICovIHQuaWRlbnRpZmllcignb3B0aW9ucycpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgXVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdC5tZXRob2REZWZpbml0aW9uKFxuICAgIC8qIGtleSAqLyB0LmlkZW50aWZpZXIoJ2NvbnN0cnVjdG9yJyksXG4gICAgLyogdmFsdWUgKi8gY29uc3RydWN0b3JGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgLyoga2luZCAqLyAnY29uc3RydWN0b3InXG4gICk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgY2FsbCBleHByZXNzaW9uIG9mXG4gKiBgJHByb21pc2VOb2RlLnRoZW4oYXJnMCA9PiB7bWFuaXB1bGF0ZShhcmcwKTsgcmV0dXJuIGFyZzA7fSlgIGlmIG5lc3RlZGZsb3dUeXBlTm9kZU9mUHJvbWlzZVxuICogb3IgaXRzIGNoaWxkIGZsb3cgdHlwZSBub2RlIG1hdGNoZXMgTnVjbGlkZVVyaS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlR2V0VXJpRnJvbVBhdGhQcm9taXNlRXhwcmVzc2lvbihcbiAgICBwcm9taXNlTm9kZTogYW55LFxuICAgIG5lc3RlZGZsb3dUeXBlTm9kZU9mUHJvbWlzZTogYW55KTogYW55IHtcblxuICBjb25zdCBhcnJvd0Z1bmN0aW9uUGFyYW1ldGVyID0gdC5pZGVudGlmaWVyKCdyZXN1bHQnKTtcbiAgY29uc3QgYXNzaWdubWVudEV4cHJlc3Npb24gPSBjcmVhdGVHZXRVcmlPZlJlbW90ZVBhdGhBc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgIG5lc3RlZGZsb3dUeXBlTm9kZU9mUHJvbWlzZSwgYXJyb3dGdW5jdGlvblBhcmFtZXRlcik7XG5cbiAgaWYgKCFhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgIHJldHVybiBwcm9taXNlTm9kZTtcbiAgfVxuXG4gIGNvbnN0IGFycm93RnVuY3Rpb24gPSB0LmFycm93RnVuY3Rpb25FeHByZXNzaW9uKFxuICAgIC8qIHBhcmFtcyAqLyBbYXJyb3dGdW5jdGlvblBhcmFtZXRlcl0sXG4gICAgLyogYm9keSAqLyB0LmJsb2NrU3RhdGVtZW50KFxuICAgICAgW1xuICAgICAgICBhc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgICAgdC5yZXR1cm5TdGF0ZW1lbnQoYXJyb3dGdW5jdGlvblBhcmFtZXRlciksXG4gICAgICBdXG4gICAgKVxuICApO1xuXG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKFxuICAgIC8qIGNhbGxlZSAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICBwcm9taXNlTm9kZSxcbiAgICAgIHQuaWRlbnRpZmllcigndGhlbicpLFxuICAgICksXG4gICAgLyogYXJndW1lbnRzICovIFthcnJvd0Z1bmN0aW9uXSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlUnBjTWV0aG9kRGVmaW5pdGlvbihcbiAgY2xhc3NEZWNsYXJhdGlvbjogYW55LFxuICBtZXRob2REZWZpbml0aW9uOiBhbnksXG4gIGlzRGVjb3JhdG9yOiBib29sZWFuLFxuKTogYW55IHtcbiAgLy8gRm9yIGVhY2ggcGFyYW1ldGVyIG9mIHRoZSBtZXRob2QsIGNoZWNrIGl0cyBmbG93IHR5cGUgYW5kIGNyZWF0ZSBtYW5pcHVsYXRpb24gZXhwcmVzc2lvbiBpZlxuICAvLyB0aGUgZmxvdyB0eXBlIG1hdGNoZXMgb3IgY29udGFpbnMgYE51Y2xpZGVVcmlgLlxuICBjb25zdCBwYXJhbWV0ZXJzTWFuaXB1bGF0aW9uRXhwcmVzc2lvbnMgPSBbXTtcbiAgaWYgKCFpc0RlY29yYXRvcikge1xuICAgIG1ldGhvZERlZmluaXRpb24udmFsdWUucGFyYW1zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgY29uc3QgYXNzaWdubWVudEV4cHJlc3Npb24gPSBjcmVhdGVHZXRQYXRoT2ZVcmlBc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgICBwYXJhbS50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbiwgcGFyYW0pO1xuICAgICAgaWYgKGFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICAgIHBhcmFtZXRlcnNNYW5pcHVsYXRpb25FeHByZXNzaW9ucy5wdXNoKGFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGxldCByZW1vdGVGdW5jdGlvbkV4cHJlc3Npb247XG4gIGlmIChpc0RlY29yYXRvcikge1xuICAgIGNvbnN0IGFyZ3NBc0lkZW50aWZpZXJzID0gbWV0aG9kRGVmaW5pdGlvbi52YWx1ZS5wYXJhbXMubWFwKHBhcmFtID0+IHQuaWRlbnRpZmllcihwYXJhbS5uYW1lKSk7XG5cbiAgICAvLyBBU1Qgbm9kZSBvZlxuICAgIC8vIGB0aGlzLl9zZXJ2aWNlTG9nZ2VyLmxvZ1NlcnZpY2VDYWxsKFxuICAgIC8vICAgJyRjbGFzc05hbWUnLFxuICAgIC8vICAgJyRtZXRob2ROYW1lJyxcbiAgICAvLyAgIHRydWUsXG4gICAgLy8gICAkbWV0aG9kUGFyYW0wLFxuICAgIC8vICAgJG1ldGhvZFBhcmFtMSxcbiAgICAvLyAgIC4uLik7XG4gICAgLy8gKTtgXG4gICAgY29uc3QgbG9nU2VydmljZUNhbGxFeHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIC8qIGNhbGxlZSAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICB0LnRoaXNFeHByZXNzaW9uKCksXG4gICAgICAgICAgdC5pZGVudGlmaWVyKCdfc2VydmljZUxvZ2dlcicpLFxuICAgICAgICApLFxuICAgICAgICB0LmlkZW50aWZpZXIoJ2xvZ1NlcnZpY2VDYWxsJylcbiAgICAgICksXG4gICAgICAvKiBhcmd1bWVudHMgKi8gW1xuICAgICAgICB0LmxpdGVyYWwoY2xhc3NEZWNsYXJhdGlvbi5pZC5uYW1lKSxcbiAgICAgICAgdC5saXRlcmFsKG1ldGhvZERlZmluaXRpb24ua2V5Lm5hbWUpLFxuICAgICAgICB0LmxpdGVyYWwodHJ1ZSksXG4gICAgICBdLmNvbmNhdChhcmdzQXNJZGVudGlmaWVycyksXG4gICAgKTtcblxuICAgIC8vIEFTVCBub2RlIG9mXG4gICAgLy8gYHRoaXMuX2RlbGVnYXRlLiRtZXRob2ROYW1lKFxuICAgIC8vICAgJG1ldGhvZFBhcmFtMCxcbiAgICAvLyAgICRtZXRob2RQYXJhbTEsXG4gICAgLy8gICAuLi4pO1xuICAgIC8vICk7YFxuICAgIGNvbnN0IGRlbGVnYXRlRXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAvKiBjYWxsZWUgKi8gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICAgIHQuaWRlbnRpZmllcignX2RlbGVnYXRlJyksXG4gICAgICAgICksXG4gICAgICAgIHQuaWRlbnRpZmllcihtZXRob2REZWZpbml0aW9uLmtleS5uYW1lKVxuICAgICAgKSxcbiAgICAgIC8qIGFyZ3VtZW50cyAqLyBhcmdzQXNJZGVudGlmaWVycyxcbiAgICApO1xuICAgIHJlbW90ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHQuZnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgLyogaWQgKi8gbnVsbCxcbiAgICAgIC8qIHBhcmFtcyAqLyBtZXRob2REZWZpbml0aW9uLnZhbHVlLnBhcmFtcyxcbiAgICAgIC8qIGJvZHkgKi8gdC5ibG9ja1N0YXRlbWVudChcbiAgICAgICAgW1xuICAgICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChsb2dTZXJ2aWNlQ2FsbEV4cHJlc3Npb24pLFxuICAgICAgICAgIHQucmV0dXJuU3RhdGVtZW50KGRlbGVnYXRlRXhwcmVzc2lvbiksXG4gICAgICAgIF0sXG4gICAgICApLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQVNUIG5vZGUgb2ZcbiAgICAvLyBgdGhpcy5fY29ubmVjdGlvbi5tYWtlUnBjKFxuICAgIC8vICAgJyRjbGFzc05hbWUvJG1ldGhvZE5hbWUnLFxuICAgIC8vICAgWyRtZXRob2RQYXJhbTAsXG4gICAgLy8gICAgJG1ldGhvZFBhcmFtMSxcbiAgICAvLyAgICAuLi4uXSxcbiAgICAvLyAgIHRoaXMuX29wdGlvbnMpO1xuICAgIC8vICk7YFxuICAgIGxldCBycGNDYWxsRXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAvKiBjYWxsZWUgKi8gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICAgIHQuaWRlbnRpZmllcignX2Nvbm5lY3Rpb24nKVxuICAgICAgICApLFxuICAgICAgICB0LmlkZW50aWZpZXIoJ21ha2VScGMnKVxuICAgICAgKSxcbiAgICAgIC8qIGFyZ3VtZW50cyAqLyBbXG4gICAgICAgIHQubGl0ZXJhbChjbGFzc0RlY2xhcmF0aW9uLmlkLm5hbWUgKyAnLycgKyBtZXRob2REZWZpbml0aW9uLmtleS5uYW1lKSxcbiAgICAgICAgdC5hcnJheUV4cHJlc3Npb24obWV0aG9kRGVmaW5pdGlvbi52YWx1ZS5wYXJhbXMpLFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24odC50aGlzRXhwcmVzc2lvbigpLCB0LmlkZW50aWZpZXIoJ19vcHRpb25zJykpLFxuICAgICAgXSxcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlIG1ldGhvZCdzIHJldHVybiB2YWx1ZSBpcyB0eXBlZCBhcyBQcm9taXNlPC4uPiBhbmQgaGFzIG5lc3RlZCBgTnVjbGlkZVVyaWAsIGFwcGVuZFxuICAgIC8vIG1hbmlwdWxhdGlvbiBjb2RlIGluIGByZXR1cm5WYWx1ZS50aGVuKC4uLilgIGJsb2NrLlxuICAgIGNvbnN0IG1ldGhvZFJldHVyblR5cGUgPSBtZXRob2REZWZpbml0aW9uLnZhbHVlLnJldHVyblR5cGU7XG4gICAgaWYgKG1ldGhvZFJldHVyblR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBpc0dlbmVyaWNGbG93VHlwZUFubm90YXRpb24obWV0aG9kUmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbiwgJ1Byb21pc2UnKSkge1xuXG4gICAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IG1ldGhvZFJldHVyblR5cGUudHlwZUFubm90YXRpb24udHlwZVBhcmFtZXRlcnM7XG5cbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycyAmJiB0eXBlUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoID09PSAxKSAge1xuICAgICAgICBycGNDYWxsRXhwcmVzc2lvbiA9IGNyZWF0ZUdldFVyaUZyb21QYXRoUHJvbWlzZUV4cHJlc3Npb24oXG4gICAgICAgICAgICBycGNDYWxsRXhwcmVzc2lvbiwgdHlwZVBhcmFtZXRlcnMucGFyYW1zWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdGVGdW5jdGlvbkV4cHJlc3Npb24gPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihcbiAgICAgIC8qIGlkICovIG51bGwsXG4gICAgICAvKiBwYXJhbXMgKi8gbWV0aG9kRGVmaW5pdGlvbi52YWx1ZS5wYXJhbXMsXG4gICAgICAvKiBib2R5ICovIHQuYmxvY2tTdGF0ZW1lbnQoXG4gICAgICAgIHBhcmFtZXRlcnNNYW5pcHVsYXRpb25FeHByZXNzaW9ucy5jb25jYXQoXG4gICAgICAgICAgW3QucmV0dXJuU3RhdGVtZW50KFxuICAgICAgICAgICAgcnBjQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgKV0sXG4gICAgICAgIClcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbWV0aG9kIGRlZmludGlvbiBBU1Qgbm9kZS5cbiAgY29uc3QgcmVtb3RlTWV0aG9kRGVmaW5pdGlvbiA9IHQubWV0aG9kRGVmaW5pdGlvbihcbiAgICAvKiBrZXkgKi8gdC5pZGVudGlmaWVyKG1ldGhvZERlZmluaXRpb24ua2V5Lm5hbWUpLFxuICAgIC8qIHZhbHVlICovIHJlbW90ZUZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAvKiBraW5kICovICdtZXRob2QnXG4gICk7XG5cbiAgaWYgKCFpc0RlY29yYXRvcikge1xuICAgIC8vIEFubm90YXRlIHRoaXMgbm9kZSB3aXRoIHRoZSBhbmFseXRpY3MudHJhY2tUaW1pbmcgZGVjb3JhdG9yLlxuICAgIHJlbW90ZU1ldGhvZERlZmluaXRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgIHQuZGVjb3JhdG9yKFxuICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICAgIHQuaWRlbnRpZmllcignYW5hbHl0aWNzJyksXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIoJ3RyYWNrVGltaW5nJylcbiAgICAgICAgICApLFxuICAgICAgICAgIFtdXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiByZW1vdGVNZXRob2REZWZpbml0aW9uO1xufVxuXG4vKipcbiAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbidzIHBhcmFtZXRlciBpcyB0eXBlZCBhcyBgTnVjbGlkZVVyaWAgb3IgaGFzIG5lc3RlZCB0eXBlIG9mIGBOdWNsaWRlVXJpYCxcbiAqIGNyZWF0ZSBhIG5ldyBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB0cmFuc2Zvcm0gdGhlIHBhcmFtdGVyJ3MgTnVjbGlkZVVyaSBmaXJzdCB0aGVuIGNhbGwgdG8gdGhlXG4gKiBvcmlnaW5hbCBjYWxsYmFjay5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gY2FsbGJhY2sgYGNhbGxiYWNrOiAocGF5bG9hZDogTnVjbGlkZVVyaSkgPT4gdm9pZGAsIGl0IHJldHVybnMgYSBuZXcgYXJyb3dcbiAqIGZ1bmN0aW9uOlxuICogYGBgXG4gKiBwYXlsb2FkID0+IHtcbiAqICAgcGF5bG9hZCA9IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0VXJpT2ZSZW1vdGVQYXRoKHBheWxvYWQpO1xuICogICByZXR1cm4gY2FsbGJhY2socGF5bG9hZCk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFuaXB1bGF0ZWRDYWxsYmFja0Fycm93RnVuY3Rpb24oY2FsbGJhY2tBc3ROb2RlOiBhbnkpOiA/YW55IHtcbiAgaWYgKCFjYWxsYmFja0FzdE5vZGUudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24ucGFyYW1zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBwYXJhbWV0ZXJNYW5pcHVsYXRlRXhwcmVzc2lvbnMgPSBbXTtcblxuICBjYWxsYmFja0FzdE5vZGUudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24ucGFyYW1zLmZvckVhY2goY2FsbGJhY2tQYXJhbWV0ZXJGbG93dHlwZU5vZGUgPT4ge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjYWxsYmFja1BhcmFtZXRlckZsb3d0eXBlTm9kZS5uYW1lO1xuICAgIGNvbnN0IG1hbmlwdWxhdGVDYWxsYmFja1BhcmFtZXRlckFzc2lnbm1lbnRFeHByZXNzaW9uID1cbiAgICAgIGNyZWF0ZUdldFVyaU9mUmVtb3RlUGF0aEFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICBjYWxsYmFja1BhcmFtZXRlckZsb3d0eXBlTm9kZS50eXBlQW5ub3RhdGlvbixcbiAgICAgICAgaWRlbnRpZmllclxuICAgICAgKTtcbiAgICBpZiAobWFuaXB1bGF0ZUNhbGxiYWNrUGFyYW1ldGVyQXNzaWdubWVudEV4cHJlc3Npb24pIHtcbiAgICAgIHBhcmFtZXRlck1hbmlwdWxhdGVFeHByZXNzaW9ucy5wdXNoKG1hbmlwdWxhdGVDYWxsYmFja1BhcmFtZXRlckFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChwYXJhbWV0ZXJNYW5pcHVsYXRlRXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBwYXJhbWV0ZXJJZGVudGlmaWVycyA9IGNhbGxiYWNrQXN0Tm9kZS50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbi5wYXJhbXMubWFwKFxuICAgICAgbm9kZSA9PiBub2RlLm5hbWUpO1xuXG4gIHJldHVybiB0LmFycm93RnVuY3Rpb25FeHByZXNzaW9uKFxuICAgIC8qIHBhcmFtcyAqLyBwYXJhbWV0ZXJJZGVudGlmaWVycyxcbiAgICAvKiBib2R5ICovIHQuYmxvY2tTdGF0ZW1lbnQoXG4gICAgICBwYXJhbWV0ZXJNYW5pcHVsYXRlRXhwcmVzc2lvbnMuY29uY2F0KFxuICAgICAgICBbXG4gICAgICAgICAgdC5yZXR1cm5TdGF0ZW1lbnQoXG4gICAgICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgICB0LmlkZW50aWZpZXIoY2FsbGJhY2tBc3ROb2RlLm5hbWUpLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJJZGVudGlmaWVycyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICApXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbW90ZUV2ZW50TWV0aG9kRGVmaW5pdGlvbihjbGFzc0RlY2xhcmF0aW9uOiBhbnksIG1ldGhvZERlZmluaXRpb246IGFueSk6IGFueSB7XG4gIGNvbnN0IHJlbW90ZUV2ZW50TWV0aG9kQm9keSA9IFtdO1xuICB2YXIgY2FsbGJhY2tQYXJhbWV0ZXIgPSBtZXRob2REZWZpbml0aW9uLnZhbHVlLnBhcmFtc1swXTtcblxuICBjb25zdCBtYW5pcHVsYXRlZENhbGxiYWNrXG4gICAgICA9IGNyZWF0ZU1hbmlwdWxhdGVkQ2FsbGJhY2tBcnJvd0Z1bmN0aW9uKG1ldGhvZERlZmluaXRpb24udmFsdWUucGFyYW1zWzBdKTtcblxuICBpZiAobWFuaXB1bGF0ZWRDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrUGFyYW1ldGVyID0gdC5pZGVudGlmaWVyKCdfJyArIGNhbGxiYWNrUGFyYW1ldGVyLm5hbWUpO1xuXG4gICAgcmVtb3RlRXZlbnRNZXRob2RCb2R5LnB1c2godC52YXJpYWJsZURlY2xhcmF0aW9uKFxuICAgICAgLyoga2luZCAqLyAndmFyJyxcbiAgICAgIC8qIGRlY2xhcmF0aW9ucyAqLyBbXG4gICAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKFxuICAgICAgICAgIC8qIGlkICovIGNhbGxiYWNrUGFyYW1ldGVyLFxuICAgICAgICAgIC8qIGluaXQgKi8gbWFuaXB1bGF0ZWRDYWxsYmFja1xuICAgICAgICApLFxuICAgICAgXVxuICAgICkpO1xuICB9XG5cbiAgcmVtb3RlRXZlbnRNZXRob2RCb2R5LnB1c2goXG4gICAgLy8gQVNUIG5vZGUgb2ZcbiAgICAvLyBgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24ucmVnaXN0ZXJFdmVudExpc3RlbmVyKFxuICAgIC8vICAgJyRjbGFzc05hbWUvJG1ldGhvZE5hbWUnLFxuICAgIC8vICAgY2FsbGJhY2ssXG4gICAgLy8gICB0aGlzLl9vcHRpb25zLFxuICAgIC8vICk7YFxuICAgIHQucmV0dXJuU3RhdGVtZW50KFxuICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgLyogY2FsbGVlICovIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICB0LnRoaXNFeHByZXNzaW9uKCksXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIoJ19jb25uZWN0aW9uJylcbiAgICAgICAgICApLFxuICAgICAgICAgIHQuaWRlbnRpZmllcigncmVnaXN0ZXJFdmVudExpc3RlbmVyJylcbiAgICAgICAgKSxcbiAgICAgICAgLyogYXJndW1lbnRzICovIFtcbiAgICAgICAgICB0LmxpdGVyYWwoY2xhc3NEZWNsYXJhdGlvbi5pZC5uYW1lICsgJy8nICsgbWV0aG9kRGVmaW5pdGlvbi5rZXkubmFtZSksXG4gICAgICAgICAgY2FsbGJhY2tQYXJhbWV0ZXIsXG4gICAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKHQudGhpc0V4cHJlc3Npb24oKSwgdC5pZGVudGlmaWVyKCdfb3B0aW9ucycpKSxcbiAgICAgICAgXVxuICAgICAgKVxuICAgIClcbiAgKTtcblxuICBjb25zdCByZW1vdGVGdW5jdGlvbkV4cHJlc3Npb24gPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihcbiAgICAvKiBpZCAqLyBudWxsLFxuICAgIC8qIHBhcmFtcyAqLyBtZXRob2REZWZpbml0aW9uLnZhbHVlLnBhcmFtcyxcbiAgICAvKiBib2R5ICovIHQuYmxvY2tTdGF0ZW1lbnQocmVtb3RlRXZlbnRNZXRob2RCb2R5KSxcbiAgKTtcblxuICByZXR1cm4gdC5tZXRob2REZWZpbml0aW9uKFxuICAgIC8qIGtleSAqLyB0LmlkZW50aWZpZXIobWV0aG9kRGVmaW5pdGlvbi5rZXkubmFtZSksXG4gICAgLyogdmFsdWUgKi8gcmVtb3RlRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgIC8qIGtpbmQgKi8gJ21ldGhvZCdcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU2VydmljZVRyYW5zZm9ybWVyKFxuICBiYXNlQ2xhc3NGaWxlUGF0aDogc3RyaW5nLFxuICBpc0RlY29yYXRvcjogYm9vbGVhbixcbik6IGFueSB7XG4gIGNvbnN0IGNsYXNzUHJlZml4ID0gZ2V0Q2xhc3NQcmVmaXgoaXNEZWNvcmF0b3IpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybWVyKCdyZW1vdGUtc2VydmljZScsIHtcbiAgICBDbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAvLyBTa2lwIGNsYXNzZXMgd2l0aCBgUmVtb3RlYCBwcmVmaXggYXMgaXQncyBnZW5lcmF0ZWQuXG4gICAgICBpZiAoaGFzR2VuZXJhdGVkQ2xhc3NQcmVmaXgobm9kZS5pZC5uYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBibG9jayBjb21tZW50IGAvKiBmbG93ICovYCBnZW5lcmF0ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZS5cbiAgICAgIC8vIFRoZSB3YXkgYmFiZWwgZGVhbCB3aXRoIGNvbW1lbnRzIGlzIGJ1Z2d5LCBpZiB3ZSBzd2l0Y2ggZm9sbG93aW5nIHR3byBsaW5lczpcbiAgICAgIC8vIGBgYFxuICAgICAgLy8gICB0aGlzLmluc2VydEJlZm9yZShjcmVhdGVCYXNlQ2xhc3NSZXF1aXJlRXhwcmVzc2lvbiguLi4pKTtcbiAgICAgIC8vICAgcmV0dXJuIGNyZWF0ZVJlbW90ZUNsYXNzRGVjbGFyYXRpb24oLi4uKTtcbiAgICAgIC8vIGBgYFxuICAgICAgLy8gVGhlIGdlbmVyYXRlZCBjb2RlIHdpbGwgbG9vayBsaWtlOlxuICAgICAgLy8gYGBgXG4gICAgICAvLyAgICd1c2UgYmFiZWwnO1xuICAgICAgLy8gICB2YXIgVGVzdFNlcnZpY2UgPSByZXF1aXJlKCcuLi4nKTtcbiAgICAgIC8vICAgLyogZmxvdyAqL1xuICAgICAgLy8gICBjbGFzcyBSZW1vdGVUZXN0U2VydmljZSBleHRlbmRzIFRlc3RTZXJ2aWNlIHtcbiAgICAgIC8vICAgLi4uXG4gICAgICAvLyBgYGBcbiAgICAgIC8vIHdoaWNoIGlzIG5vdCB3aGF0IHdlIGV4cGVjdC5cbiAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIoY3JlYXRlUmVtb3RlQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBpc0RlY29yYXRvcikpO1xuXG4gICAgICAvLyBSZXF1aXJlIHRoZSBhbmFseXRpY3MgcGFja2FnZS5cbiAgICAgIGlmICghaXNEZWNvcmF0b3IpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRBZnRlcihjcmVhdGVBbmFseXRpY3NSZXF1aXJlRXhwcmVzc2lvbigpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZUJhc2VDbGFzc1JlcXVpcmVFeHByZXNzaW9uKG5vZGUuaWQubmFtZSwgYmFzZUNsYXNzRmlsZVBhdGgpO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYG1vZHVsZS5leHBvcnRzYCB0byBleHBvcnQgZ2VuZXJhdGVkIHJlbW90ZSBjbGFzcy5cbiAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAvLyBJZ25vcmUgZXhwcmVzc2lvbiBub3QgaW4gZm9ybSBvZiBgbW9kdWxlLmV4cG9ydHMgPSAuLi5gLlxuICAgICAgaWYgKCF0LmlzQXNzaWdubWVudEV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKSB8fFxuICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5vcGVyYXRvciAhPT0gJz0nIHx8XG4gICAgICAgICAgIXQuaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbi5sZWZ0KSB8fFxuICAgICAgICAgICF0LmlzSWRlbnRpZmllcihub2RlLmV4cHJlc3Npb24ubGVmdC5vYmplY3QpIHx8XG4gICAgICAgICAgIXQuaXNJZGVudGlmaWVyKG5vZGUuZXhwcmVzc2lvbi5sZWZ0LnByb3BlcnR5KSB8fFxuICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5sZWZ0Lm9iamVjdC5uYW1lICE9PSAnbW9kdWxlJyB8fFxuICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5sZWZ0LnByb3BlcnR5Lm5hbWUgIT09ICdleHBvcnRzJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByaWdodCA9IG5vZGUuZXhwcmVzc2lvbi5yaWdodDtcblxuICAgICAgLy8gSWYgZXhwcmVzc2lvbiB0YWtlcyBmb3JtIGBtb2R1bGUuZXhwb3J0cyA9ICRpZGVudGlmaWVyYCwgdGhlbiB3ZSBhcmUgZXhwb3J0aW5nXG4gICAgICAvLyBvbmx5IG9uZSBjbGFzcy5cbiAgICAgIGlmICh0LmlzSWRlbnRpZmllcihyaWdodCkpIHtcbiAgICAgICAgbm9kZS5leHByZXNzaW9uLnJpZ2h0ID0gdC5pZGVudGlmaWVyKFxuICAgICAgICAgIGNsYXNzUHJlZml4ICsgbm9kZS5leHByZXNzaW9uLnJpZ2h0Lm5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGV4cHJlc3Npb24gdGFrZXMgZm9ybSBgbW9kdWxlLmV4cG9ydHMgPSB7ICRpZGVudGlmaWVyLCAuLi4sICRpZGVudGlmZXIgfWAsIHRoZW5cbiAgICAgIC8vIHdlIGFyZSBleHBvcnRpbmcgbXVsdGlwbGUgY2xhc3Nlcy5cbiAgICAgIGlmICh0LmlzT2JqZWN0RXhwcmVzc2lvbihyaWdodCkpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBhbGwgaWRlbnRpZmllciA6IGlkZW50aWZpZXIgbWFwcGlucy5cbiAgICAgICAgY29uc3QgaWRlbnRpZmllcnMgPSByaWdodC5wcm9wZXJ0aWVzLmV2ZXJ5KHByb3AgPT4ge1xuICAgICAgICAgIHJldHVybiB0LmlzSWRlbnRpZmllcihwcm9wLmtleSkgJiYgdC5pc0lkZW50aWZpZXIocHJvcC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXJzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBlbmQgdGhlIGNsYXNzIHByZWZpeCB0byBldmVyeSBrZXkgYW5kIHZhbHVlLlxuICAgICAgICByaWdodC5wcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgcHJvcC52YWx1ZSA9IHQuaWRlbnRpZmllcihjbGFzc1ByZWZpeCArIHByb3AudmFsdWUubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuIl19
