Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _libServiceframeworkConfig = require('../../lib/serviceframework/config');

var config = _interopRequireWildcard(_libServiceframeworkConfig);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _events = require('events');

var _NuclideSocket = require('../NuclideSocket');

var _NuclideSocket2 = _interopRequireDefault(_NuclideSocket);

var _rx = require('rx');

var _config = require('../config');

var _nuclideServiceParserLibTypeRegistry = require('nuclide-service-parser/lib/TypeRegistry');

var _nuclideServiceParserLibTypeRegistry2 = _interopRequireDefault(_nuclideServiceParserLibTypeRegistry);

var _nuclideServiceParser = require('nuclide-service-parser');

'use babel';

var logger = require('nuclide-logging').getLogger();

var ClientComponent = (function () {
  function ClientComponent(emitter, socket, requestIdGenerator) {
    var _this = this;

    _classCallCheck(this, ClientComponent);

    this._emitter = emitter;
    this._socket = socket;
    this._requestIdGenerator = requestIdGenerator;

    this._typeRegistry = new _nuclideServiceParserLibTypeRegistry2['default']();
    this._objectRegistry = new Map();

    // Setup services.
    var services = config.loadServicesConfig();
    for (var service of services) {
      logger.debug('Registering 3.0 service ' + service.name + '...');
      try {
        (function () {
          var defs = (0, _nuclideServiceParser.getDefinitions)(service.definition);
          var proxy = (0, _nuclideServiceParser.getProxy)(service.name, service.definition, _this);

          defs.forEach(function (definition) {
            var name = definition.name;
            switch (definition.kind) {
              case 'alias':
                logger.debug('Registering type alias ' + name + '...');
                if (definition.definition != null) {
                  _this._typeRegistry.registerAlias(name, definition.definition);
                }
                break;
              case 'interface':
                logger.debug('Registering interface ' + name + '.');
                _this._typeRegistry.registerType(name, _asyncToGenerator(function* (object) {
                  return yield object._idPromise;
                }), _asyncToGenerator(function* (objectId) {
                  // Return a cached proxy, if one already exists, for this object.
                  if (_this._objectRegistry.has(objectId)) {
                    return _this._objectRegistry.get(objectId);
                  }

                  // Generate the proxy by manually setting the prototype of the object to be the
                  // prototype of the remote proxy constructor.
                  var object = { _idPromise: Promise.resolve(objectId) };
                  Object.setPrototypeOf(object, proxy[name].prototype);
                  _this._objectRegistry.set(objectId, object);
                  return object;
                }));
                break;
            }
          });
        })();
      } catch (e) {
        logger.error('Failed to load service ' + service.name + '. Stack Trace:\n' + e.stack);
        continue;
      }
    }
  }

  // TODO: This should be a custom marshaller registered in the TypeRegistry

  // Delegate marshalling to the type registry.

  _createClass(ClientComponent, [{
    key: 'marshal',
    value: function marshal() {
      var _typeRegistry;

      return (_typeRegistry = this._typeRegistry).marshal.apply(_typeRegistry, arguments);
    }
  }, {
    key: 'unmarshal',
    value: function unmarshal() {
      var _typeRegistry2;

      return (_typeRegistry2 = this._typeRegistry).unmarshal.apply(_typeRegistry2, arguments);
    }
  }, {
    key: 'registerType',
    value: function registerType() {
      var _typeRegistry3;

      return (_typeRegistry3 = this._typeRegistry).registerType.apply(_typeRegistry3, arguments);
    }

    /**
     * Call a remote function, through the service framework.
     * @param functionName - The name of the remote function to invoke.
     * @param returnType - The type of object that this function returns, so the the transport layer can
     *   register the appropriate listeners.
     * @param args - The serialized arguments to invoke the remote function with.
     */
  }, {
    key: 'callRemoteFunction',
    value: function callRemoteFunction(functionName, returnType, args) {
      var message = {
        protocol: 'service_framework3_rpc',
        type: 'FunctionCall',
        'function': functionName,
        requestId: this._requestIdGenerator(),
        args: args
      };
      return this._sendMessageAndListenForResult(message, returnType, 'Calling function ' + functionName);
    }

    /**
     * Call a method of a remote object, through the service framework.
     * @param objectId - The id of the remote object.
     * @param methodName - The name of the method to invoke.
     * @param returnType - The type of object that this function returns, so the the transport layer can
     *   register the appropriate listeners.
     * @param args - The serialized arguments to invoke the remote method with.
     */
  }, {
    key: 'callRemoteMethod',
    value: function callRemoteMethod(objectId, methodName, returnType, args) {
      var message = {
        protocol: 'service_framework3_rpc',
        type: 'MethodCall',
        method: methodName,
        objectId: objectId,
        requestId: this._requestIdGenerator(),
        args: args
      };
      return this._sendMessageAndListenForResult(message, returnType, 'Calling remote method ' + methodName + '.');
    }

    /**
     * Call a remote constructor, returning an id that eventually resolves to a unique identifier
     * for the object.
     * @param interfaceName - The name of the remote class for which to construct an object.
     * @param args - Serialized arguments to pass to the remote constructor.
     */
  }, {
    key: 'createRemoteObject',
    value: function createRemoteObject(interfaceName, args) {
      var message = {
        protocol: 'service_framework3_rpc',
        type: 'NewObject',
        'interface': interfaceName,
        requestId: this._requestIdGenerator(),
        args: args
      };
      return this._sendMessageAndListenForResult(message, 'promise', 'Creating instance of ' + interfaceName);
    }

    /**
     * Dispose a remote object. This makes it's proxies unsuable, and calls the `dispose` method on
     * the remote object.
     * @param objectId - The numerical id that identifies the remote object.
     * @returns A Promise that resolves when the object disposal has completed.
     */
  }, {
    key: 'disposeRemoteObject',
    value: function disposeRemoteObject(objectId) {
      var message = {
        protocol: 'service_framework3_rpc',
        type: 'DisposeObject',
        requestId: this._requestIdGenerator(),
        objectId: objectId
      };
      return this._sendMessageAndListenForResult(message, 'promise', 'Disposing object ' + objectId);
    }

    /**
     * Helper function that listens for a result for the given requestId.
     * @param returnType - Determines the type of messages we should subscribe to, and what this
     *   function should return.
     * @param requestId - The id of the request who's result we are listening for.
     * @returns Depending on the expected return type, this function either returns undefined, a Promise,
     *   or an Observable.
     */
  }, {
    key: '_sendMessageAndListenForResult',
    value: function _sendMessageAndListenForResult(message, returnType, timeoutMessage) {
      var _this2 = this;

      switch (returnType) {
        case 'void':
          this._socket.send(message);
          return; // No values to return.
        case 'promise':
          // Listen for a single message, and resolve or reject a promise on that message.
          return new Promise(function (resolve, reject) {
            _this2._socket.send(message);
            _this2._emitter.once(message.requestId.toString(), function (hadError, error, result) {
              hadError ? reject(decodeError(error)) : resolve(result);
            });

            setTimeout(function () {
              _this2._emitter.removeAllListeners(message.requestId.toString());
              reject('Timeout after ' + _config.SERVICE_FRAMEWORK_RPC_TIMEOUT_MS + ' for requestId: ' + message.requestId + ', ' + timeoutMessage + '.');
            }, _config.SERVICE_FRAMEWORK_RPC_TIMEOUT_MS);
          });
        case 'observable':
          var observable = _rx.Observable.create(function (observer) {
            _this2._socket.send(message);

            // Listen for 'next', 'error', and 'completed' events.
            _this2._emitter.on(message.requestId.toString(), function (hadError, error, result) {
              if (hadError) {
                observer.onError(decodeError(error));
              } else {
                (0, _assert2['default'])(result);
                if (result.type === 'completed') {
                  observer.onCompleted();
                } else if (result.type === 'next') {
                  observer.onNext(result.data);
                }
              }
            });

            // Observable dispose function, which is called on subscription dipsose, on stream
            // completion, and on stream error.
            return function () {
              _this2._emitter.removeAllListeners(message.requestId.toString());

              // Send a message to server to call the dispose function of
              // the remote Observable subscription.
              var disposeMessage = {
                protocol: 'service_framework3_rpc',
                type: 'DisposeObservable',
                requestId: message.requestId
              };
              _this2._socket.send(disposeMessage);
            };
          });

          return observable;
        default:
          throw new Error('Unkown return type: ' + returnType + '.');
      }
    }
  }]);

  return ClientComponent;
})();

exports['default'] = ClientComponent;
function decodeError(encodedError) {
  if (encodedError != null && typeof encodedError === 'object') {
    var resultError = new Error();
    resultError.message = encodedError.message;
    // $FlowIssue - some Errors (notably file operations) have a code.
    resultError.code = encodedError.code;
    resultError.stack = encodedError.stack;
    return resultError;
  } else {
    return encodedError;
  }
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZlci9saWIvc2VydmljZWZyYW1ld29yay9DbGllbnRDb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0FXd0IsbUNBQW1DOztJQUEvQyxNQUFNOztzQkFFSSxRQUFROzs7O3NCQUNILFFBQVE7OzZCQUNULGtCQUFrQjs7OztrQkFDbkIsSUFBSTs7c0JBQ2tCLFdBQVc7O21EQUVqQyx5Q0FBeUM7Ozs7b0NBQzNCLHdCQUF3Qjs7QUFwQi9ELFdBQVcsQ0FBQzs7QUEwQlosSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7O0lBRWpDLGVBQWU7QUFRdkIsV0FSUSxlQUFlLENBUXRCLE9BQXFCLEVBQUUsTUFBcUIsRUFBRSxrQkFBZ0MsRUFBRTs7OzBCQVJ6RSxlQUFlOztBQVNoQyxRQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztBQUN4QixRQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUN0QixRQUFJLENBQUMsbUJBQW1CLEdBQUcsa0JBQWtCLENBQUM7O0FBRTlDLFFBQUksQ0FBQyxhQUFhLEdBQUcsc0RBQWtCLENBQUM7QUFDeEMsUUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDOzs7QUFHakMsUUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixFQUFFLENBQUM7QUFDN0MsU0FBSyxJQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7QUFDOUIsWUFBTSxDQUFDLEtBQUssOEJBQTRCLE9BQU8sQ0FBQyxJQUFJLFNBQU0sQ0FBQztBQUMzRCxVQUFJOztBQUNGLGNBQU0sSUFBSSxHQUFHLDBCQTdCSCxjQUFjLEVBNkJJLE9BQU8sQ0FBQyxVQUFVLENB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L3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtc2VydmVyL2xpYi9zZXJ2aWNlZnJhbWV3b3JrL0NsaWVudENvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuLi8uLi9saWIvc2VydmljZWZyYW1ld29yay9jb25maWcnO1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge0V2ZW50RW1pdHRlcn0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBOdWNsaWRlU29ja2V0IGZyb20gJy4uL051Y2xpZGVTb2NrZXQnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeCc7XG5pbXBvcnQge1NFUlZJQ0VfRlJBTUVXT1JLX1JQQ19USU1FT1VUX01TfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQgVHlwZVJlZ2lzdHJ5IGZyb20gJ251Y2xpZGUtc2VydmljZS1wYXJzZXIvbGliL1R5cGVSZWdpc3RyeSc7XG5pbXBvcnQge2dldFByb3h5LCBnZXREZWZpbml0aW9uc30gZnJvbSAnbnVjbGlkZS1zZXJ2aWNlLXBhcnNlcic7XG5cbmltcG9ydCB0eXBlIHtSZXF1ZXN0TWVzc2FnZSwgQ2FsbFJlbW90ZUZ1bmN0aW9uTWVzc2FnZSwgQ3JlYXRlUmVtb3RlT2JqZWN0TWVzc2FnZSxcbiAgQ2FsbFJlbW90ZU1ldGhvZE1lc3NhZ2UsIERpc3Bvc2VSZW1vdGVPYmplY3RNZXNzYWdlLCBEaXNwb3NlT2JzZXJ2YWJsZU1lc3NhZ2UsXG4gIFJldHVyblR5cGUsIE9ic2VydmFibGVSZXN1bHR9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpZW50Q29tcG9uZW50IHtcbiAgX2VtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcbiAgX3NvY2tldDogTnVjbGlkZVNvY2tldDtcbiAgX3JlcXVlc3RJZEdlbmVyYXRvcjogKCkgPT4gbnVtYmVyO1xuXG4gIF90eXBlUmVnaXN0cnk6IFR5cGVSZWdpc3RyeTtcbiAgX29iamVjdFJlZ2lzdHJ5OiBNYXA8bnVtYmVyLCBhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKGVtaXR0ZXI6IEV2ZW50RW1pdHRlciwgc29ja2V0OiBOdWNsaWRlU29ja2V0LCByZXF1ZXN0SWRHZW5lcmF0b3I6ICgpID0+IG51bWJlcikge1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcbiAgICB0aGlzLl9yZXF1ZXN0SWRHZW5lcmF0b3IgPSByZXF1ZXN0SWRHZW5lcmF0b3I7XG5cbiAgICB0aGlzLl90eXBlUmVnaXN0cnkgPSBuZXcgVHlwZVJlZ2lzdHJ5KCk7XG4gICAgdGhpcy5fb2JqZWN0UmVnaXN0cnkgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBTZXR1cCBzZXJ2aWNlcy5cbiAgICBjb25zdCBzZXJ2aWNlcyA9IGNvbmZpZy5sb2FkU2VydmljZXNDb25maWcoKTtcbiAgICBmb3IgKGNvbnN0IHNlcnZpY2Ugb2Ygc2VydmljZXMpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgUmVnaXN0ZXJpbmcgMy4wIHNlcnZpY2UgJHtzZXJ2aWNlLm5hbWV9Li4uYCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWZzID0gZ2V0RGVmaW5pdGlvbnMoc2VydmljZS5kZWZpbml0aW9uKTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBnZXRQcm94eShzZXJ2aWNlLm5hbWUsIHNlcnZpY2UuZGVmaW5pdGlvbiwgdGhpcyk7XG5cbiAgICAgICAgZGVmcy5mb3JFYWNoKGRlZmluaXRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZWZpbml0aW9uLm5hbWU7XG4gICAgICAgICAgc3dpdGNoIChkZWZpbml0aW9uLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBSZWdpc3RlcmluZyB0eXBlIGFsaWFzICR7bmFtZX0uLi5gKTtcbiAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uZGVmaW5pdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHlwZVJlZ2lzdHJ5LnJlZ2lzdGVyQWxpYXMobmFtZSwgZGVmaW5pdGlvbi5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUmVnaXN0ZXJpbmcgaW50ZXJmYWNlICR7bmFtZX0uYCk7XG4gICAgICAgICAgICAgIHRoaXMuX3R5cGVSZWdpc3RyeS5yZWdpc3RlclR5cGUobmFtZSwgYXN5bmMgb2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgb2JqZWN0Ll9pZFByb21pc2U7XG4gICAgICAgICAgICAgIH0sIGFzeW5jIG9iamVjdElkID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYSBjYWNoZWQgcHJveHksIGlmIG9uZSBhbHJlYWR5IGV4aXN0cywgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vYmplY3RSZWdpc3RyeS5oYXMob2JqZWN0SWQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0UmVnaXN0cnkuZ2V0KG9iamVjdElkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcHJveHkgYnkgbWFudWFsbHkgc2V0dGluZyB0aGUgcHJvdG90eXBlIG9mIHRoZSBvYmplY3QgdG8gYmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJvdG90eXBlIG9mIHRoZSByZW1vdGUgcHJveHkgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0geyBfaWRQcm9taXNlOiBQcm9taXNlLnJlc29sdmUob2JqZWN0SWQpIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iamVjdCwgcHJveHlbbmFtZV0ucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RSZWdpc3RyeS5zZXQob2JqZWN0SWQsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBzZXJ2aWNlICR7c2VydmljZS5uYW1lfS4gU3RhY2sgVHJhY2U6XFxuJHtlLnN0YWNrfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZWxlZ2F0ZSBtYXJzaGFsbGluZyB0byB0aGUgdHlwZSByZWdpc3RyeS5cbiAgbWFyc2hhbCguLi5hcmdzKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZVJlZ2lzdHJ5Lm1hcnNoYWwoLi4uYXJncyk7XG4gIH1cbiAgdW5tYXJzaGFsKC4uLmFyZ3MpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl90eXBlUmVnaXN0cnkudW5tYXJzaGFsKC4uLmFyZ3MpO1xuICB9XG4gIHJlZ2lzdGVyVHlwZSguLi5hcmdzKTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVSZWdpc3RyeS5yZWdpc3RlclR5cGUoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhIHJlbW90ZSBmdW5jdGlvbiwgdGhyb3VnaCB0aGUgc2VydmljZSBmcmFtZXdvcmsuXG4gICAqIEBwYXJhbSBmdW5jdGlvbk5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVtb3RlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHJldHVyblR5cGUgLSBUaGUgdHlwZSBvZiBvYmplY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMsIHNvIHRoZSB0aGUgdHJhbnNwb3J0IGxheWVyIGNhblxuICAgKiAgIHJlZ2lzdGVyIHRoZSBhcHByb3ByaWF0ZSBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIHNlcmlhbGl6ZWQgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgcmVtb3RlIGZ1bmN0aW9uIHdpdGguXG4gICAqL1xuICBjYWxsUmVtb3RlRnVuY3Rpb24oZnVuY3Rpb25OYW1lOiBzdHJpbmcsIHJldHVyblR5cGU6IFJldHVyblR5cGUsIGFyZ3M6IEFycmF5PGFueT4pOiBhbnkge1xuICAgIGNvbnN0IG1lc3NhZ2U6IENhbGxSZW1vdGVGdW5jdGlvbk1lc3NhZ2UgPSB7XG4gICAgICBwcm90b2NvbDogJ3NlcnZpY2VfZnJhbWV3b3JrM19ycGMnLFxuICAgICAgdHlwZTogJ0Z1bmN0aW9uQ2FsbCcsXG4gICAgICBmdW5jdGlvbjogZnVuY3Rpb25OYW1lLFxuICAgICAgcmVxdWVzdElkOiB0aGlzLl9yZXF1ZXN0SWRHZW5lcmF0b3IoKSxcbiAgICAgIGFyZ3MsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZE1lc3NhZ2VBbmRMaXN0ZW5Gb3JSZXN1bHQobWVzc2FnZSwgcmV0dXJuVHlwZSwgYENhbGxpbmcgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9YCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhIG1ldGhvZCBvZiBhIHJlbW90ZSBvYmplY3QsIHRocm91Z2ggdGhlIHNlcnZpY2UgZnJhbWV3b3JrLlxuICAgKiBAcGFyYW0gb2JqZWN0SWQgLSBUaGUgaWQgb2YgdGhlIHJlbW90ZSBvYmplY3QuXG4gICAqIEBwYXJhbSBtZXRob2ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAqIEBwYXJhbSByZXR1cm5UeXBlIC0gVGhlIHR5cGUgb2Ygb2JqZWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zLCBzbyB0aGUgdGhlIHRyYW5zcG9ydCBsYXllciBjYW5cbiAgICogICByZWdpc3RlciB0aGUgYXBwcm9wcmlhdGUgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBzZXJpYWxpemVkIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIHJlbW90ZSBtZXRob2Qgd2l0aC5cbiAgICovXG4gIGNhbGxSZW1vdGVNZXRob2Qob2JqZWN0SWQ6IG51bWJlciwgbWV0aG9kTmFtZTogc3RyaW5nLCByZXR1cm5UeXBlOiBSZXR1cm5UeXBlLCBhcmdzOiBBcnJheTxhbnk+KTogYW55IHtcbiAgICBjb25zdCBtZXNzYWdlOiBDYWxsUmVtb3RlTWV0aG9kTWVzc2FnZSA9IHtcbiAgICAgIHByb3RvY29sOiAnc2VydmljZV9mcmFtZXdvcmszX3JwYycsXG4gICAgICB0eXBlOiAnTWV0aG9kQ2FsbCcsXG4gICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICBvYmplY3RJZCxcbiAgICAgIHJlcXVlc3RJZDogdGhpcy5fcmVxdWVzdElkR2VuZXJhdG9yKCksXG4gICAgICBhcmdzLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRNZXNzYWdlQW5kTGlzdGVuRm9yUmVzdWx0KG1lc3NhZ2UsIHJldHVyblR5cGUsIGBDYWxsaW5nIHJlbW90ZSBtZXRob2QgJHttZXRob2ROYW1lfS5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGEgcmVtb3RlIGNvbnN0cnVjdG9yLCByZXR1cm5pbmcgYW4gaWQgdGhhdCBldmVudHVhbGx5IHJlc29sdmVzIHRvIGEgdW5pcXVlIGlkZW50aWZpZXJcbiAgICogZm9yIHRoZSBvYmplY3QuXG4gICAqIEBwYXJhbSBpbnRlcmZhY2VOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHJlbW90ZSBjbGFzcyBmb3Igd2hpY2ggdG8gY29uc3RydWN0IGFuIG9iamVjdC5cbiAgICogQHBhcmFtIGFyZ3MgLSBTZXJpYWxpemVkIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSByZW1vdGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBjcmVhdGVSZW1vdGVPYmplY3QoaW50ZXJmYWNlTmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBtZXNzYWdlOiBDcmVhdGVSZW1vdGVPYmplY3RNZXNzYWdlID0ge1xuICAgICAgcHJvdG9jb2w6ICdzZXJ2aWNlX2ZyYW1ld29yazNfcnBjJyxcbiAgICAgIHR5cGU6ICdOZXdPYmplY3QnLFxuICAgICAgaW50ZXJmYWNlOiBpbnRlcmZhY2VOYW1lLFxuICAgICAgcmVxdWVzdElkOiB0aGlzLl9yZXF1ZXN0SWRHZW5lcmF0b3IoKSxcbiAgICAgIGFyZ3MsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZE1lc3NhZ2VBbmRMaXN0ZW5Gb3JSZXN1bHQobWVzc2FnZSwgJ3Byb21pc2UnLCBgQ3JlYXRpbmcgaW5zdGFuY2Ugb2YgJHtpbnRlcmZhY2VOYW1lfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgYSByZW1vdGUgb2JqZWN0LiBUaGlzIG1ha2VzIGl0J3MgcHJveGllcyB1bnN1YWJsZSwgYW5kIGNhbGxzIHRoZSBgZGlzcG9zZWAgbWV0aG9kIG9uXG4gICAqIHRoZSByZW1vdGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gb2JqZWN0SWQgLSBUaGUgbnVtZXJpY2FsIGlkIHRoYXQgaWRlbnRpZmllcyB0aGUgcmVtb3RlIG9iamVjdC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgb2JqZWN0IGRpc3Bvc2FsIGhhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBkaXNwb3NlUmVtb3RlT2JqZWN0KG9iamVjdElkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXNzYWdlOiBEaXNwb3NlUmVtb3RlT2JqZWN0TWVzc2FnZSA9IHtcbiAgICAgIHByb3RvY29sOiAnc2VydmljZV9mcmFtZXdvcmszX3JwYycsXG4gICAgICB0eXBlOiAnRGlzcG9zZU9iamVjdCcsXG4gICAgICByZXF1ZXN0SWQ6IHRoaXMuX3JlcXVlc3RJZEdlbmVyYXRvcigpLFxuICAgICAgb2JqZWN0SWQsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZE1lc3NhZ2VBbmRMaXN0ZW5Gb3JSZXN1bHQobWVzc2FnZSwgJ3Byb21pc2UnLCBgRGlzcG9zaW5nIG9iamVjdCAke29iamVjdElkfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGxpc3RlbnMgZm9yIGEgcmVzdWx0IGZvciB0aGUgZ2l2ZW4gcmVxdWVzdElkLlxuICAgKiBAcGFyYW0gcmV0dXJuVHlwZSAtIERldGVybWluZXMgdGhlIHR5cGUgb2YgbWVzc2FnZXMgd2Ugc2hvdWxkIHN1YnNjcmliZSB0bywgYW5kIHdoYXQgdGhpc1xuICAgKiAgIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4uXG4gICAqIEBwYXJhbSByZXF1ZXN0SWQgLSBUaGUgaWQgb2YgdGhlIHJlcXVlc3Qgd2hvJ3MgcmVzdWx0IHdlIGFyZSBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcmV0dXJucyBEZXBlbmRpbmcgb24gdGhlIGV4cGVjdGVkIHJldHVybiB0eXBlLCB0aGlzIGZ1bmN0aW9uIGVpdGhlciByZXR1cm5zIHVuZGVmaW5lZCwgYSBQcm9taXNlLFxuICAgKiAgIG9yIGFuIE9ic2VydmFibGUuXG4gICAqL1xuICBfc2VuZE1lc3NhZ2VBbmRMaXN0ZW5Gb3JSZXN1bHQobWVzc2FnZTogUmVxdWVzdE1lc3NhZ2UsIHJldHVyblR5cGU6IFJldHVyblR5cGUsIHRpbWVvdXRNZXNzYWdlOiBzdHJpbmcpOiBhbnkge1xuICAgIHN3aXRjaCAocmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAndm9pZCc6XG4gICAgICAgIHRoaXMuX3NvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47IC8vIE5vIHZhbHVlcyB0byByZXR1cm4uXG4gICAgICBjYXNlICdwcm9taXNlJzpcbiAgICAgICAgLy8gTGlzdGVuIGZvciBhIHNpbmdsZSBtZXNzYWdlLCBhbmQgcmVzb2x2ZSBvciByZWplY3QgYSBwcm9taXNlIG9uIHRoYXQgbWVzc2FnZS5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLl9zb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLl9lbWl0dGVyLm9uY2UobWVzc2FnZS5yZXF1ZXN0SWQudG9TdHJpbmcoKSwgKGhhZEVycm9yLCBlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBoYWRFcnJvciA/IHJlamVjdChkZWNvZGVFcnJvcihlcnJvcikpIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhtZXNzYWdlLnJlcXVlc3RJZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlamVjdChgVGltZW91dCBhZnRlciAke1NFUlZJQ0VfRlJBTUVXT1JLX1JQQ19USU1FT1VUX01TfSBmb3IgcmVxdWVzdElkOiAke21lc3NhZ2UucmVxdWVzdElkfSwgJHt0aW1lb3V0TWVzc2FnZX0uYCk7XG4gICAgICAgICAgfSwgU0VSVklDRV9GUkFNRVdPUktfUlBDX1RJTUVPVVRfTVMpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgJ29ic2VydmFibGUnOlxuICAgICAgICBjb25zdCBvYnNlcnZhYmxlID0gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgIHRoaXMuX3NvY2tldC5zZW5kKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgLy8gTGlzdGVuIGZvciAnbmV4dCcsICdlcnJvcicsIGFuZCAnY29tcGxldGVkJyBldmVudHMuXG4gICAgICAgICAgdGhpcy5fZW1pdHRlci5vbihcbiAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAoaGFkRXJyb3I6IGJvb2xlYW4sIGVycm9yOiA/RXJyb3IsIHJlc3VsdDogP09ic2VydmFibGVSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGhhZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihkZWNvZGVFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmFyaWFudChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQudHlwZSA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBPYnNlcnZhYmxlIGRpc3Bvc2UgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCBvbiBzdWJzY3JpcHRpb24gZGlwc29zZSwgb24gc3RyZWFtXG4gICAgICAgICAgLy8gY29tcGxldGlvbiwgYW5kIG9uIHN0cmVhbSBlcnJvci5cbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMobWVzc2FnZS5yZXF1ZXN0SWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIHNlcnZlciB0byBjYWxsIHRoZSBkaXNwb3NlIGZ1bmN0aW9uIG9mXG4gICAgICAgICAgICAvLyB0aGUgcmVtb3RlIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgICAgY29uc3QgZGlzcG9zZU1lc3NhZ2U6IERpc3Bvc2VPYnNlcnZhYmxlTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgcHJvdG9jb2w6ICdzZXJ2aWNlX2ZyYW1ld29yazNfcnBjJyxcbiAgICAgICAgICAgICAgdHlwZTogJ0Rpc3Bvc2VPYnNlcnZhYmxlJyxcbiAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLnJlcXVlc3RJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQuc2VuZChkaXNwb3NlTWVzc2FnZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua293biByZXR1cm4gdHlwZTogJHtyZXR1cm5UeXBlfS5gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgYSBjdXN0b20gbWFyc2hhbGxlciByZWdpc3RlcmVkIGluIHRoZSBUeXBlUmVnaXN0cnlcbmZ1bmN0aW9uIGRlY29kZUVycm9yKGVuY29kZWRFcnJvcjogPyhPYmplY3QgfCBzdHJpbmcpKTogPyhFcnJvciB8IHN0cmluZykge1xuICBpZiAoZW5jb2RlZEVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVuY29kZWRFcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCByZXN1bHRFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgIHJlc3VsdEVycm9yLm1lc3NhZ2UgPSBlbmNvZGVkRXJyb3IubWVzc2FnZTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gc29tZSBFcnJvcnMgKG5vdGFibHkgZmlsZSBvcGVyYXRpb25zKSBoYXZlIGEgY29kZS5cbiAgICByZXN1bHRFcnJvci5jb2RlID0gZW5jb2RlZEVycm9yLmNvZGU7XG4gICAgcmVzdWx0RXJyb3Iuc3RhY2sgPSBlbmNvZGVkRXJyb3Iuc3RhY2s7XG4gICAgcmV0dXJuIHJlc3VsdEVycm9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbmNvZGVkRXJyb3I7XG4gIH1cbn1cbiJdfQ==
