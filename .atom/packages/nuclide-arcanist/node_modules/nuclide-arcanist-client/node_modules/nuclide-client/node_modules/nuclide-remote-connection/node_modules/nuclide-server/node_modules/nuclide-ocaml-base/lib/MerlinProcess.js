Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var getInstance = _asyncToGenerator(function* (file) {
  if (merlinProcessInstance && merlinProcessInstance.isRunning()) {
    return merlinProcessInstance;
  }

  var merlinPath = getPathToMerlin();

  if (!(yield isInstalled(merlinPath))) {
    return null;
  }

  var dotMerlinPath = yield (0, _nuclideCommons.findNearestFile)('.merlin', file);

  var options = {
    cwd: dotMerlinPath ? require('path').dirname(dotMerlinPath) : '.'
  };

  logger.info('Spawning new ocamlmerlin process');
  var process = yield (0, _nuclideCommons.safeSpawn)(merlinPath, [], options);
  merlinProcessInstance = new MerlinProcess(process);

  if (dotMerlinPath) {
    // TODO(pieter) add support for multiple .dotmerlin files
    yield merlinProcessInstance.pushDotMerlinPath(dotMerlinPath);
    logger.debug('Added .merlin path: ' + dotMerlinPath);
  }

  return merlinProcessInstance;
}

/**
 * @return The path to ocamlmerlin on the user's machine. It is recommended not to cache the result
 *   of this function in case the user updates his or her preferences in Atom, in which case the
 *   return value will be stale.
 */
);

exports.getInstance = getInstance;

var isInstalled = _asyncToGenerator(function* (merlinPath) {
  if (isInstalledCache == null) {
    var result = yield (0, _nuclideCommons.checkOutput)('which', [merlinPath]);
    isInstalledCache = result.exitCode === 0;
    if (!isInstalledCache) {
      logger.info('ocamlmerlin not installed');
    }
  }
  return isInstalledCache;
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _nuclideCommons = require('nuclide-commons');

'use babel';

var logger = require('nuclide-logging').getLogger();

var ERROR_RESPONSES = new Set(['failure', 'error', 'exception']);

/**
 * Wraps an ocamlmerlin process; provides api access to
 * ocamlmerlin's json-over-stdin/stdout protocol.
 *
 * This is based on the protocol description at:
 *   https://github.com/the-lambda-church/merlin/blob/master/PROTOCOL.md
 *   https://github.com/the-lambda-church/merlin/tree/master/src/frontend
 */

var MerlinProcess = (function () {
  function MerlinProcess(proc) {
    var _this = this;

    _classCallCheck(this, MerlinProcess);

    this._proc = proc;
    this._promiseQueue = new _nuclideCommons.PromiseQueue();
    this._running = true;
    this._proc.on('exit', function (code, signal) {
      _this._running = false;
    });
  }

  _createClass(MerlinProcess, [{
    key: 'isRunning',
    value: function isRunning() {
      return this._running;
    }

    /**
     * Tell merlin where to find its per-repo .merlin config file.
     *
     * Configuration file format description:
     *   https://github.com/the-lambda-church/merlin/wiki/project-configuration
     *
     * @return a dummy cursor position on success
     */
  }, {
    key: 'pushDotMerlinPath',
    value: _asyncToGenerator(function* (path) {
      var _this2 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        var result = yield _this2.runSingleCommand(['reset', 'dot_merlin', [path], 'auto']);
        resolve(result);
      }));
    })

    /**
     * Set the buffer content to query against. Merlin uses an internal
     * buffer (name + content) that is independent from file content on
     * disk.
     *
     * @return on success: a cursor position pointed at the end of the buffer
     */
  }, {
    key: 'pushNewBuffer',
    value: _asyncToGenerator(function* (name, content) {
      var _this3 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        yield _this3.runSingleCommand(['reset', 'auto', // one of {ml, mli, auto}
        name]);

        var result = yield _this3.runSingleCommand(['tell', 'source', content]);
        resolve(result);
      }));
    })

    /**
     * Find definition
     *
     * `kind` is one of 'ml' or 'mli'
     *
     * Note: ocamlmerlin line numbers are 1-based.
     * @return null if nothing was found; a position of the form
     *   {"file": "somepath", "pos": {"line": 41, "col": 5}}.
     */
  }, {
    key: 'locate',
    value: _asyncToGenerator(function* (path, line, col, kind) {
      var _this4 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        var location = yield _this4.runSingleCommand(['locate',
        /* identifier name */'', kind, 'at', { line: line + 1, col: col }]);

        if (typeof location === 'string') {
          return reject(Error(location));
        }

        // Ocamlmerlin doesn't include a `file` field at all if the destination is
        // in the same file.
        if (!location.file) {
          location.file = path;
        }

        resolve(location);
      }));
    })
  }, {
    key: 'complete',
    value: _asyncToGenerator(function* (path, line, col, prefix) {
      var _this5 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        var result = yield _this5.runSingleCommand(['complete', 'prefix', prefix, 'at', { line: line + 1, col: col + 1 }]);

        resolve(result);
      }));
    })

    /**
     * Run a command; parse the json output, return an object. This assumes
     * that merlin's protocol is line-based (results are json objects rendered
     * on a single line).
     */
  }, {
    key: 'runSingleCommand',
    value: function runSingleCommand(command) {
      var logger = require('nuclide-logging').getLogger();

      var commandString = JSON.stringify(command);
      var stdin = this._proc.stdin;
      var stdout = this._proc.stdout;

      return new Promise(function (resolve, reject) {
        // Flow claims that createInterface is not found, but it obviously can find it since the type
        // hint for `reader` returns Interface, which is the return value of createInterface.
        // $FlowIssue

        var _require = require('readline');

        var createInterface = _require.createInterface;

        var reader = createInterface({
          input: stdout,
          terminal: false
        });

        reader.on('line', function (line) {
          reader.close();
          var response = undefined;
          try {
            response = JSON.parse(line);
          } catch (err) {
            response = null;
          }
          if (!response || !Array.isArray(response) || response.length !== 2) {
            logger.error('Unexpected response from ocamlmerlin: ${line}');
            reject(Error('Unexpected ocamlmerlin output format'));
            return;
          }

          var status = response[0];
          var content = response[1];

          if (ERROR_RESPONSES.has(status)) {
            logger.error('Ocamlmerlin raised an error: ' + line);
            reject(Error('Ocamlmerlin returned an error'));
            return;
          }

          resolve(content);
        });

        stdin.write(commandString);
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._proc.kill();
    }
  }]);

  return MerlinProcess;
})();

exports.MerlinProcess = MerlinProcess;

var merlinProcessInstance = undefined;

function getPathToMerlin() {
  if (global.atom) {
    return global.atom.config.get('nuclide-ocaml.pathToMerlin');
  } else {
    return 'ocamlmerlin';
  }
}

var isInstalledCache = null;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLW9jYW1sLWJhc2UvbGliL01lcmxpblByb2Nlc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFpTnNCLFdBQVcscUJBQTFCLFdBQTJCLElBQWdCLEVBQTJCO0FBQzNFLE1BQUkscUJBQXFCLElBQUkscUJBQXFCLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDOUQsV0FBTyxxQkFBcUIsQ0FBQztHQUM5Qjs7QUFFRCxNQUFNLFVBQVUsR0FBRyxlQUFlLEVBQUUsQ0FBQzs7QUFFckMsTUFBSSxFQUFDLE1BQU0sV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFBLEVBQUU7QUFDbEMsV0FBTyxJQUFJLENBQUM7R0FDYjs7QUFFRCxNQUFNLGFBQWEsR0FBRyxNQUFNLG9CQTdNNUIsZUFBZSxFQTZNNkIsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDOztBQUU3RCxNQUFNLE9BQU8sR0FBRztBQUNkLE9BQUcsRUFBRyxhQUFhLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLEFBQUM7R0FDcEUsQ0FBQzs7QUFFRixRQUFNLENBQUMsSUFBSSxDQUFDLGtDQUFrQyxDQUFDLENBQUM7QUFDaEQsTUFBTSxPQUFPLEdBQUcsTUFBTSxvQkFuTnRCLFNBQVMsRUFtTnVCLFVBQVUsRUFBRSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDekQsdUJBQXFCLEdBQUcsSUFBSSxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRW5ELE1BQUksYUFBYSxFQUFFOztBQUVqQixVQUFNLHFCQUFxQixDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQzdELFVBQU0sQ0FBQyxLQUFLLENBQUMsc0JBQXNCLEdBQUcsYUFBYSxDQUFDLENBQUM7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LGFBQWEsQ0FBQyxDQUFDO09BQzVCLENBQUMsQ0FBQztLQUNKOzs7V0FFTSxtQkFBRztBQUNSLFVBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDbkI7OztTQXhLVSxhQUFhOzs7OztBQTJLMUIsSUFBSSxxQkFBcUMsWUFBQSxDQUFDOztBQXFDMUMsU0FBUyxlQUFlLEdBQVc7QUFDakMsTUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO0FBQ2YsV0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsQ0FBQztHQUM3RCxNQUFNO0FBQ0wsV0FBTyxhQUFhLENBQUM7R0FDdEI7Q0FDRjs7QUFFRCxJQUFJLGdCQUEwQixHQUFHLElBQUksQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1vY2FtbC1iYXNlL2xpYi9NZXJsaW5Qcm9jZXNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHR5cGUge051Y2xpZGVVcml9IGZyb20gJ251Y2xpZGUtcmVtb3RlLXVyaSc7XG5cbmltcG9ydCB7XG4gIGNoZWNrT3V0cHV0LFxuICBmaW5kTmVhcmVzdEZpbGUsXG4gIHNhZmVTcGF3bixcbiAgUHJvbWlzZVF1ZXVlLFxufSBmcm9tICdudWNsaWRlLWNvbW1vbnMnO1xuXG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcblxuY29uc3QgRVJST1JfUkVTUE9OU0VTID0gbmV3IFNldChbXG4gICdmYWlsdXJlJyxcbiAgJ2Vycm9yJyxcbiAgJ2V4Y2VwdGlvbicsXG5dKTtcblxuLyoqXG4gKiBXcmFwcyBhbiBvY2FtbG1lcmxpbiBwcm9jZXNzOyBwcm92aWRlcyBhcGkgYWNjZXNzIHRvXG4gKiBvY2FtbG1lcmxpbidzIGpzb24tb3Zlci1zdGRpbi9zdGRvdXQgcHJvdG9jb2wuXG4gKlxuICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgcHJvdG9jb2wgZGVzY3JpcHRpb24gYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS90aGUtbGFtYmRhLWNodXJjaC9tZXJsaW4vYmxvYi9tYXN0ZXIvUFJPVE9DT0wubWRcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL3RoZS1sYW1iZGEtY2h1cmNoL21lcmxpbi90cmVlL21hc3Rlci9zcmMvZnJvbnRlbmRcbiAqL1xuZXhwb3J0IGNsYXNzIE1lcmxpblByb2Nlc3Mge1xuICBfcHJvYzogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M7XG4gIF9wcm9taXNlUXVldWU6IFByb21pc2VRdWV1ZTtcbiAgX3J1bm5pbmc6IGJvb2w7XG5cbiAgY29uc3RydWN0b3IocHJvYzogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MpIHtcbiAgICB0aGlzLl9wcm9jID0gcHJvYztcbiAgICB0aGlzLl9wcm9taXNlUXVldWUgPSBuZXcgUHJvbWlzZVF1ZXVlKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5fcHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHsgdGhpcy5fcnVubmluZyA9IGZhbHNlOyB9KTtcbiAgfVxuXG4gIGlzUnVubmluZygpOiBib29sIHtcbiAgICByZXR1cm4gdGhpcy5fcnVubmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxsIG1lcmxpbiB3aGVyZSB0byBmaW5kIGl0cyBwZXItcmVwbyAubWVybGluIGNvbmZpZyBmaWxlLlxuICAgKlxuICAgKiBDb25maWd1cmF0aW9uIGZpbGUgZm9ybWF0IGRlc2NyaXB0aW9uOlxuICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS90aGUtbGFtYmRhLWNodXJjaC9tZXJsaW4vd2lraS9wcm9qZWN0LWNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHJldHVybiBhIGR1bW15IGN1cnNvciBwb3NpdGlvbiBvbiBzdWNjZXNzXG4gICAqL1xuICBhc3luYyBwdXNoRG90TWVybGluUGF0aChwYXRoOiBOdWNsaWRlVXJpKTogUHJvbWlzZTxtaXhlZD4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9wcm9taXNlUXVldWUuc3VibWl0KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuU2luZ2xlQ29tbWFuZChbXG4gICAgICAgICdyZXNldCcsXG4gICAgICAgICdkb3RfbWVybGluJyxcbiAgICAgICAgW3BhdGhdLFxuICAgICAgICAnYXV0bycsXG4gICAgICBdKTtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGJ1ZmZlciBjb250ZW50IHRvIHF1ZXJ5IGFnYWluc3QuIE1lcmxpbiB1c2VzIGFuIGludGVybmFsXG4gICAqIGJ1ZmZlciAobmFtZSArIGNvbnRlbnQpIHRoYXQgaXMgaW5kZXBlbmRlbnQgZnJvbSBmaWxlIGNvbnRlbnQgb25cbiAgICogZGlzay5cbiAgICpcbiAgICogQHJldHVybiBvbiBzdWNjZXNzOiBhIGN1cnNvciBwb3NpdGlvbiBwb2ludGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgKi9cbiAgYXN5bmMgcHVzaE5ld0J1ZmZlcihuYW1lOiBOdWNsaWRlVXJpLCBjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPG1peGVkPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3Byb21pc2VRdWV1ZS5zdWJtaXQoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5ydW5TaW5nbGVDb21tYW5kKFtcbiAgICAgICAgJ3Jlc2V0JyxcbiAgICAgICAgJ2F1dG8nLCAvLyBvbmUgb2Yge21sLCBtbGksIGF1dG99XG4gICAgICAgIG5hbWUsXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5TaW5nbGVDb21tYW5kKFtcbiAgICAgICAgJ3RlbGwnLFxuICAgICAgICAnc291cmNlJyxcbiAgICAgICAgY29udGVudCxcbiAgICAgIF0pO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgZGVmaW5pdGlvblxuICAgKlxuICAgKiBga2luZGAgaXMgb25lIG9mICdtbCcgb3IgJ21saSdcbiAgICpcbiAgICogTm90ZTogb2NhbWxtZXJsaW4gbGluZSBudW1iZXJzIGFyZSAxLWJhc2VkLlxuICAgKiBAcmV0dXJuIG51bGwgaWYgbm90aGluZyB3YXMgZm91bmQ7IGEgcG9zaXRpb24gb2YgdGhlIGZvcm1cbiAgICogICB7XCJmaWxlXCI6IFwic29tZXBhdGhcIiwgXCJwb3NcIjoge1wibGluZVwiOiA0MSwgXCJjb2xcIjogNX19LlxuICAgKi9cbiAgYXN5bmMgbG9jYXRlKFxuICAgIHBhdGg6IE51Y2xpZGVVcmksXG4gICAgbGluZTogbnVtYmVyLFxuICAgIGNvbDogbnVtYmVyLFxuICAgIGtpbmQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTw/e2ZpbGU6IHN0cmluZywgcG9zOiB7bGluZTogbnVtYmVyLCBjb2w6IG51bWJlcn19PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3Byb21pc2VRdWV1ZS5zdWJtaXQoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbG9jYXRpb246IE9iamVjdCA9IGF3YWl0IHRoaXMucnVuU2luZ2xlQ29tbWFuZChbXG4gICAgICAgICdsb2NhdGUnLFxuICAgICAgICAvKiBpZGVudGlmaWVyIG5hbWUgKi8gJycsXG4gICAgICAgIGtpbmQsXG4gICAgICAgICdhdCcsXG4gICAgICAgIHtsaW5lOiBsaW5lICsgMSwgY29sfSxcbiAgICAgIF0pO1xuXG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoRXJyb3IobG9jYXRpb24pKTtcbiAgICAgIH1cblxuICAgICAgLy8gT2NhbWxtZXJsaW4gZG9lc24ndCBpbmNsdWRlIGEgYGZpbGVgIGZpZWxkIGF0IGFsbCBpZiB0aGUgZGVzdGluYXRpb24gaXNcbiAgICAgIC8vIGluIHRoZSBzYW1lIGZpbGUuXG4gICAgICBpZiAoIWxvY2F0aW9uLmZpbGUpIHtcbiAgICAgICAgbG9jYXRpb24uZmlsZSA9IHBhdGg7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUobG9jYXRpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY29tcGxldGUocGF0aDogTnVjbGlkZVVyaSwgbGluZTogbnVtYmVyLCBjb2w6IG51bWJlciwgcHJlZml4OiBzdHJpbmcpOiBQcm9taXNlPG1peGVkPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3Byb21pc2VRdWV1ZS5zdWJtaXQoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5TaW5nbGVDb21tYW5kKFtcbiAgICAgICAgJ2NvbXBsZXRlJyxcbiAgICAgICAgJ3ByZWZpeCcsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgJ2F0JyxcbiAgICAgICAge2xpbmU6IGxpbmUgKyAxLCBjb2w6IGNvbCArIDF9LFxuICAgICAgXSk7XG5cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJ1biBhIGNvbW1hbmQ7IHBhcnNlIHRoZSBqc29uIG91dHB1dCwgcmV0dXJuIGFuIG9iamVjdC4gVGhpcyBhc3N1bWVzXG4gICAqIHRoYXQgbWVybGluJ3MgcHJvdG9jb2wgaXMgbGluZS1iYXNlZCAocmVzdWx0cyBhcmUganNvbiBvYmplY3RzIHJlbmRlcmVkXG4gICAqIG9uIGEgc2luZ2xlIGxpbmUpLlxuICAgKi9cbiAgcnVuU2luZ2xlQ29tbWFuZChjb21tYW5kOiBtaXhlZCk6IFByb21pc2U8bWl4ZWQ+IHtcbiAgICBjb25zdCBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcblxuICAgIGNvbnN0IGNvbW1hbmRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjb21tYW5kKTtcbiAgICBjb25zdCBzdGRpbiA9IHRoaXMuX3Byb2Muc3RkaW47XG4gICAgY29uc3Qgc3Rkb3V0ID0gdGhpcy5fcHJvYy5zdGRvdXQ7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gRmxvdyBjbGFpbXMgdGhhdCBjcmVhdGVJbnRlcmZhY2UgaXMgbm90IGZvdW5kLCBidXQgaXQgb2J2aW91c2x5IGNhbiBmaW5kIGl0IHNpbmNlIHRoZSB0eXBlXG4gICAgICAvLyBoaW50IGZvciBgcmVhZGVyYCByZXR1cm5zIEludGVyZmFjZSwgd2hpY2ggaXMgdGhlIHJldHVybiB2YWx1ZSBvZiBjcmVhdGVJbnRlcmZhY2UuXG4gICAgICAvLyAkRmxvd0lzc3VlXG4gICAgICBjb25zdCB7Y3JlYXRlSW50ZXJmYWNlfSA9IHJlcXVpcmUoJ3JlYWRsaW5lJyk7XG4gICAgICBjb25zdCByZWFkZXIgPSBjcmVhdGVJbnRlcmZhY2Uoe1xuICAgICAgICBpbnB1dDogc3Rkb3V0LFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgcmVhZGVyLm9uKCdsaW5lJywgKGxpbmUpID0+IHtcbiAgICAgICAgcmVhZGVyLmNsb3NlKCk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlIHx8ICFBcnJheS5pc0FycmF5KHJlc3BvbnNlKSB8fCByZXNwb25zZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSBvY2FtbG1lcmxpbjogJHtsaW5lfScpO1xuICAgICAgICAgIHJlamVjdChFcnJvcignVW5leHBlY3RlZCBvY2FtbG1lcmxpbiBvdXRwdXQgZm9ybWF0JykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlWzBdO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gcmVzcG9uc2VbMV07XG5cbiAgICAgICAgaWYgKEVSUk9SX1JFU1BPTlNFUy5oYXMoc3RhdHVzKSkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignT2NhbWxtZXJsaW4gcmFpc2VkIGFuIGVycm9yOiAnICsgbGluZSk7XG4gICAgICAgICAgcmVqZWN0KEVycm9yKCdPY2FtbG1lcmxpbiByZXR1cm5lZCBhbiBlcnJvcicpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHN0ZGluLndyaXRlKGNvbW1hbmRTdHJpbmcpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9wcm9jLmtpbGwoKTtcbiAgfVxufVxuXG5sZXQgbWVybGluUHJvY2Vzc0luc3RhbmNlOiA/TWVybGluUHJvY2VzcztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEluc3RhbmNlKGZpbGU6IE51Y2xpZGVVcmkpOiBQcm9taXNlPD9NZXJsaW5Qcm9jZXNzPiB7XG4gIGlmIChtZXJsaW5Qcm9jZXNzSW5zdGFuY2UgJiYgbWVybGluUHJvY2Vzc0luc3RhbmNlLmlzUnVubmluZygpKSB7XG4gICAgcmV0dXJuIG1lcmxpblByb2Nlc3NJbnN0YW5jZTtcbiAgfVxuXG4gIGNvbnN0IG1lcmxpblBhdGggPSBnZXRQYXRoVG9NZXJsaW4oKTtcblxuICBpZiAoIWF3YWl0IGlzSW5zdGFsbGVkKG1lcmxpblBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBkb3RNZXJsaW5QYXRoID0gYXdhaXQgZmluZE5lYXJlc3RGaWxlKCcubWVybGluJywgZmlsZSk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBjd2Q6IChkb3RNZXJsaW5QYXRoID8gcmVxdWlyZSgncGF0aCcpLmRpcm5hbWUoZG90TWVybGluUGF0aCkgOiAnLicpLFxuICB9O1xuXG4gIGxvZ2dlci5pbmZvKCdTcGF3bmluZyBuZXcgb2NhbWxtZXJsaW4gcHJvY2VzcycpO1xuICBjb25zdCBwcm9jZXNzID0gYXdhaXQgc2FmZVNwYXduKG1lcmxpblBhdGgsIFtdLCBvcHRpb25zKTtcbiAgbWVybGluUHJvY2Vzc0luc3RhbmNlID0gbmV3IE1lcmxpblByb2Nlc3MocHJvY2Vzcyk7XG5cbiAgaWYgKGRvdE1lcmxpblBhdGgpIHtcbiAgICAvLyBUT0RPKHBpZXRlcikgYWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIC5kb3RtZXJsaW4gZmlsZXNcbiAgICBhd2FpdCBtZXJsaW5Qcm9jZXNzSW5zdGFuY2UucHVzaERvdE1lcmxpblBhdGgoZG90TWVybGluUGF0aCk7XG4gICAgbG9nZ2VyLmRlYnVnKCdBZGRlZCAubWVybGluIHBhdGg6ICcgKyBkb3RNZXJsaW5QYXRoKTtcbiAgfVxuXG4gIHJldHVybiBtZXJsaW5Qcm9jZXNzSW5zdGFuY2U7XG59XG5cbi8qKlxuICogQHJldHVybiBUaGUgcGF0aCB0byBvY2FtbG1lcmxpbiBvbiB0aGUgdXNlcidzIG1hY2hpbmUuIEl0IGlzIHJlY29tbWVuZGVkIG5vdCB0byBjYWNoZSB0aGUgcmVzdWx0XG4gKiAgIG9mIHRoaXMgZnVuY3Rpb24gaW4gY2FzZSB0aGUgdXNlciB1cGRhdGVzIGhpcyBvciBoZXIgcHJlZmVyZW5jZXMgaW4gQXRvbSwgaW4gd2hpY2ggY2FzZSB0aGVcbiAqICAgcmV0dXJuIHZhbHVlIHdpbGwgYmUgc3RhbGUuXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhUb01lcmxpbigpOiBzdHJpbmcge1xuICBpZiAoZ2xvYmFsLmF0b20pIHtcbiAgICByZXR1cm4gZ2xvYmFsLmF0b20uY29uZmlnLmdldCgnbnVjbGlkZS1vY2FtbC5wYXRoVG9NZXJsaW4nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ29jYW1sbWVybGluJztcbiAgfVxufVxuXG5sZXQgaXNJbnN0YWxsZWRDYWNoZTogP2Jvb2xlYW4gPSBudWxsO1xuYXN5bmMgZnVuY3Rpb24gaXNJbnN0YWxsZWQobWVybGluUGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGlmIChpc0luc3RhbGxlZENhY2hlID09IG51bGwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja091dHB1dCgnd2hpY2gnLCBbbWVybGluUGF0aF0pO1xuICAgIGlzSW5zdGFsbGVkQ2FjaGUgPSByZXN1bHQuZXhpdENvZGUgPT09IDA7XG4gICAgaWYgKCFpc0luc3RhbGxlZENhY2hlKSB7XG4gICAgICBsb2dnZXIuaW5mbygnb2NhbWxtZXJsaW4gbm90IGluc3RhbGxlZCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNJbnN0YWxsZWRDYWNoZTtcbn1cbiJdfQ==
