Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _config = require('./config');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _serviceframework = require('./serviceframework');

var _serviceframework2 = _interopRequireDefault(_serviceframework);

var _nuclideLogging = require('nuclide-logging');

'use babel';

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var blocked = require('./blocked');
var connect = require('connect');

var _require = require('./service-manager');

var getService = _require.getService;
var getRemoteEventName = _require.getRemoteEventName;

var http = require('http');
var https = require('https');

var _require2 = require('nuclide-service-transformer');

var parseServiceApiSync = _require2.parseServiceApiSync;

var _require3 = require('events');

var EventEmitter = _require3.EventEmitter;

var WebSocketServer = require('ws').Server;

var _require4 = require('./utils');

var deserializeArgs = _require4.deserializeArgs;
var sendJsonResponse = _require4.sendJsonResponse;
var sendTextResponse = _require4.sendTextResponse;

var _require5 = require('nuclide-version');

var getVersion = _require5.getVersion;

var logger = (0, _nuclideLogging.getLogger)();

var EVENT_HANDLE_REGISTERED = '_nuclideServerEventHandleRegstered';

var NuclideServer = (function () {
  function NuclideServer(options) {
    _classCallCheck(this, NuclideServer);

    (0, _assert2['default'])(NuclideServer._theServer == null);
    NuclideServer._theServer = this;

    var serverKey = options.serverKey;
    var serverCertificate = options.serverCertificate;
    var port = options.port;
    var certificateAuthorityCertificate = options.certificateAuthorityCertificate;
    var trackEventLoop = options.trackEventLoop;

    this._app = connect();
    this._attachUtilHandlers(this._app);
    if (serverKey && serverCertificate && certificateAuthorityCertificate) {
      var webServerOptions = {
        key: serverKey,
        cert: serverCertificate,
        ca: certificateAuthorityCertificate,
        requestCert: true,
        rejectUnauthorized: true
      };

      this._webServer = https.createServer(webServerOptions, this._app);
    } else {
      this._webServer = http.createServer(this._app);
    }
    this._port = port;

    this._webSocketServer = this._createWebSocketServer();
    this._clients = {};
    this._eventSubscriptions = new Map();

    this._setupServices(); // Setup 1.0 and 2.0 services.

    if (trackEventLoop) {
      blocked(function (ms) {
        logger.info('NuclideServer event loop blocked for ' + ms + 'ms');
      });
    }

    // Setup 3.0 services.
    this._serverComponent = new _serviceframework2['default'].ServerComponent(this);
  }

  _createClass(NuclideServer, [{
    key: '_attachUtilHandlers',
    value: function _attachUtilHandlers(app) {
      var _this = this;

      // Add specific method handlers.
      ['get', 'post', 'delete', 'put'].forEach(function (methodName) {
        _this._app[methodName] = function (uri, handler) {
          _this._app.use(uri, function (request, response, next) {
            if (request.method.toUpperCase() !== methodName.toUpperCase()) {
              // skip if method doesn't match.
              return next();
            } else {
              handler(request, response, next);
            }
          });
        };
      });
    }
  }, {
    key: '_createWebSocketServer',
    value: function _createWebSocketServer() {
      var _this2 = this;

      var webSocketServer = new WebSocketServer({ server: this._webServer });
      webSocketServer.on('connection', function (socket) {
        return _this2._onConnection(socket);
      });
      webSocketServer.on('error', function (error) {
        return logger.error('WebSocketServer Error:', error);
      });
      return webSocketServer;
    }
  }, {
    key: '_getServiceFrameworkServiceAndRegisterEventHandle',
    value: function _getServiceFrameworkServiceAndRegisterEventHandle(serviceConfig, serviceOptions) {
      var _this3 = this;

      var localServiceInstance = getService(serviceConfig.name, serviceOptions, serviceConfig.implementation);
      if (localServiceInstance[EVENT_HANDLE_REGISTERED]) {
        return localServiceInstance;
      }

      var serviceApi = parseServiceApiSync(serviceConfig.definition, serviceConfig.name);

      serviceApi.eventMethodNames.forEach(function (methodName) {
        localServiceInstance[methodName].call(localServiceInstance, function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var eventName = getRemoteEventName(serviceConfig.name, methodName, serviceOptions);
          (_this3._eventSubscriptions.get(eventName) || []).forEach(function (clientId) {
            var client = _this3._clients[clientId];

            if (!client) {
              logger.warn('Client with clientId: %s not found!', clientId);
              return;
            }

            _this3._sendSocketMessage(client, {
              channel: _config.SERVICE_FRAMEWORK_EVENT_CHANNEL,
              event: {
                name: eventName,
                args: args
              }
            });
          });
        });
      });
      Object.defineProperty(localServiceInstance, EVENT_HANDLE_REGISTERED, { value: true });

      return localServiceInstance;
    }
  }, {
    key: '_registerServiceWithServiceFramework',
    value: function _registerServiceWithServiceFramework(serviceConfig) {
      var _this4 = this;

      var serviceApi = parseServiceApiSync(serviceConfig.definition, serviceConfig.name);

      serviceApi.rpcMethodNames.forEach(function (methodName) {
        _this4._registerService('/' + serviceApi.className + '/' + methodName,

        // Take serviceOptions as first argument for serviceFramework service.
        // TODO(chenshen) seperate the logic of service initialization.
        function (serviceOptions) {
          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          var localServiceInstance = _this4._getServiceFrameworkServiceAndRegisterEventHandle(serviceConfig, serviceOptions);
          return localServiceInstance[methodName].apply(localServiceInstance, args);
        }, 'post');
      });
    }
  }, {
    key: '_registerServiceWithoutServiceFramework',
    value: function _registerServiceWithoutServiceFramework(serviceFilePath) {
      var _require6 = require(serviceFilePath);

      var urlHandlers = _require6.urlHandlers;
      var services = _require6.services;
      var initialize = _require6.initialize;

      for (var serviceName in services) {
        var serviceConfig = services[serviceName];
        this._registerService(serviceName, serviceConfig.handler, serviceConfig.method, serviceConfig.text);
      }

      if (urlHandlers) {
        for (var url in urlHandlers) {
          var handlerConfig = urlHandlers[url];
          this._attachUrlHandler(url, handlerConfig.handler, handlerConfig.method);
        }
      }

      if (initialize) {
        initialize(this);
      }
    }
  }, {
    key: '_setupServices',
    value: function _setupServices() {
      var _this5 = this;

      // Lazy require these functions so that we could spyOn them while testing in
      // ServiceIntegrationTestHelper.

      var _require7 = require('./config');

      var loadConfigsOfServiceWithServiceFramework = _require7.loadConfigsOfServiceWithServiceFramework;
      var loadConfigsOfServiceWithoutServiceFramework = _require7.loadConfigsOfServiceWithoutServiceFramework;

      this._serviceRegistry = {};
      this._version = getVersion().toString();
      this._setupHeartbeatHandler();
      this._setupServiceFrameworkSubscriptionHandler();
      this._serviceWithoutServiceFrameworkConfigs = loadConfigsOfServiceWithoutServiceFramework();
      this._serviceWithServiceFrameworkConfigs = loadConfigsOfServiceWithServiceFramework();

      this._serviceWithoutServiceFrameworkConfigs.forEach(function (config) {
        _this5._registerServiceWithoutServiceFramework(config);
        logger.debug('Registered service ' + config + ' without ServiceFramework.');
      });

      this._serviceWithServiceFrameworkConfigs.forEach(function (config) {
        _this5._registerServiceWithServiceFramework(config);
        logger.debug('Registered service ' + config.name + ' with ServiceFramework.');
      });

      // Setup error handler.
      this._app.use(function (error, request, response, next) {
        if (error) {
          sendJsonResponse(response, { code: error.code, message: error.message }, 500);
        } else {
          next();
        }
      });
    }
  }, {
    key: '_setupHeartbeatHandler',
    value: function _setupHeartbeatHandler() {
      var _this6 = this;

      this._registerService('/' + _config.HEARTBEAT_CHANNEL, _asyncToGenerator(function* () {
        return _this6._version;
      }), 'post', true);
    }
  }, {
    key: '_setupServiceFrameworkSubscriptionHandler',
    value: function _setupServiceFrameworkSubscriptionHandler() {
      var _this7 = this;

      this._registerService('/serviceFramework/subscribeEvent', function (serviceOptions, clientId, serviceName, methodName) {

        // Create the service instance and register the event handle.

        var _serviceWithServiceFrameworkConfigs$filter = _this7._serviceWithServiceFrameworkConfigs.filter(function (config) {
          return config.name === serviceName;
        });

        var _serviceWithServiceFrameworkConfigs$filter2 = _slicedToArray(_serviceWithServiceFrameworkConfigs$filter, 1);

        var serviceConfig = _serviceWithServiceFrameworkConfigs$filter2[0];

        _this7._getServiceFrameworkServiceAndRegisterEventHandle(serviceConfig, serviceOptions);

        var eventName = getRemoteEventName(serviceName, methodName, serviceOptions);

        _this7._eventSubscriptions.set(eventName, (_this7._eventSubscriptions.get(eventName) || new Set()).add(clientId));

        logger.debug(clientId + ' subscribed to ' + eventName);
      }, 'post');

      this._registerService('/serviceFramework/unsubscribeEvent', function (serviceOptions, clientId, serviceName, methodName) {
        var eventName = getRemoteEventName(serviceName, methodName, serviceOptions);
        if (_this7._eventSubscriptions.has(eventName)) {
          _this7._eventSubscriptions.get(eventName)['delete'](clientId);
        }
        logger.debug(clientId + ' unsubscribed to ' + eventName);
      }, 'post');
    }
  }, {
    key: 'connect',
    value: function connect() {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        _this8._webServer.on('listening', function () {
          resolve();
        });
        _this8._webServer.on('error', function (e) {
          _this8._webServer.removeAllListeners();
          reject(e);
        });
        _this8._webServer.listen(_this8._port);
      });
    }

    /**
     * Calls a registered service with a name and arguments.
     */
  }, {
    key: 'callService',
    value: function callService(serviceName, args) {
      var serviceFunction = this._serviceRegistry[serviceName];
      if (!serviceFunction) {
        throw Error('No service registered with name: ' + serviceName);
      }
      return serviceFunction.apply(this, args);
    }

    /**
     * Registers a service function to a service name.
     * This allows simple future calls of the service by name and arguments or http-triggered endpoint calls
     * with arguments serialized over http.
     */
  }, {
    key: '_registerService',
    value: function _registerService(serviceName, serviceFunction, method, isTextResponse) {
      if (method === undefined) method = 'get';

      if (this._serviceRegistry[serviceName]) {
        throw new Error('A service with this name is already registered:', serviceName);
      }
      this._serviceRegistry[serviceName] = serviceFunction;
      this._registerHttpService(serviceName, method, isTextResponse);
    }
  }, {
    key: '_registerHttpService',
    value: function _registerHttpService(serviceName, method, isTextResponse) {
      var _this9 = this;

      var loweredCaseMethod = method.toLowerCase();
      this._app[loweredCaseMethod](serviceName, _asyncToGenerator(function* (request, response, next) {
        try {
          var result = yield _this9.callService(serviceName, deserializeArgs(request.url));
          if (isTextResponse) {
            sendTextResponse(response, result || '');
          } else {
            sendJsonResponse(response, result);
          }
        } catch (e) {
          // Delegate to the registered connect error handler.
          next(e);
        }
      }));
    }

    /**
     * Attach an explicit http connect handler for some services that need request/response related optimizations.
     * e.g. readFile and writeFile uses it to stream reading and writing files (perf improvement for big files).
     */
  }, {
    key: '_attachUrlHandler',
    value: function _attachUrlHandler(url, handler) {
      var method = arguments.length <= 2 || arguments[2] === undefined ? 'get' : arguments[2];

      this._app[method](url, handler);
    }
  }, {
    key: '_onConnection',
    value: function _onConnection(socket) {
      var _this10 = this;

      logger.debug('WebSocket connecting');

      var client = null;

      socket.on('error', function (e) {
        return logger.error('Client #%s error: %s', client ? client.id : 'unkown', e.message);
      });

      socket.once('message', function (clientId) {
        client = _this10._clients[clientId] = _this10._clients[clientId] || { subscriptions: {}, id: clientId, messageQueue: [] };
        // If an existing client, we close its socket before listening to the new socket.
        if (client.socket) {
          client.socket.close();
          client.socket = null;
        }
        logger.info('Client #%s connecting with a new socket!', clientId);
        client.socket = socket;
        client.messageQueue.splice(0).forEach(function (message) {
          return _this10._sendSocketMessage(client, message.data);
        });
        socket.on('message', function (message) {
          return _this10._onSocketMessage(client, message);
        });
      });

      socket.on('close', function () {
        if (!client) {
          return;
        }
        if (client.socket === socket) {
          client.socket = null;
        }
        logger.info('Client #%s closing a socket!', client.id);
        // TODO: enable subscription cleanup when we have a robust reconnect scenario.
        /*
        for (var channel in client.subscriptions) {
          this.unsubscribe(channel, subscriptions[channel]);
        }
        this._eventSubscriptions.forEach(value => value.delete(client.id));
        delete this._clients[client.id];
        */
      });
    }
  }, {
    key: '_onSocketMessage',
    value: _asyncToGenerator(function* (client, message) {
      message = JSON.parse(message);
      if (message.protocol && message.protocol === _config.SERVICE_FRAMEWORK3_CHANNEL) {
        this._serverComponent.handleMessage(client, message);
        return;
      }

      var _message = message;
      var serviceName = _message.serviceName;
      var methodName = _message.methodName;
      var methodArgs = _message.methodArgs;
      var serviceOptions = _message.serviceOptions;
      var requestId = _message.requestId;

      var result = null;
      var error = null;

      try {
        result = yield this.callService('/' + serviceName + '/' + methodName, [serviceOptions].concat(methodArgs));
      } catch (e) {
        logger.error('Failed to call %s/%s with error %o', serviceName, methodName, e);
        error = e;
      }

      this._sendSocketMessage(client, {
        channel: _config.SERVICE_FRAMEWORK_RPC_CHANNEL,
        requestId: requestId,
        result: result,
        error: error
      });
    })
  }, {
    key: '_sendSocketMessage',
    value: function _sendSocketMessage(client, data) {
      // Wrap the data in an object, because if `data` is a primitive data type,
      // finding it in an array would return the first matching item, not necessarily the same inserted item.
      var message = { data: data };
      var id = client.id;
      var socket = client.socket;
      var messageQueue = client.messageQueue;

      messageQueue.push(message);
      if (!socket) {
        return;
      }
      socket.send(JSON.stringify(data), function (err) {
        if (err) {
          logger.warn('Failed sending socket message to client:', id, data);
        } else {
          var messageIndex = messageQueue.indexOf(message);
          if (messageIndex !== -1) {
            messageQueue.splice(messageIndex, 1);
          }
        }
      });
    }
  }, {
    key: 'close',
    value: function close() {
      var _this11 = this;

      (0, _assert2['default'])(NuclideServer._theServer === this);
      NuclideServer._theServer = null;

      this._webSocketServer.close();
      this._webServer.close();
      this._serviceWithoutServiceFrameworkConfigs.forEach(function (service_path) {
        var _require8 = require(service_path);

        var shutdown = _require8.shutdown;

        if (shutdown) {
          shutdown(_this11);
        }
      });
    }
  }], [{
    key: 'shutdown',
    value: function shutdown() {
      logger.info('Shutting down the server');
      try {
        if (NuclideServer._theServer != null) {
          NuclideServer._theServer.close();
        }
      } catch (e) {
        logger.error('Error while shutting down, but proceeding anyway:', e);
      } finally {
        (0, _nuclideLogging.flushLogsAndExit)(0);
      }
    }
  }]);

  return NuclideServer;
})();

module.exports = NuclideServer;
/* eventName */ /* clientId */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZlci9saWIvTnVjbGlkZVNlcnZlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztzQkFxQm1DLFVBQVU7O3NCQU92QixRQUFROzs7O2dDQUNELG9CQUFvQjs7Ozs4QkFFUCxpQkFBaUI7O0FBL0IzRCxXQUFXLENBQUM7Ozs7Ozs7Ozs7QUFXWixJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDckMsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztlQUVNLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQzs7SUFBOUQsVUFBVSxZQUFWLFVBQVU7SUFBRSxrQkFBa0IsWUFBbEIsa0JBQWtCOztBQUNyQyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0IsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztnQkFNRCxPQUFPLENBQUMsNkJBQTZCLENBQUM7O0lBQTdELG1CQUFtQixhQUFuQixtQkFBbUI7O2dCQUVILE9BQU8sQ0FBQyxRQUFRLENBQUM7O0lBQWpDLFlBQVksYUFBWixZQUFZOztBQUNuQixJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDOztnQkFDaUIsT0FBTyxDQUFDLFNBQVMsQ0FBQzs7SUFBekUsZUFBZSxhQUFmLGVBQWU7SUFBRSxnQkFBZ0IsYUFBaEIsZ0JBQWdCO0lBQUUsZ0JBQWdCLGFBQWhCLGdCQUFnQjs7Z0JBQ3JDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQzs7SUFBeEMsVUFBVSxhQUFWLFVBQVU7O0FBS2pCLElBQU0sTUFBTSxHQUFHLG9CQURQLFNBQVMsR0FDUyxDQUFDOztBQUszQixJQUFNLHVCQUF1QixH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Q0FBQyxDQUFDLENBQUM7T0FDdEUsU0FBUztBQUNSLDRCQWhPYSxnQkFBZ0IsRUFnT1osQ0FBQyxDQUFDLENBQUM7T0FDckI7S0FDRjs7O1NBck1HLGFBQWE7OztBQWtabkIsTUFBTSxDQUFDLE9BQU8sR0FBRyxhQUFhLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtc2VydmVyL2xpYi9OdWNsaWRlU2VydmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgYmxvY2tlZCA9IHJlcXVpcmUoJy4vYmxvY2tlZCcpO1xuY29uc3QgY29ubmVjdCA9IHJlcXVpcmUoJ2Nvbm5lY3QnKTtcblxuY29uc3Qge2dldFNlcnZpY2UsIGdldFJlbW90ZUV2ZW50TmFtZX0gPSByZXF1aXJlKCcuL3NlcnZpY2UtbWFuYWdlcicpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmltcG9ydCB7XG4gIEhFQVJUQkVBVF9DSEFOTkVMLFxuICBTRVJWSUNFX0ZSQU1FV09SS19FVkVOVF9DSEFOTkVMLFxuICBTRVJWSUNFX0ZSQU1FV09SS19SUENfQ0hBTk5FTCxcbiAgU0VSVklDRV9GUkFNRVdPUkszX0NIQU5ORUx9IGZyb20gJy4vY29uZmlnJztcbmNvbnN0IHtwYXJzZVNlcnZpY2VBcGlTeW5jfSA9IHJlcXVpcmUoJ251Y2xpZGUtc2VydmljZS10cmFuc2Zvcm1lcicpO1xuXG5jb25zdCB7RXZlbnRFbWl0dGVyfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgV2ViU29ja2V0U2VydmVyID0gcmVxdWlyZSgnd3MnKS5TZXJ2ZXI7XG5jb25zdCB7ZGVzZXJpYWxpemVBcmdzLCBzZW5kSnNvblJlc3BvbnNlLCBzZW5kVGV4dFJlc3BvbnNlfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHtnZXRWZXJzaW9ufSA9IHJlcXVpcmUoJ251Y2xpZGUtdmVyc2lvbicpO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IFNlcnZpY2VGcmFtZXdvcmsgZnJvbSAnLi9zZXJ2aWNlZnJhbWV3b3JrJztcblxuaW1wb3J0IHtnZXRMb2dnZXIsIGZsdXNoTG9nc0FuZEV4aXR9IGZyb20gJ251Y2xpZGUtbG9nZ2luZyc7XG5jb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKTtcblxuXG5cblxuY29uc3QgRVZFTlRfSEFORExFX1JFR0lTVEVSRUQgPSAnX251Y2xpZGVTZXJ2ZXJFdmVudEhhbmRsZVJlZ3N0ZXJlZCc7XG5cblxudHlwZSBOdWNsaWRlU2VydmVyT3B0aW9ucyA9IHtcbiAgcG9ydDogbnVtYmVyO1xuICBzZXJ2ZXJLZXk6ID9CdWZmZXI7XG4gIHNlcnZlckNlcnRpZmljYXRlOiA/QnVmZmVyO1xuICBjZXJ0aWZpY2F0ZUF1dGhvcml0eUNlcnRpZmljYXRlOiA/QnVmZmVyO1xuICB0cmFja0V2ZW50TG9vcDogP2Jvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIFNvY2tldENsaWVudCA9IHtcbiAgaWQ6IHN0cmluZztcbiAgc3Vic2NyaXB0aW9uczoge1tjaGFubmVsOiBzdHJpbmddOiAoZXZlbnQ6IGFueSkgPT4gdm9pZH07XG4gIHNvY2tldDogP1dlYlNvY2tldDtcbn07XG5cbnR5cGUgU2VydmljZUNvbmZpZyA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBkZWZpbml0aW9uOiBzdHJpbmc7XG4gIGltcGxlbWVudGF0aW9uOiBzdHJpbmc7XG59XG5cbmNsYXNzIE51Y2xpZGVTZXJ2ZXIge1xuICBzdGF0aWMgX3RoZVNlcnZlcjogP051Y2xpZGVTZXJ2ZXI7XG5cbiAgX3dlYlNlcnZlcjogaHR0cC5TZXJ2ZXIgfCBodHRwcy5TZXJ2ZXI7XG4gIF93ZWJTb2NrZXRTZXJ2ZXI6IFdlYlNvY2tldFNlcnZlcjtcbiAgX2NsaWVudHM6IHtbY2xpZW50SWQ6IHN0cmluZ106IFNvY2tldENsaWVudH07XG4gIF9ldmVudFN1YnNjcmlwdGlvbnM6IE1hcDwvKiBldmVudE5hbWUgKi8gc3RyaW5nLCBTZXQ8LyogY2xpZW50SWQgKi8gc3RyaW5nPj47XG4gIF9wb3J0OiBudW1iZXI7XG4gIF9zZXJ2aWNlV2l0aG91dFNlcnZpY2VGcmFtZXdvcmtDb25maWdzOiBBcnJheTxzdHJpbmc+O1xuICBfc2VydmljZVdpdGhTZXJ2aWNlRnJhbWV3b3JrQ29uZmlnczogQXJyYXk8YW55PjtcblxuICBfc2VydmVyQ29tcG9uZW50OiBTZXJ2aWNlRnJhbWV3b3JrLlNlcnZlckNvbXBvbmVudDtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBOdWNsaWRlU2VydmVyT3B0aW9ucykge1xuICAgIGludmFyaWFudChOdWNsaWRlU2VydmVyLl90aGVTZXJ2ZXIgPT0gbnVsbCk7XG4gICAgTnVjbGlkZVNlcnZlci5fdGhlU2VydmVyID0gdGhpcztcblxuICAgIGNvbnN0IHtzZXJ2ZXJLZXksIHNlcnZlckNlcnRpZmljYXRlLCBwb3J0LCBjZXJ0aWZpY2F0ZUF1dGhvcml0eUNlcnRpZmljYXRlLCB0cmFja0V2ZW50TG9vcH0gPSBvcHRpb25zO1xuXG4gICAgdGhpcy5fYXBwID0gY29ubmVjdCgpO1xuICAgIHRoaXMuX2F0dGFjaFV0aWxIYW5kbGVycyh0aGlzLl9hcHApO1xuICAgIGlmIChzZXJ2ZXJLZXkgJiYgc2VydmVyQ2VydGlmaWNhdGUgJiYgY2VydGlmaWNhdGVBdXRob3JpdHlDZXJ0aWZpY2F0ZSkge1xuICAgICAgY29uc3Qgd2ViU2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAga2V5OiBzZXJ2ZXJLZXksXG4gICAgICAgIGNlcnQ6IHNlcnZlckNlcnRpZmljYXRlLFxuICAgICAgICBjYTogY2VydGlmaWNhdGVBdXRob3JpdHlDZXJ0aWZpY2F0ZSxcbiAgICAgICAgcmVxdWVzdENlcnQ6IHRydWUsXG4gICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3dlYlNlcnZlciA9IGh0dHBzLmNyZWF0ZVNlcnZlcih3ZWJTZXJ2ZXJPcHRpb25zLCB0aGlzLl9hcHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcih0aGlzLl9hcHApO1xuICAgIH1cbiAgICB0aGlzLl9wb3J0ID0gcG9ydDtcblxuICAgIHRoaXMuX3dlYlNvY2tldFNlcnZlciA9IHRoaXMuX2NyZWF0ZVdlYlNvY2tldFNlcnZlcigpO1xuICAgIHRoaXMuX2NsaWVudHMgPSB7fTtcbiAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLl9zZXR1cFNlcnZpY2VzKCk7IC8vIFNldHVwIDEuMCBhbmQgMi4wIHNlcnZpY2VzLlxuXG4gICAgaWYgKHRyYWNrRXZlbnRMb29wKSB7XG4gICAgICBibG9ja2VkKChtczogbnVtYmVyKSA9PiB7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdOdWNsaWRlU2VydmVyIGV2ZW50IGxvb3AgYmxvY2tlZCBmb3IgJyArIG1zICsgJ21zJyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCAzLjAgc2VydmljZXMuXG4gICAgdGhpcy5fc2VydmVyQ29tcG9uZW50ID0gbmV3IFNlcnZpY2VGcmFtZXdvcmsuU2VydmVyQ29tcG9uZW50KHRoaXMpO1xuICB9XG5cbiAgX2F0dGFjaFV0aWxIYW5kbGVycyhhcHApIHtcbiAgICAvLyBBZGQgc3BlY2lmaWMgbWV0aG9kIGhhbmRsZXJzLlxuICAgIFsnZ2V0JywgJ3Bvc3QnLCAnZGVsZXRlJywgJ3B1dCddLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcbiAgICAgIHRoaXMuX2FwcFttZXRob2ROYW1lXSA9ICh1cmksIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy5fYXBwLnVzZSh1cmksIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpICE9PSBtZXRob2ROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXNuJ3QgbWF0Y2guXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVyKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVXZWJTb2NrZXRTZXJ2ZXIoKTogV2ViU29ja2V0U2VydmVyIHtcbiAgICBjb25zdCB3ZWJTb2NrZXRTZXJ2ZXIgPSBuZXcgV2ViU29ja2V0U2VydmVyKHtzZXJ2ZXI6IHRoaXMuX3dlYlNlcnZlcn0pO1xuICAgIHdlYlNvY2tldFNlcnZlci5vbignY29ubmVjdGlvbicsIChzb2NrZXQpID0+IHRoaXMuX29uQ29ubmVjdGlvbihzb2NrZXQpKTtcbiAgICB3ZWJTb2NrZXRTZXJ2ZXIub24oJ2Vycm9yJywgKGVycm9yKSA9PiBsb2dnZXIuZXJyb3IoJ1dlYlNvY2tldFNlcnZlciBFcnJvcjonLCBlcnJvcikpO1xuICAgIHJldHVybiB3ZWJTb2NrZXRTZXJ2ZXI7XG4gIH1cblxuICBfZ2V0U2VydmljZUZyYW1ld29ya1NlcnZpY2VBbmRSZWdpc3RlckV2ZW50SGFuZGxlKFxuICAgICAgc2VydmljZUNvbmZpZzogU2VydmljZUNvbmZpZywgc2VydmljZU9wdGlvbnM6IGFueSk6IGFueSB7XG4gICAgY29uc3QgbG9jYWxTZXJ2aWNlSW5zdGFuY2UgPSBnZXRTZXJ2aWNlKHNlcnZpY2VDb25maWcubmFtZSwgc2VydmljZU9wdGlvbnMsIHNlcnZpY2VDb25maWcuaW1wbGVtZW50YXRpb24pO1xuICAgIGlmIChsb2NhbFNlcnZpY2VJbnN0YW5jZVtFVkVOVF9IQU5ETEVfUkVHSVNURVJFRF0pIHtcbiAgICAgIHJldHVybiBsb2NhbFNlcnZpY2VJbnN0YW5jZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2aWNlQXBpID0gcGFyc2VTZXJ2aWNlQXBpU3luYyhzZXJ2aWNlQ29uZmlnLmRlZmluaXRpb24sIHNlcnZpY2VDb25maWcubmFtZSk7XG5cbiAgICBzZXJ2aWNlQXBpLmV2ZW50TWV0aG9kTmFtZXMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgIGxvY2FsU2VydmljZUluc3RhbmNlW21ldGhvZE5hbWVdLmNhbGwobG9jYWxTZXJ2aWNlSW5zdGFuY2UsICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGdldFJlbW90ZUV2ZW50TmFtZShzZXJ2aWNlQ29uZmlnLm5hbWUsIG1ldGhvZE5hbWUsIHNlcnZpY2VPcHRpb25zKTtcbiAgICAgICAgKHRoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucy5nZXQoZXZlbnROYW1lKSB8fCBbXSkuZm9yRWFjaChjbGllbnRJZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5fY2xpZW50c1tjbGllbnRJZF07XG5cbiAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0NsaWVudCB3aXRoIGNsaWVudElkOiAlcyBub3QgZm91bmQhJywgY2xpZW50SWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NlbmRTb2NrZXRNZXNzYWdlKGNsaWVudCwge1xuICAgICAgICAgICAgY2hhbm5lbDogU0VSVklDRV9GUkFNRVdPUktfRVZFTlRfQ0hBTk5FTCxcbiAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxvY2FsU2VydmljZUluc3RhbmNlLCBFVkVOVF9IQU5ETEVfUkVHSVNURVJFRCwge3ZhbHVlOiB0cnVlfSk7XG5cbiAgICByZXR1cm4gbG9jYWxTZXJ2aWNlSW5zdGFuY2U7XG4gIH1cblxuICBfcmVnaXN0ZXJTZXJ2aWNlV2l0aFNlcnZpY2VGcmFtZXdvcmsoc2VydmljZUNvbmZpZzogU2VydmljZUNvbmZpZyk6IHZvaWQge1xuICAgIGNvbnN0IHNlcnZpY2VBcGkgPSBwYXJzZVNlcnZpY2VBcGlTeW5jKHNlcnZpY2VDb25maWcuZGVmaW5pdGlvbiwgc2VydmljZUNvbmZpZy5uYW1lKTtcblxuICAgIHNlcnZpY2VBcGkucnBjTWV0aG9kTmFtZXMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyU2VydmljZShcbiAgICAgICAgJy8nICsgc2VydmljZUFwaS5jbGFzc05hbWUgKyAnLycgKyBtZXRob2ROYW1lLFxuXG4gICAgICAgIC8vIFRha2Ugc2VydmljZU9wdGlvbnMgYXMgZmlyc3QgYXJndW1lbnQgZm9yIHNlcnZpY2VGcmFtZXdvcmsgc2VydmljZS5cbiAgICAgICAgLy8gVE9ETyhjaGVuc2hlbikgc2VwZXJhdGUgdGhlIGxvZ2ljIG9mIHNlcnZpY2UgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgIChzZXJ2aWNlT3B0aW9ucywgLi4uYXJncykgPT4ge1xuICAgICAgICAgIGNvbnN0IGxvY2FsU2VydmljZUluc3RhbmNlID0gdGhpcy5fZ2V0U2VydmljZUZyYW1ld29ya1NlcnZpY2VBbmRSZWdpc3RlckV2ZW50SGFuZGxlKFxuICAgICAgICAgICAgICBzZXJ2aWNlQ29uZmlnLCBzZXJ2aWNlT3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsU2VydmljZUluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KGxvY2FsU2VydmljZUluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3Bvc3QnLFxuICAgICAgKTtcbiAgICB9KTtcblxuICB9XG5cbiAgX3JlZ2lzdGVyU2VydmljZVdpdGhvdXRTZXJ2aWNlRnJhbWV3b3JrKHNlcnZpY2VGaWxlUGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qge3VybEhhbmRsZXJzLCBzZXJ2aWNlcywgaW5pdGlhbGl6ZX0gPSByZXF1aXJlKHNlcnZpY2VGaWxlUGF0aCk7XG4gICAgZm9yIChjb25zdCBzZXJ2aWNlTmFtZSBpbiBzZXJ2aWNlcykge1xuICAgICAgY29uc3Qgc2VydmljZUNvbmZpZyA9IHNlcnZpY2VzW3NlcnZpY2VOYW1lXTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyU2VydmljZShzZXJ2aWNlTmFtZSwgc2VydmljZUNvbmZpZy5oYW5kbGVyLCBzZXJ2aWNlQ29uZmlnLm1ldGhvZCwgc2VydmljZUNvbmZpZy50ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAodXJsSGFuZGxlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgdXJsIGluIHVybEhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJDb25maWcgPSB1cmxIYW5kbGVyc1t1cmxdO1xuICAgICAgICB0aGlzLl9hdHRhY2hVcmxIYW5kbGVyKHVybCwgaGFuZGxlckNvbmZpZy5oYW5kbGVyLCBoYW5kbGVyQ29uZmlnLm1ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgIGluaXRpYWxpemUodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgX3NldHVwU2VydmljZXMoKSB7XG4gICAgLy8gTGF6eSByZXF1aXJlIHRoZXNlIGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNvdWxkIHNweU9uIHRoZW0gd2hpbGUgdGVzdGluZyBpblxuICAgIC8vIFNlcnZpY2VJbnRlZ3JhdGlvblRlc3RIZWxwZXIuXG4gICAgY29uc3Qge2xvYWRDb25maWdzT2ZTZXJ2aWNlV2l0aFNlcnZpY2VGcmFtZXdvcmssXG4gICAgICBsb2FkQ29uZmlnc09mU2VydmljZVdpdGhvdXRTZXJ2aWNlRnJhbWV3b3JrfSA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdGhpcy5fc2VydmljZVJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5fdmVyc2lvbiA9IGdldFZlcnNpb24oKS50b1N0cmluZygpO1xuICAgIHRoaXMuX3NldHVwSGVhcnRiZWF0SGFuZGxlcigpO1xuICAgIHRoaXMuX3NldHVwU2VydmljZUZyYW1ld29ya1N1YnNjcmlwdGlvbkhhbmRsZXIoKTtcbiAgICB0aGlzLl9zZXJ2aWNlV2l0aG91dFNlcnZpY2VGcmFtZXdvcmtDb25maWdzID0gbG9hZENvbmZpZ3NPZlNlcnZpY2VXaXRob3V0U2VydmljZUZyYW1ld29yaygpO1xuICAgIHRoaXMuX3NlcnZpY2VXaXRoU2VydmljZUZyYW1ld29ya0NvbmZpZ3MgPSBsb2FkQ29uZmlnc09mU2VydmljZVdpdGhTZXJ2aWNlRnJhbWV3b3JrKCk7XG5cbiAgICB0aGlzLl9zZXJ2aWNlV2l0aG91dFNlcnZpY2VGcmFtZXdvcmtDb25maWdzLmZvckVhY2goKGNvbmZpZzogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLl9yZWdpc3RlclNlcnZpY2VXaXRob3V0U2VydmljZUZyYW1ld29yayhjb25maWcpO1xuICAgICAgbG9nZ2VyLmRlYnVnKGBSZWdpc3RlcmVkIHNlcnZpY2UgJHtjb25maWd9IHdpdGhvdXQgU2VydmljZUZyYW1ld29yay5gKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NlcnZpY2VXaXRoU2VydmljZUZyYW1ld29ya0NvbmZpZ3MuZm9yRWFjaChjb25maWcgPT4ge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJTZXJ2aWNlV2l0aFNlcnZpY2VGcmFtZXdvcmsoY29uZmlnKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgUmVnaXN0ZXJlZCBzZXJ2aWNlICR7Y29uZmlnLm5hbWV9IHdpdGggU2VydmljZUZyYW1ld29yay5gKTtcbiAgICB9KTtcblxuICAgIC8vIFNldHVwIGVycm9yIGhhbmRsZXIuXG4gICAgdGhpcy5fYXBwLnVzZSgoZXJyb3IsIHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgc2VuZEpzb25SZXNwb25zZShyZXNwb25zZSwge2NvZGU6IGVycm9yLmNvZGUsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2V9LCA1MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3NldHVwSGVhcnRiZWF0SGFuZGxlcigpIHtcbiAgICB0aGlzLl9yZWdpc3RlclNlcnZpY2UoJy8nICsgSEVBUlRCRUFUX0NIQU5ORUwsIGFzeW5jICgpID0+IHRoaXMuX3ZlcnNpb24sXG4gICAgICAgICdwb3N0JywgdHJ1ZSk7XG4gIH1cblxuICBzdGF0aWMgc2h1dGRvd24oKTogdm9pZCB7XG4gICAgbG9nZ2VyLmluZm8oJ1NodXR0aW5nIGRvd24gdGhlIHNlcnZlcicpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoTnVjbGlkZVNlcnZlci5fdGhlU2VydmVyICE9IG51bGwpIHtcbiAgICAgICAgTnVjbGlkZVNlcnZlci5fdGhlU2VydmVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSBzaHV0dGluZyBkb3duLCBidXQgcHJvY2VlZGluZyBhbnl3YXk6JywgZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGZsdXNoTG9nc0FuZEV4aXQoMCk7XG4gICAgfVxuICB9XG5cbiAgX3NldHVwU2VydmljZUZyYW1ld29ya1N1YnNjcmlwdGlvbkhhbmRsZXIoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJTZXJ2aWNlKCcvc2VydmljZUZyYW1ld29yay9zdWJzY3JpYmVFdmVudCcsIChzZXJ2aWNlT3B0aW9uczogYW55LCBjbGllbnRJZDogc3RyaW5nLCBzZXJ2aWNlTmFtZTogc3RyaW5nLCBtZXRob2ROYW1lOiBzdHJpbmcpID0+IHtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXJ2aWNlIGluc3RhbmNlIGFuZCByZWdpc3RlciB0aGUgZXZlbnQgaGFuZGxlLlxuICAgICAgY29uc3QgW3NlcnZpY2VDb25maWddID0gdGhpcy5fc2VydmljZVdpdGhTZXJ2aWNlRnJhbWV3b3JrQ29uZmlncy5maWx0ZXIoY29uZmlnID0+IGNvbmZpZy5uYW1lID09PSBzZXJ2aWNlTmFtZSk7XG4gICAgICB0aGlzLl9nZXRTZXJ2aWNlRnJhbWV3b3JrU2VydmljZUFuZFJlZ2lzdGVyRXZlbnRIYW5kbGUoc2VydmljZUNvbmZpZywgc2VydmljZU9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBldmVudE5hbWUgPSBnZXRSZW1vdGVFdmVudE5hbWUoc2VydmljZU5hbWUsIG1ldGhvZE5hbWUsIHNlcnZpY2VPcHRpb25zKTtcblxuICAgICAgdGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zLnNldChcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAodGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zLmdldChldmVudE5hbWUpIHx8IG5ldyBTZXQoKSkuYWRkKGNsaWVudElkKSxcbiAgICAgICk7XG5cbiAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtjbGllbnRJZH0gc3Vic2NyaWJlZCB0byAke2V2ZW50TmFtZX1gKTtcbiAgICB9LCAncG9zdCcpO1xuXG4gICAgdGhpcy5fcmVnaXN0ZXJTZXJ2aWNlKCcvc2VydmljZUZyYW1ld29yay91bnN1YnNjcmliZUV2ZW50JywgKHNlcnZpY2VPcHRpb25zOiBhbnksIGNsaWVudElkOiBzdHJpbmcsIHNlcnZpY2VOYW1lOiBzdHJpbmcsIG1ldGhvZE5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgZXZlbnROYW1lID0gZ2V0UmVtb3RlRXZlbnROYW1lKHNlcnZpY2VOYW1lLCBtZXRob2ROYW1lLCBzZXJ2aWNlT3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucy5nZXQoZXZlbnROYW1lKS5kZWxldGUoY2xpZW50SWQpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmRlYnVnKGAke2NsaWVudElkfSB1bnN1YnNjcmliZWQgdG8gJHtldmVudE5hbWV9YCk7XG4gICAgfSwgJ3Bvc3QnKTtcbiAgfVxuXG4gIGNvbm5lY3QoKTogUHJvbWlzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3dlYlNlcnZlci5vbignbGlzdGVuaW5nJywgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3dlYlNlcnZlci5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLl93ZWJTZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fd2ViU2VydmVyLmxpc3Rlbih0aGlzLl9wb3J0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBhIHJlZ2lzdGVyZWQgc2VydmljZSB3aXRoIGEgbmFtZSBhbmQgYXJndW1lbnRzLlxuICAgKi9cbiAgY2FsbFNlcnZpY2Uoc2VydmljZU5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55Pik6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgc2VydmljZUZ1bmN0aW9uID0gdGhpcy5fc2VydmljZVJlZ2lzdHJ5W3NlcnZpY2VOYW1lXTtcbiAgICBpZiAoIXNlcnZpY2VGdW5jdGlvbikge1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIHNlcnZpY2UgcmVnaXN0ZXJlZCB3aXRoIG5hbWU6ICcgKyBzZXJ2aWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBzZXJ2aWNlRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgc2VydmljZSBmdW5jdGlvbiB0byBhIHNlcnZpY2UgbmFtZS5cbiAgICogVGhpcyBhbGxvd3Mgc2ltcGxlIGZ1dHVyZSBjYWxscyBvZiB0aGUgc2VydmljZSBieSBuYW1lIGFuZCBhcmd1bWVudHMgb3IgaHR0cC10cmlnZ2VyZWQgZW5kcG9pbnQgY2FsbHNcbiAgICogd2l0aCBhcmd1bWVudHMgc2VyaWFsaXplZCBvdmVyIGh0dHAuXG4gICAqL1xuICBfcmVnaXN0ZXJTZXJ2aWNlKFxuICAgICAgc2VydmljZU5hbWU6IHN0cmluZyxcbiAgICAgIHNlcnZpY2VGdW5jdGlvbjogKCkgPT4gUHJvbWlzZTxhbnk+LFxuICAgICAgbWV0aG9kOiA/c3RyaW5nID0gJ2dldCcsXG4gICAgICBpc1RleHRSZXNwb25zZTogP2Jvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5fc2VydmljZVJlZ2lzdHJ5W3NlcnZpY2VOYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNlcnZpY2Ugd2l0aCB0aGlzIG5hbWUgaXMgYWxyZWFkeSByZWdpc3RlcmVkOicsIHNlcnZpY2VOYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fc2VydmljZVJlZ2lzdHJ5W3NlcnZpY2VOYW1lXSA9IHNlcnZpY2VGdW5jdGlvbjtcbiAgICB0aGlzLl9yZWdpc3Rlckh0dHBTZXJ2aWNlKHNlcnZpY2VOYW1lLCBtZXRob2QsIGlzVGV4dFJlc3BvbnNlKTtcbiAgfVxuXG4gIF9yZWdpc3Rlckh0dHBTZXJ2aWNlKHNlcnZpY2VOYW1lOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nLCBpc1RleHRSZXNwb25zZTogP2Jvb2xlYW4pIHtcbiAgICBjb25zdCBsb3dlcmVkQ2FzZU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMuX2FwcFtsb3dlcmVkQ2FzZU1ldGhvZF0oc2VydmljZU5hbWUsIGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsU2VydmljZShzZXJ2aWNlTmFtZSwgZGVzZXJpYWxpemVBcmdzKHJlcXVlc3QudXJsKSk7XG4gICAgICAgIGlmIChpc1RleHRSZXNwb25zZSkge1xuICAgICAgICAgIHNlbmRUZXh0UmVzcG9uc2UocmVzcG9uc2UsIHJlc3VsdCB8fCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VuZEpzb25SZXNwb25zZShyZXNwb25zZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIERlbGVnYXRlIHRvIHRoZSByZWdpc3RlcmVkIGNvbm5lY3QgZXJyb3IgaGFuZGxlci5cbiAgICAgICAgbmV4dChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gZXhwbGljaXQgaHR0cCBjb25uZWN0IGhhbmRsZXIgZm9yIHNvbWUgc2VydmljZXMgdGhhdCBuZWVkIHJlcXVlc3QvcmVzcG9uc2UgcmVsYXRlZCBvcHRpbWl6YXRpb25zLlxuICAgKiBlLmcuIHJlYWRGaWxlIGFuZCB3cml0ZUZpbGUgdXNlcyBpdCB0byBzdHJlYW0gcmVhZGluZyBhbmQgd3JpdGluZyBmaWxlcyAocGVyZiBpbXByb3ZlbWVudCBmb3IgYmlnIGZpbGVzKS5cbiAgICovXG4gIF9hdHRhY2hVcmxIYW5kbGVyKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGhhbmRsZXI6IChyZXF1ZXN0OiBodHRwLkluY29taW5nTWVzc2FnZSwgcmVzcG9uc2U6IGh0dHAuT3V0Z29pbmdNZXNzYWdlLCBuZXh0OiAoZXJyOiBFcnJvcikgPT4gdm9pZCkgPT4gdm9pZCxcbiAgICBtZXRob2Q6ID9zdHJpbmcgPSAnZ2V0J1xuICApOiB2b2lkIHtcbiAgICB0aGlzLl9hcHBbbWV0aG9kXSh1cmwsIGhhbmRsZXIpO1xuICB9XG5cbiAgX29uQ29ubmVjdGlvbihzb2NrZXQ6IFdlYlNvY2tldCk6IHZvaWQge1xuICAgIGxvZ2dlci5kZWJ1ZygnV2ViU29ja2V0IGNvbm5lY3RpbmcnKTtcblxuXG4gICAgbGV0IGNsaWVudCA9IG51bGw7XG5cbiAgICBzb2NrZXQub24oJ2Vycm9yJywgKGUpID0+XG4gICAgICBsb2dnZXIuZXJyb3IoJ0NsaWVudCAjJXMgZXJyb3I6ICVzJywgY2xpZW50ID8gY2xpZW50LmlkIDogJ3Vua293bicsIGUubWVzc2FnZSkpO1xuXG4gICAgc29ja2V0Lm9uY2UoJ21lc3NhZ2UnLCAoY2xpZW50SWQpID0+IHtcbiAgICAgIGNsaWVudCA9IHRoaXMuX2NsaWVudHNbY2xpZW50SWRdID0gdGhpcy5fY2xpZW50c1tjbGllbnRJZF0gfHxcbiAgICAgICAgICB7c3Vic2NyaXB0aW9uczoge30sIGlkOiBjbGllbnRJZCwgbWVzc2FnZVF1ZXVlOiBbXX07XG4gICAgICAvLyBJZiBhbiBleGlzdGluZyBjbGllbnQsIHdlIGNsb3NlIGl0cyBzb2NrZXQgYmVmb3JlIGxpc3RlbmluZyB0byB0aGUgbmV3IHNvY2tldC5cbiAgICAgIGlmIChjbGllbnQuc29ja2V0KSB7XG4gICAgICAgIGNsaWVudC5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgY2xpZW50LnNvY2tldCA9IG51bGw7XG4gICAgICB9XG4gICAgICBsb2dnZXIuaW5mbygnQ2xpZW50ICMlcyBjb25uZWN0aW5nIHdpdGggYSBuZXcgc29ja2V0IScsIGNsaWVudElkKTtcbiAgICAgIGNsaWVudC5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICBjbGllbnQubWVzc2FnZVF1ZXVlLnNwbGljZSgwKS5mb3JFYWNoKG1lc3NhZ2UgPT4gdGhpcy5fc2VuZFNvY2tldE1lc3NhZ2UoY2xpZW50LCBtZXNzYWdlLmRhdGEpKTtcbiAgICAgIHNvY2tldC5vbignbWVzc2FnZScsIChtZXNzYWdlKSA9PiB0aGlzLl9vblNvY2tldE1lc3NhZ2UoY2xpZW50LCBtZXNzYWdlKSk7XG4gICAgfSk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNsaWVudC5zb2NrZXQgPT09IHNvY2tldCkge1xuICAgICAgICBjbGllbnQuc29ja2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5pbmZvKCdDbGllbnQgIyVzIGNsb3NpbmcgYSBzb2NrZXQhJywgY2xpZW50LmlkKTtcbiAgICAgIC8vIFRPRE86IGVuYWJsZSBzdWJzY3JpcHRpb24gY2xlYW51cCB3aGVuIHdlIGhhdmUgYSByb2J1c3QgcmVjb25uZWN0IHNjZW5hcmlvLlxuICAgICAgLypcbiAgICAgIGZvciAodmFyIGNoYW5uZWwgaW4gY2xpZW50LnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZShjaGFubmVsLCBzdWJzY3JpcHRpb25zW2NoYW5uZWxdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucy5mb3JFYWNoKHZhbHVlID0+IHZhbHVlLmRlbGV0ZShjbGllbnQuaWQpKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jbGllbnRzW2NsaWVudC5pZF07XG4gICAgICAqL1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgX29uU29ja2V0TWVzc2FnZShjbGllbnQ6IFNvY2tldENsaWVudCwgbWVzc2FnZTogYW55KTogdm9pZCB7XG4gICAgbWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgaWYgKG1lc3NhZ2UucHJvdG9jb2wgJiYgbWVzc2FnZS5wcm90b2NvbCA9PT0gU0VSVklDRV9GUkFNRVdPUkszX0NIQU5ORUwpIHtcbiAgICAgIHRoaXMuX3NlcnZlckNvbXBvbmVudC5oYW5kbGVNZXNzYWdlKGNsaWVudCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge3NlcnZpY2VOYW1lLCBtZXRob2ROYW1lLCBtZXRob2RBcmdzLCBzZXJ2aWNlT3B0aW9ucywgcmVxdWVzdElkfSA9IG1lc3NhZ2U7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGxTZXJ2aWNlKFxuICAgICAgICAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZE5hbWUsXG4gICAgICAgIFtzZXJ2aWNlT3B0aW9uc10uY29uY2F0KG1ldGhvZEFyZ3MpLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjYWxsICVzLyVzIHdpdGggZXJyb3IgJW8nLCBzZXJ2aWNlTmFtZSwgbWV0aG9kTmFtZSwgZSk7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZFNvY2tldE1lc3NhZ2UoY2xpZW50LCB7XG4gICAgICBjaGFubmVsOiBTRVJWSUNFX0ZSQU1FV09SS19SUENfQ0hBTk5FTCxcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIGVycm9yLFxuICAgIH0pO1xuICB9XG5cbiAgX3NlbmRTb2NrZXRNZXNzYWdlKGNsaWVudDogU29ja2V0Q2xpZW50LCBkYXRhOiBhbnkpIHtcbiAgICAvLyBXcmFwIHRoZSBkYXRhIGluIGFuIG9iamVjdCwgYmVjYXVzZSBpZiBgZGF0YWAgaXMgYSBwcmltaXRpdmUgZGF0YSB0eXBlLFxuICAgIC8vIGZpbmRpbmcgaXQgaW4gYW4gYXJyYXkgd291bGQgcmV0dXJuIHRoZSBmaXJzdCBtYXRjaGluZyBpdGVtLCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgaW5zZXJ0ZWQgaXRlbS5cbiAgICBjb25zdCBtZXNzYWdlID0ge2RhdGF9O1xuICAgIGNvbnN0IHtpZCwgc29ja2V0LCBtZXNzYWdlUXVldWV9ID0gY2xpZW50O1xuICAgIG1lc3NhZ2VRdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgIGlmICghc29ja2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgc2VuZGluZyBzb2NrZXQgbWVzc2FnZSB0byBjbGllbnQ6JywgaWQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gbWVzc2FnZVF1ZXVlLmluZGV4T2YobWVzc2FnZSk7XG4gICAgICAgIGlmIChtZXNzYWdlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbWVzc2FnZVF1ZXVlLnNwbGljZShtZXNzYWdlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICBpbnZhcmlhbnQoTnVjbGlkZVNlcnZlci5fdGhlU2VydmVyID09PSB0aGlzKTtcbiAgICBOdWNsaWRlU2VydmVyLl90aGVTZXJ2ZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fd2ViU29ja2V0U2VydmVyLmNsb3NlKCk7XG4gICAgdGhpcy5fd2ViU2VydmVyLmNsb3NlKCk7XG4gICAgdGhpcy5fc2VydmljZVdpdGhvdXRTZXJ2aWNlRnJhbWV3b3JrQ29uZmlncy5mb3JFYWNoKHNlcnZpY2VfcGF0aCA9PiB7XG4gICAgICBjb25zdCB7c2h1dGRvd259ID0gcmVxdWlyZShzZXJ2aWNlX3BhdGgpO1xuICAgICAgaWYgKHNodXRkb3duKSB7XG4gICAgICAgIHNodXRkb3duKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTnVjbGlkZVNlcnZlcjtcbiJdfQ==
