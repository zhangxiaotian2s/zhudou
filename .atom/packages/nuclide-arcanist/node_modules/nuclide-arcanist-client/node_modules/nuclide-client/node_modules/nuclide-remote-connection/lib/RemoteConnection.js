
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _require = require('atom');

var CompositeDisposable = _require.CompositeDisposable;
var Disposable = _require.Disposable;

var remoteUri = require('nuclide-remote-uri');
var logger = require('nuclide-logging').getLogger();

var _require2 = require('events');

var EventEmitter = _require2.EventEmitter;

var RemoteFile = require('./RemoteFile');
var RemoteDirectory = require('./RemoteDirectory');
var NuclideClient = require('nuclide-server/lib/NuclideClient');
var NuclideRemoteEventbus = require('nuclide-server/lib/NuclideRemoteEventbus');

var _require3 = require('./RemoteConnectionConfigurationManager');

var getConnectionConfig = _require3.getConnectionConfig;
var setConnectionConfig = _require3.setConnectionConfig;

var _require4 = require('nuclide-version');

var getVersion = _require4.getVersion;

var HEARTBEAT_AWAY_REPORT_COUNT = 3;
var HEARTBEAT_NOTIFICATION_ERROR = 1;
var HEARTBEAT_NOTIFICATION_WARNING = 2;

// Taken from the error message in
// https://github.com/facebook/watchman/blob/99dde8ee3f13233be097c036147748b2d7f8bfa7/tests/integration/rootrestrict.php#L58
var WATCHMAN_ERROR_MESSAGE_FOR_ENFORCE_ROOT_FILES_REGEX = /global config root_files/;

// key for https connection.

function getReloadKeystrokeLabel() {
  var binding = atom.keymaps.findKeyBindings({ command: 'window:reload' });
  if (!binding || !binding[0]) {
    return null;
  }

  var _require5 = require('nuclide-keystroke-label');

  var humanizeKeystroke = _require5.humanizeKeystroke;

  return humanizeKeystroke(binding[0].keystrokes);
}

var _connections = [];
var _emitter = new EventEmitter();

var RemoteConnection = (function () {
  function RemoteConnection(config) {
    _classCallCheck(this, RemoteConnection);

    this._subscriptions = new CompositeDisposable();
    this._entries = {};
    this._config = config;
    this._heartbeatNetworkAwayCount = 0;
    this._closed = false;
  }

  // Expose local variables for testability.

  _createClass(RemoteConnection, [{
    key: 'dispose',
    value: function dispose() {
      this._subscriptions.dispose();
    }

    /**
     * Create a connection by reusing the configuration of last successful connection associated with
     * given host. If the server's certs has been updated or there is no previous successful
     * connection, null (resolved by promise) is returned.
     */
  }, {
    key: '_setHgRepoInfo',

    // A workaround before Atom 2.0: Atom's Project::setPaths currently uses
    // ::repositoryForDirectorySync, so we need the repo information to already be
    // available when the new path is added. t6913624 tracks cleanup of this.
    value: _asyncToGenerator(function* () {
      var remotePath = this.getPathForInitialWorkingDirectory();

      var _getService = this.getService('SourceControlService');

      var getHgRepository = _getService.getHgRepository;

      var hgRepoDescription = yield getHgRepository(remotePath);
      this._setHgRepositoryDescription(hgRepoDescription);
    })
  }, {
    key: '_monitorConnectionHeartbeat',
    value: function _monitorConnectionHeartbeat() {
      var _this = this;

      var socket = this.getClient().eventbus.socket;
      var serverUri = socket.getServerUri();

      /**
       * Adds an Atom notification for the detected heartbeat network status
       * The function makes sure not to add many notifications for the same event and prioritize new events.
       */
      var addHeartbeatNotification = function addHeartbeatNotification(type, errorCode, message, dismissable) {
        var _ref = _this._lastHeartbeatNotification || {};

        var code = _ref.code;
        var existingNotification = _ref.notification;

        if (code && code === errorCode && dismissable) {
          // A dismissible heartbeat notification with this code is already active.
          return;
        }
        var notification = null;
        switch (type) {
          case HEARTBEAT_NOTIFICATION_ERROR:
            notification = atom.notifications.addError(message, { dismissable: dismissable });
            break;
          case HEARTBEAT_NOTIFICATION_WARNING:
            notification = atom.notifications.addWarning(message, { dismissable: dismissable });
            break;
          default:
            throw new Error('Unrecongnized heartbeat notification type');
        }
        if (existingNotification) {
          existingNotification.dismiss();
        }
        _this._lastHeartbeatNotification = {
          notification: notification,
          code: errorCode
        };
      };

      var onHeartbeat = function onHeartbeat() {
        if (_this._lastHeartbeatNotification) {
          // If there has been existing heartbeat error/warning,
          // that means connection has been lost and we shall show a message about connection
          // being restored without a reconnect prompt.
          var _notification = _this._lastHeartbeatNotification.notification;

          _notification.dismiss();
          atom.notifications.addSuccess('Connection restored to Nuclide Server at: ' + serverUri);
          _this._heartbeatNetworkAwayCount = 0;
          _this._lastHeartbeatNotification = null;
        }
      };

      var notifyNetworkAway = function notifyNetworkAway(code) {
        _this._heartbeatNetworkAwayCount++;
        if (_this._heartbeatNetworkAwayCount >= HEARTBEAT_AWAY_REPORT_COUNT) {
          addHeartbeatNotification(HEARTBEAT_NOTIFICATION_WARNING, code, 'Nuclide server can not be reached at: ' + serverUri + '<br/>Check your network connection!',
          /*dismissable*/true);
        }
      };

      var onHeartbeatError = function onHeartbeatError(error) {
        var reloadkeystroke = getReloadKeystrokeLabel();
        var reloadKeystrokeLabel = reloadkeystroke ? ' : (' + reloadkeystroke + ')' : '';
        var code = error.code;
        var message = error.message;
        var originalCode = error.originalCode;

        logger.info('Heartbeat network error:', code, originalCode, message);
        switch (code) {
          case 'NETWORK_AWAY':
            // Notify switching networks, disconnected, timeout, unreachable server or fragile connection.
            notifyNetworkAway(code);
            break;
          case 'SERVER_CRASHED':
            // Server shut down or port no longer accessible.
            // Notify the server was there, but now gone.
            addHeartbeatNotification(HEARTBEAT_NOTIFICATION_ERROR, code, 'Nuclide server crashed!<br/>' + 'Please reload Nuclide to restore your remote project connection!' + reloadKeystrokeLabel,
            /*dismissable*/true);
            // TODO(most) reconnect RemoteConnection, restore the current project state,
            // and finally change dismissable to false and type to 'WARNING'.
            break;
          case 'PORT_NOT_ACCESSIBLE':
            // Notify never heard a heartbeat from the server.

            var _remoteUri$parse = remoteUri.parse(serverUri),
                port = _remoteUri$parse.port;

            addHeartbeatNotification(HEARTBEAT_NOTIFICATION_ERROR, code, 'Nuclide server is not reachable.<br/>It could be running on a port that is not accessible: ' + port,
            /*dismissable*/true);
            break;
          case 'INVALID_CERTIFICATE':
            // Notify the client certificate is not accepted by nuclide server (certificate mismatch).
            addHeartbeatNotification(HEARTBEAT_NOTIFICATION_ERROR, code, 'Connection Reset Error!!<br/>This could be caused by the client certificate mismatching the server certificate.<br/>' + 'Please reload Nuclide to restore your remote project connection!' + reloadKeystrokeLabel,
            /*dismissable*/true);
            // TODO(most): reconnect RemoteConnection, restore the current project state.
            // and finally change dismissable to false and type to 'WARNING'.
            break;
          default:
            notifyNetworkAway(code);
            logger.error('Unrecongnized heartbeat error code: ' + code, message);
            break;
        }
      };
      socket.on('heartbeat', onHeartbeat);
      socket.on('heartbeat.error', onHeartbeatError);

      this._subscriptions.add(new Disposable(function () {
        socket.removeListener('heartbeat', onHeartbeat);
        socket.removeListener('heartbeat.error', onHeartbeatError);
      }));
    }
  }, {
    key: 'getUriOfRemotePath',
    value: function getUriOfRemotePath(remotePath) {
      return 'nuclide://' + this.getRemoteHost() + remotePath;
    }
  }, {
    key: 'getPathOfUri',
    value: function getPathOfUri(uri) {
      return remoteUri.parse(uri).path;
    }
  }, {
    key: 'createDirectory',
    value: function createDirectory(uri) {
      var _remoteUri$parse2 = remoteUri.parse(uri);

      var path = _remoteUri$parse2.path;

      path = require('path').normalize(path);

      var entry = this._entries[path];
      if (!entry || entry.getLocalPath() !== path) {
        this._entries[path] = entry = new RemoteDirectory(this, this.getUriOfRemotePath(path), { hgRepositoryDescription: this._hgRepositoryDescription });
        // TODO: We should add the following line to keep the cache up-to-date.
        // We need to implement onDidRename and onDidDelete in RemoteDirectory
        // first. It's ok that we don't add the handlers for now since we have
        // the check `entry.getLocalPath() !== path` above.
        //
        // this._addHandlersForEntry(entry);
      }

      if (!entry.isDirectory()) {
        throw new Error('Path is not a directory:' + uri);
      }

      return entry;
    }

    // A workaround before Atom 2.0: see ::getHgRepoInfo of main.js.
  }, {
    key: '_setHgRepositoryDescription',
    value: function _setHgRepositoryDescription(hgRepositoryDescription) {
      this._hgRepositoryDescription = hgRepositoryDescription;
    }
  }, {
    key: 'createFile',
    value: function createFile(uri) {
      var _remoteUri$parse3 = remoteUri.parse(uri);

      var path = _remoteUri$parse3.path;

      path = require('path').normalize(path);

      var entry = this._entries[path];
      if (!entry || entry.getLocalPath() !== path) {
        this._entries[path] = entry = new RemoteFile(this, this.getUriOfRemotePath(path));
        this._addHandlersForEntry(entry);
      }

      if (entry.isDirectory()) {
        throw new Error('Path is not a file');
      }

      return entry;
    }
  }, {
    key: '_addHandlersForEntry',
    value: function _addHandlersForEntry(entry) {
      var _this2 = this;

      var oldPath = entry.getLocalPath();
      var renameSubscription = entry.onDidRename(function () {
        delete _this2._entries[oldPath];
        _this2._entries[entry.getLocalPath()] = entry;
      });
      var deleteSubscription = entry.onDidDelete(function () {
        delete _this2._entries[entry.getLocalPath()];
        renameSubscription.dispose();
        deleteSubscription.dispose();
      });
    }
  }, {
    key: 'initialize',
    value: _asyncToGenerator(function* () {
      var _this3 = this;

      // Right now we don't re-handshake.
      if (this._initialized === undefined) {
        this._initialized = false;
        var client = this._getClient();

        // Test connection first. First time we get here we're checking to reestablish
        // connection using cached credentials. This will fail fast (faster than infoService)
        // when we don't have cached credentials yet.
        try {
          yield client.testConnection();

          // Do version check.
          var serverVersion = undefined;

          // Need to set initialized to true optimistically so that we can get the InfoService.
          // TODO: We shouldn't need the client to get a service.
          this._initialized = true;
          var infoService = this.getService('InfoService');
          serverVersion = yield infoService.getServerVersion();

          var clientVersion = getVersion();
          if (clientVersion !== serverVersion) {
            throw new Error('Version mismatch. Client at ' + clientVersion + ' while server at ' + serverVersion + '.');
          }
        } catch (e) {
          client.close();
          this._initialized = false;
          throw e;
        }

        var FileSystemService = this.getService('FileSystemService');
        this._config.cwd = yield FileSystemService.resolveRealPath(this._config.cwd);

        // Store the configuration for future usage.
        setConnectionConfig(this._config);

        this._monitorConnectionHeartbeat();

        // A workaround before Atom 2.0: see ::getHgRepoInfo.
        yield this._setHgRepoInfo();

        // Register NuclideUri type conversions.
        client.registerType('NuclideUri', function (uri) {
          return _this3.getPathOfUri(uri);
        }, function (path) {
          return _this3.getUriOfRemotePath(path);
        });

        // Save to cache.
        this._addConnection();
        this._watchRootProjectDirectory();
      }
    })
  }, {
    key: '_addConnection',
    value: function _addConnection() {
      _connections.push(this);
      _emitter.emit('did-add', this);
    }
  }, {
    key: '_watchRootProjectDirectory',
    value: function _watchRootProjectDirectory() {
      // TODO(peterhal): move singleton from main.js to client.js

      var _require6 = require('./service-manager');

      var getServiceByNuclideUri = _require6.getServiceByNuclideUri;

      var rootDirectoryUri = this.getUriForInitialWorkingDirectory();

      var _getServiceByNuclideUri = getServiceByNuclideUri('FileWatcherService', rootDirectoryUri);

      var watchDirectoryRecursive = _getServiceByNuclideUri.watchDirectoryRecursive;

      // Start watching the project for changes and initialize the root watcher
      // for next calls to `watchFile` and `watchDirectory`.
      var watchStream = watchDirectoryRecursive(rootDirectoryUri);
      var subscription = watchStream.subscribe(function (watchUpdate) {
        // Nothing needs to be done if the root directory was watched correctly.
        // Let's just console log it anyway.
        logger.info('Watcher Features Initialized for project: ' + rootDirectoryUri, watchUpdate);
      }, function (error) {
        var warningMessageToUser = 'You just connected to a remote project ' + ('(' + rootDirectoryUri + '), but we recommend you remove this directory now!') + '<br/><br/> The directory you connected to could not be watched by watchman, ' + 'so crucial features like synced remote file editing, file search, ' + 'and Mercurial-related updates will not work.';
        var loggedErrorMessage = error.message || error;
        if (loggedErrorMessage.match(WATCHMAN_ERROR_MESSAGE_FOR_ENFORCE_ROOT_FILES_REGEX)) {
          warningMessageToUser += '<br/><br/>You need to connect to a different root directory, ' + 'because the watchman on the server you are connecting to is configured to not allow ' + ('you to watch ' + rootDirectoryUri + '. You may have luck connecting to a deeper ') + 'directory, because often watchman is configured to only allow watching ' + 'certain subdirectories (often roots or subdirectories of source control repositories).';
        }
        // Add a persistent warning message to make sure the user sees it before dismissing.
        atom.notifications.addWarning(warningMessageToUser, { dismissable: true });
        logger.error('Watcher failed to start - watcher features disabled! Error: ' + loggedErrorMessage);
      }, function () {
        // Nothing needs to be done if the root directory watch has ended.
        logger.info('Watcher Features Ended for project: ' + rootDirectoryUri);
      });
      this._subscriptions.add(subscription);
    }
  }, {
    key: 'close',
    value: function close() {
      // Close the eventbus that will stop the heartbeat interval, websocket reconnect trials, ..etc.
      if (this._client) {
        this._client.close();
        this._client = null;
      }
      if (!this._closed) {
        // Future getClient calls should fail, if it has a cached RemoteConnection instance.
        this._closed = true;
        // Remove from _connections to not be considered in future connection queries.
        _connections.splice(_connections.indexOf(this), 1);
        _emitter.emit('did-close', this);
      }
    }
  }, {
    key: 'getClient',
    value: function getClient() {
      if (!this._initialized) {
        throw new Error('Remote connection has not been initialized.');
      } else if (this._closed) {
        throw new Error('Remote connection has been closed.');
      } else {
        return this._getClient();
      }
    }
  }, {
    key: '_getClient',
    value: function _getClient() {
      if (!this._client) {
        var uri = undefined;
        var options = {};

        // Use https if we have key, cert, and ca
        if (this._isSecure()) {
          options.certificateAuthorityCertificate = this._config.certificateAuthorityCertificate;
          options.clientCertificate = this._config.clientCertificate;
          options.clientKey = this._config.clientKey;
          uri = 'https://' + this.getRemoteHost();
        } else {
          uri = 'http://' + this.getRemoteHost();
        }

        // The remote connection and client are identified by both the remote host and the inital working directory.
        var clientId = this.getRemoteHost() + this.getPathForInitialWorkingDirectory();
        this._client = new NuclideClient(clientId, new NuclideRemoteEventbus(uri, options), { cwd: this._config.cwd });
      }
      return this._client;
    }

    /**
     * Make rpc call through this connection given serviceUri in form of `$serviceName/$methodName`
     * and args as arguments list.
     */
  }, {
    key: 'makeRpc',
    value: function makeRpc(serviceUri, args, serviceOptions) {
      return this.getClient().makeRpc(serviceUri, args, serviceOptions);
    }
  }, {
    key: 'registerEventListener',
    value: function registerEventListener(eventName, callback, serviceOptions) {
      return this.getClient().registerEventListener(eventName, callback, serviceOptions);
    }
  }, {
    key: '_isSecure',
    value: function _isSecure() {
      return !!(this._config.certificateAuthorityCertificate && this._config.clientCertificate && this._config.clientKey);
    }
  }, {
    key: 'getRemoteHost',
    value: function getRemoteHost() {
      return this._config.host + ':' + this._config.port;
    }
  }, {
    key: 'getRemoteHostname',
    value: function getRemoteHostname() {
      return this._config.host;
    }
  }, {
    key: 'getUriForInitialWorkingDirectory',
    value: function getUriForInitialWorkingDirectory() {
      return this.getUriOfRemotePath(this.getPathForInitialWorkingDirectory());
    }
  }, {
    key: 'getPathForInitialWorkingDirectory',
    value: function getPathForInitialWorkingDirectory() {
      return this._config.cwd;
    }
  }, {
    key: 'getConfig',
    value: function getConfig() {
      return this._config;
    }
  }, {
    key: 'getService',

    // TODO(peterhal): The implementation should move from service-manager to here
    // however we should wait until we remove the event-bus and v2 rpc framework
    // before making that change.
    value: function getService(serviceName) {
      var _require7 = require('./service-manager');

      var getRemoteServiceByRemoteConnection = _require7.getRemoteServiceByRemoteConnection;

      return getRemoteServiceByRemoteConnection(serviceName, this);
    }
  }], [{
    key: 'createConnectionBySavedConfig',
    value: _asyncToGenerator(function* (host, cwd) {
      var connectionConfig = getConnectionConfig(host);
      if (!connectionConfig) {
        return;
      }
      try {
        var config = _extends({}, connectionConfig, { cwd: cwd });
        var _connection = new RemoteConnection(config);
        yield _connection.initialize();
        return _connection;
      } catch (e) {
        logger.warn('Failed to reuse connectionConfiguration for ' + host, e);
        return null;
      }
    })
  }, {
    key: 'onDidAddRemoteConnection',
    value: function onDidAddRemoteConnection(handler) {
      _emitter.on('did-add', handler);
      return new Disposable(function () {
        _emitter.removeListener('did-add', handler);
      });
    }
  }, {
    key: 'onDidCloseRemoteConnection',
    value: function onDidCloseRemoteConnection(handler) {
      _emitter.on('did-close', handler);
      return new Disposable(function () {
        _emitter.removeListener('did-close', handler);
      });
    }
  }, {
    key: 'getForUri',
    value: function getForUri(uri) {
      var _remoteUri$parse4 = remoteUri.parse(uri);

      var hostname = _remoteUri$parse4.hostname;
      var path = _remoteUri$parse4.path;

      return RemoteConnection.getByHostnameAndPath(hostname, path);
    }

    /**
     * Get cached connection match the hostname and the path has the prefix of connection.cwd.
     * @param hostname The connected server host name.
     * @param path The absolute path that's has the prefix of cwd of the connection.
     *   If path is null, empty or undefined, then return the connection which matches
     *   the hostname and ignore the initial working directory.
     */
  }, {
    key: 'getByHostnameAndPath',
    value: function getByHostnameAndPath(hostname, path) {
      return _connections.filter(function (connection) {
        return connection.getRemoteHostname() === hostname && (!path || path.startsWith(connection.getPathForInitialWorkingDirectory()));
      })[0];
    }
  }, {
    key: 'getByHostname',
    value: function getByHostname(hostname) {
      return _connections.filter(function (connection) {
        return connection.getRemoteHostname() === hostname;
      });
    }
  }]);

  return RemoteConnection;
})();

RemoteConnection.test = {
  connections: _connections,
  getReloadKeystrokeLabel: getReloadKeystrokeLabel
};

module.exports = RemoteConnection;
// host nuclide server is running on.
// port to connect to.
// Path to remote directory user should start in upon connection.
// certificate of certificate authority.
// client certificate for https connection.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1jb25uZWN0aW9uL2xpYi9SZW1vdGVDb25uZWN0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQVc4QixPQUFPLENBQUMsTUFBTSxDQUFDOztJQUFsRCxtQkFBbUIsWUFBbkIsbUJBQW1CO0lBQUUsVUFBVSxZQUFWLFVBQVU7O0FBQ3RDLElBQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQ2hELElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDOztnQkFDL0IsT0FBTyxDQUFDLFFBQVEsQ0FBQzs7SUFBakMsWUFBWSxhQUFaLFlBQVk7O0FBRW5CLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUMzQyxJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUNyRCxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsa0NBQWtDLENBQUMsQ0FBQztBQUNsRSxJQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDOztnQkFDL0IsT0FBTyxDQUFDLHdDQUF3QyxDQUFDOztJQUE3RixtQkFBbUIsYUFBbkIsbUJBQW1CO0lBQUUsbUJBQW1CLGFBQW5CLG1CQUFtQjs7Z0JBQzFCLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQzs7SUFBeEMsVUFBVSxhQUFWLFVBQVU7O0FBRWpCLElBQU0sMkJBQTJCLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLElBQU0sNEJBQTRCLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZDLElBQU0sOEJBQThCLEdBQUcsQ0FBQyxDQUFDOzs7O0FBSXpDLElBQU0sbURBQW1ELEdB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LENBQUMsVUFBVSxDQUFDLGlDQUFpQyxFQUFFLENBQUMsQ0FBQSxBQUFDLENBQUM7T0FDaEYsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ1A7OztXQUVtQix1QkFBQyxRQUFnQixFQUEyQjtBQUM5RCxhQUFPLFlBQVksQ0FBQyxNQUFNLENBQUMsVUFBQSxVQUFVO2VBQUksVUFBVSxDQUFDLGlCQUFpQixFQUFFLEtBQUssUUFBUTtPQUFBLENBQUMsQ0FBQztLQUN2Rjs7O1NBemNHLGdCQUFnQjs7O0FBcWR0QixnQkFBZ0IsQ0FBQyxJQUFJLEdBQUc7QUFDdEIsYUFBVyxFQUFFLFlBQVk7QUFDekIseUJBQXVCLEVBQXZCLHVCQUF1QjtDQUN4QixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsZ0JBQWdCLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtcmVtb3RlLWNvbm5lY3Rpb24vbGliL1JlbW90ZUNvbm5lY3Rpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5jb25zdCB7Q29tcG9zaXRlRGlzcG9zYWJsZSwgRGlzcG9zYWJsZX0gPSByZXF1aXJlKCdhdG9tJyk7XG5jb25zdCByZW1vdGVVcmkgPSByZXF1aXJlKCdudWNsaWRlLXJlbW90ZS11cmknKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xuY29uc3Qge0V2ZW50RW1pdHRlcn0gPSByZXF1aXJlKCdldmVudHMnKTtcblxuY29uc3QgUmVtb3RlRmlsZSA9IHJlcXVpcmUoJy4vUmVtb3RlRmlsZScpO1xuY29uc3QgUmVtb3RlRGlyZWN0b3J5ID0gcmVxdWlyZSgnLi9SZW1vdGVEaXJlY3RvcnknKTtcbmNvbnN0IE51Y2xpZGVDbGllbnQgPSByZXF1aXJlKCdudWNsaWRlLXNlcnZlci9saWIvTnVjbGlkZUNsaWVudCcpO1xuY29uc3QgTnVjbGlkZVJlbW90ZUV2ZW50YnVzID0gcmVxdWlyZSgnbnVjbGlkZS1zZXJ2ZXIvbGliL051Y2xpZGVSZW1vdGVFdmVudGJ1cycpO1xuY29uc3Qge2dldENvbm5lY3Rpb25Db25maWcsIHNldENvbm5lY3Rpb25Db25maWd9ID0gcmVxdWlyZSgnLi9SZW1vdGVDb25uZWN0aW9uQ29uZmlndXJhdGlvbk1hbmFnZXInKTtcbmNvbnN0IHtnZXRWZXJzaW9ufSA9IHJlcXVpcmUoJ251Y2xpZGUtdmVyc2lvbicpO1xuXG5jb25zdCBIRUFSVEJFQVRfQVdBWV9SRVBPUlRfQ09VTlQgPSAzO1xuY29uc3QgSEVBUlRCRUFUX05PVElGSUNBVElPTl9FUlJPUiA9IDE7XG5jb25zdCBIRUFSVEJFQVRfTk9USUZJQ0FUSU9OX1dBUk5JTkcgPSAyO1xuXG4vLyBUYWtlbiBmcm9tIHRoZSBlcnJvciBtZXNzYWdlIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svd2F0Y2htYW4vYmxvYi85OWRkZThlZTNmMTMyMzNiZTA5N2MwMzYxNDc3NDhiMmQ3ZjhiZmE3L3Rlc3RzL2ludGVncmF0aW9uL3Jvb3RyZXN0cmljdC5waHAjTDU4XG5jb25zdCBXQVRDSE1BTl9FUlJPUl9NRVNTQUdFX0ZPUl9FTkZPUkNFX1JPT1RfRklMRVNfUkVHRVggPSAvZ2xvYmFsIGNvbmZpZyByb290X2ZpbGVzLztcblxudHlwZSBIZWFydGJlYXROb3RpZmljYXRpb24gPSB7XG4gIG5vdGlmaWNhdGlvbjogYXRvbSROb3RpZmljYXRpb247XG4gIGNvZGU6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgUmVtb3RlQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb24gPSB7XG4gIGhvc3Q6IHN0cmluZzsgLy8gaG9zdCBudWNsaWRlIHNlcnZlciBpcyBydW5uaW5nIG9uLlxuICBwb3J0OiBudW1iZXI7IC8vIHBvcnQgdG8gY29ubmVjdCB0by5cbiAgY3dkOiBzdHJpbmc7IC8vIFBhdGggdG8gcmVtb3RlIGRpcmVjdG9yeSB1c2VyIHNob3VsZCBzdGFydCBpbiB1cG9uIGNvbm5lY3Rpb24uXG4gIGNlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGU/OiBCdWZmZXI7IC8vIGNlcnRpZmljYXRlIG9mIGNlcnRpZmljYXRlIGF1dGhvcml0eS5cbiAgY2xpZW50Q2VydGlmaWNhdGU/OiBCdWZmZXI7IC8vIGNsaWVudCBjZXJ0aWZpY2F0ZSBmb3IgaHR0cHMgY29ubmVjdGlvbi5cbiAgY2xpZW50S2V5PzogQnVmZmVyOyAvLyBrZXkgZm9yIGh0dHBzIGNvbm5lY3Rpb24uXG59XG5cbmZ1bmN0aW9uIGdldFJlbG9hZEtleXN0cm9rZUxhYmVsKCk6ID9zdHJpbmcge1xuICBjb25zdCBiaW5kaW5nID0gYXRvbS5rZXltYXBzLmZpbmRLZXlCaW5kaW5ncyh7Y29tbWFuZDogJ3dpbmRvdzpyZWxvYWQnfSk7XG4gIGlmICghYmluZGluZyB8fCAhYmluZGluZ1swXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHtodW1hbml6ZUtleXN0cm9rZX0gPSByZXF1aXJlKCdudWNsaWRlLWtleXN0cm9rZS1sYWJlbCcpO1xuICByZXR1cm4gaHVtYW5pemVLZXlzdHJva2UoYmluZGluZ1swXS5rZXlzdHJva2VzKTtcbn1cblxuY29uc3QgX2Nvbm5lY3Rpb25zOiBBcnJheTxSZW1vdGVDb25uZWN0aW9uPiA9IFtdO1xuY29uc3QgX2VtaXR0ZXI6IEV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuY2xhc3MgUmVtb3RlQ29ubmVjdGlvbiB7XG4gIF9lbnRyaWVzOiB7W3BhdGg6IHN0cmluZ106IFJlbW90ZUZpbGV8UmVtb3RlRGlyZWN0b3J5fTtcbiAgX2NvbmZpZzogUmVtb3RlQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb247XG4gIF9pbml0aWFsaXplZDogP2Jvb2w7XG4gIF9jbG9zZWQ6ID9ib29sO1xuICBfc3Vic2NyaXB0aW9uczogQ29tcG9zaXRlRGlzcG9zYWJsZTtcbiAgX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uOiA/SGdSZXBvc2l0b3J5RGVzY3JpcHRpb247XG4gIF9oZWFydGJlYXROZXR3b3JrQXdheUNvdW50OiBudW1iZXI7XG4gIF9sYXN0SGVhcnRiZWF0Tm90aWZpY2F0aW9uOiA/SGVhcnRiZWF0Tm90aWZpY2F0aW9uO1xuICBfY2xpZW50OiA/TnVjbGlkZUNsaWVudDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFJlbW90ZUNvbm5lY3Rpb25Db25maWd1cmF0aW9uKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgdGhpcy5fZW50cmllcyA9IHt9O1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9oZWFydGJlYXROZXR3b3JrQXdheUNvdW50ID0gMDtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29ubmVjdGlvbiBieSByZXVzaW5nIHRoZSBjb25maWd1cmF0aW9uIG9mIGxhc3Qgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uIGFzc29jaWF0ZWQgd2l0aFxuICAgKiBnaXZlbiBob3N0LiBJZiB0aGUgc2VydmVyJ3MgY2VydHMgaGFzIGJlZW4gdXBkYXRlZCBvciB0aGVyZSBpcyBubyBwcmV2aW91cyBzdWNjZXNzZnVsXG4gICAqIGNvbm5lY3Rpb24sIG51bGwgKHJlc29sdmVkIGJ5IHByb21pc2UpIGlzIHJldHVybmVkLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUNvbm5lY3Rpb25CeVNhdmVkQ29uZmlnKFxuICAgIGhvc3Q6IHN0cmluZyxcbiAgICBjd2Q6IHN0cmluZyxcbiAgKTogUHJvbWlzZTw/UmVtb3RlQ29ubmVjdGlvbj4ge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBnZXRDb25uZWN0aW9uQ29uZmlnKGhvc3QpO1xuICAgIGlmICghY29ubmVjdGlvbkNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uZmlnID0gey4uLmNvbm5lY3Rpb25Db25maWcsIGN3ZH07XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IFJlbW90ZUNvbm5lY3Rpb24oY29uZmlnKTtcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uaW5pdGlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byByZXVzZSBjb25uZWN0aW9uQ29uZmlndXJhdGlvbiBmb3IgJHtob3N0fWAsIGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gQSB3b3JrYXJvdW5kIGJlZm9yZSBBdG9tIDIuMDogQXRvbSdzIFByb2plY3Q6OnNldFBhdGhzIGN1cnJlbnRseSB1c2VzXG4gIC8vIDo6cmVwb3NpdG9yeUZvckRpcmVjdG9yeVN5bmMsIHNvIHdlIG5lZWQgdGhlIHJlcG8gaW5mb3JtYXRpb24gdG8gYWxyZWFkeSBiZVxuICAvLyBhdmFpbGFibGUgd2hlbiB0aGUgbmV3IHBhdGggaXMgYWRkZWQuIHQ2OTEzNjI0IHRyYWNrcyBjbGVhbnVwIG9mIHRoaXMuXG4gIGFzeW5jIF9zZXRIZ1JlcG9JbmZvKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlbW90ZVBhdGggPSB0aGlzLmdldFBhdGhGb3JJbml0aWFsV29ya2luZ0RpcmVjdG9yeSgpO1xuICAgIGNvbnN0IHtnZXRIZ1JlcG9zaXRvcnl9ID0gdGhpcy5nZXRTZXJ2aWNlKCdTb3VyY2VDb250cm9sU2VydmljZScpO1xuICAgIGNvbnN0IGhnUmVwb0Rlc2NyaXB0aW9uID0gYXdhaXQgZ2V0SGdSZXBvc2l0b3J5KHJlbW90ZVBhdGgpO1xuICAgIHRoaXMuX3NldEhnUmVwb3NpdG9yeURlc2NyaXB0aW9uKGhnUmVwb0Rlc2NyaXB0aW9uKTtcbiAgfVxuXG4gIF9tb25pdG9yQ29ubmVjdGlvbkhlYXJ0YmVhdCgpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLmdldENsaWVudCgpLmV2ZW50YnVzLnNvY2tldDtcbiAgICBjb25zdCBzZXJ2ZXJVcmkgPSBzb2NrZXQuZ2V0U2VydmVyVXJpKCk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIEF0b20gbm90aWZpY2F0aW9uIGZvciB0aGUgZGV0ZWN0ZWQgaGVhcnRiZWF0IG5ldHdvcmsgc3RhdHVzXG4gICAgICogVGhlIGZ1bmN0aW9uIG1ha2VzIHN1cmUgbm90IHRvIGFkZCBtYW55IG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBzYW1lIGV2ZW50IGFuZCBwcmlvcml0aXplIG5ldyBldmVudHMuXG4gICAgICovXG4gICAgY29uc3QgYWRkSGVhcnRiZWF0Tm90aWZpY2F0aW9uID0gKHR5cGU6IG51bWJlciwgZXJyb3JDb2RlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgZGlzbWlzc2FibGU6IGJvb2xlYW4pID0+IHtcbiAgICAgIGNvbnN0IHtjb2RlLCBub3RpZmljYXRpb246IGV4aXN0aW5nTm90aWZpY2F0aW9ufSA9IHRoaXMuX2xhc3RIZWFydGJlYXROb3RpZmljYXRpb24gfHwge307XG4gICAgICBpZiAoY29kZSAmJiBjb2RlID09PSBlcnJvckNvZGUgJiYgZGlzbWlzc2FibGUpIHtcbiAgICAgICAgLy8gQSBkaXNtaXNzaWJsZSBoZWFydGJlYXQgbm90aWZpY2F0aW9uIHdpdGggdGhpcyBjb2RlIGlzIGFscmVhZHkgYWN0aXZlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgbm90aWZpY2F0aW9uID0gbnVsbDtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIEhFQVJUQkVBVF9OT1RJRklDQVRJT05fRVJST1I6XG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gYXRvbS5ub3RpZmljYXRpb25zLmFkZEVycm9yKG1lc3NhZ2UsIHtkaXNtaXNzYWJsZX0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhFQVJUQkVBVF9OT1RJRklDQVRJT05fV0FSTklORzpcbiAgICAgICAgICBub3RpZmljYXRpb24gPSBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkV2FybmluZyhtZXNzYWdlLCB7ZGlzbWlzc2FibGV9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb25nbml6ZWQgaGVhcnRiZWF0IG5vdGlmaWNhdGlvbiB0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgICAgZXhpc3RpbmdOb3RpZmljYXRpb24uZGlzbWlzcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFzdEhlYXJ0YmVhdE5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgbm90aWZpY2F0aW9uLFxuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBvbkhlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9sYXN0SGVhcnRiZWF0Tm90aWZpY2F0aW9uKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIGV4aXN0aW5nIGhlYXJ0YmVhdCBlcnJvci93YXJuaW5nLFxuICAgICAgICAvLyB0aGF0IG1lYW5zIGNvbm5lY3Rpb24gaGFzIGJlZW4gbG9zdCBhbmQgd2Ugc2hhbGwgc2hvdyBhIG1lc3NhZ2UgYWJvdXQgY29ubmVjdGlvblxuICAgICAgICAvLyBiZWluZyByZXN0b3JlZCB3aXRob3V0IGEgcmVjb25uZWN0IHByb21wdC5cbiAgICAgICAgY29uc3Qge25vdGlmaWNhdGlvbn0gPSB0aGlzLl9sYXN0SGVhcnRiZWF0Tm90aWZpY2F0aW9uO1xuICAgICAgICBub3RpZmljYXRpb24uZGlzbWlzcygpO1xuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkU3VjY2VzcygnQ29ubmVjdGlvbiByZXN0b3JlZCB0byBOdWNsaWRlIFNlcnZlciBhdDogJyArIHNlcnZlclVyaSk7XG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdE5ldHdvcmtBd2F5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLl9sYXN0SGVhcnRiZWF0Tm90aWZpY2F0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgbm90aWZ5TmV0d29ya0F3YXkgPSAoY29kZTogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLl9oZWFydGJlYXROZXR3b3JrQXdheUNvdW50Kys7XG4gICAgICBpZiAodGhpcy5faGVhcnRiZWF0TmV0d29ya0F3YXlDb3VudCA+PSBIRUFSVEJFQVRfQVdBWV9SRVBPUlRfQ09VTlQpIHtcbiAgICAgICAgYWRkSGVhcnRiZWF0Tm90aWZpY2F0aW9uKEhFQVJUQkVBVF9OT1RJRklDQVRJT05fV0FSTklORywgY29kZSxcbiAgICAgICAgICAnTnVjbGlkZSBzZXJ2ZXIgY2FuIG5vdCBiZSByZWFjaGVkIGF0OiAnICsgc2VydmVyVXJpICtcbiAgICAgICAgICAnPGJyLz5DaGVjayB5b3VyIG5ldHdvcmsgY29ubmVjdGlvbiEnLFxuICAgICAgICAgIC8qZGlzbWlzc2FibGUqLyB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb25IZWFydGJlYXRFcnJvciA9IChlcnJvcjogYW55KSA9PiB7XG4gICAgICBjb25zdCByZWxvYWRrZXlzdHJva2UgPSBnZXRSZWxvYWRLZXlzdHJva2VMYWJlbCgpO1xuICAgICAgY29uc3QgcmVsb2FkS2V5c3Ryb2tlTGFiZWwgPSByZWxvYWRrZXlzdHJva2UgPyBgIDogKCR7cmVsb2Fka2V5c3Ryb2tlfSlgIDogJyc7XG4gICAgICBjb25zdCB7Y29kZSwgbWVzc2FnZSwgb3JpZ2luYWxDb2RlfSA9IGVycm9yO1xuICAgICAgbG9nZ2VyLmluZm8oJ0hlYXJ0YmVhdCBuZXR3b3JrIGVycm9yOicsIGNvZGUsIG9yaWdpbmFsQ29kZSwgbWVzc2FnZSk7XG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAnTkVUV09SS19BV0FZJzpcbiAgICAgICAgICAgIC8vIE5vdGlmeSBzd2l0Y2hpbmcgbmV0d29ya3MsIGRpc2Nvbm5lY3RlZCwgdGltZW91dCwgdW5yZWFjaGFibGUgc2VydmVyIG9yIGZyYWdpbGUgY29ubmVjdGlvbi5cbiAgICAgICAgICBub3RpZnlOZXR3b3JrQXdheShjb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0VSVkVSX0NSQVNIRUQnOlxuICAgICAgICAgICAgLy8gU2VydmVyIHNodXQgZG93biBvciBwb3J0IG5vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgICAgICAgICAgLy8gTm90aWZ5IHRoZSBzZXJ2ZXIgd2FzIHRoZXJlLCBidXQgbm93IGdvbmUuXG4gICAgICAgICAgYWRkSGVhcnRiZWF0Tm90aWZpY2F0aW9uKEhFQVJUQkVBVF9OT1RJRklDQVRJT05fRVJST1IsIGNvZGUsXG4gICAgICAgICAgICAgICAgJ051Y2xpZGUgc2VydmVyIGNyYXNoZWQhPGJyLz4nICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIHJlbG9hZCBOdWNsaWRlIHRvIHJlc3RvcmUgeW91ciByZW1vdGUgcHJvamVjdCBjb25uZWN0aW9uIScgK1xuICAgICAgICAgICAgICAgIHJlbG9hZEtleXN0cm9rZUxhYmVsLFxuICAgICAgICAgICAgICAgIC8qZGlzbWlzc2FibGUqLyB0cnVlKTtcbiAgICAgICAgICAgIC8vIFRPRE8obW9zdCkgcmVjb25uZWN0IFJlbW90ZUNvbm5lY3Rpb24sIHJlc3RvcmUgdGhlIGN1cnJlbnQgcHJvamVjdCBzdGF0ZSxcbiAgICAgICAgICAgIC8vIGFuZCBmaW5hbGx5IGNoYW5nZSBkaXNtaXNzYWJsZSB0byBmYWxzZSBhbmQgdHlwZSB0byAnV0FSTklORycuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1BPUlRfTk9UX0FDQ0VTU0lCTEUnOlxuICAgICAgICAgICAgLy8gTm90aWZ5IG5ldmVyIGhlYXJkIGEgaGVhcnRiZWF0IGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICBjb25zdCB7cG9ydH0gPSByZW1vdGVVcmkucGFyc2Uoc2VydmVyVXJpKTtcbiAgICAgICAgICBhZGRIZWFydGJlYXROb3RpZmljYXRpb24oSEVBUlRCRUFUX05PVElGSUNBVElPTl9FUlJPUiwgY29kZSxcbiAgICAgICAgICAgICAgICBgTnVjbGlkZSBzZXJ2ZXIgaXMgbm90IHJlYWNoYWJsZS48YnIvPkl0IGNvdWxkIGJlIHJ1bm5pbmcgb24gYSBwb3J0IHRoYXQgaXMgbm90IGFjY2Vzc2libGU6ICR7cG9ydH1gLFxuICAgICAgICAgICAgICAgIC8qZGlzbWlzc2FibGUqLyB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSU5WQUxJRF9DRVJUSUZJQ0FURSc6XG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBpcyBub3QgYWNjZXB0ZWQgYnkgbnVjbGlkZSBzZXJ2ZXIgKGNlcnRpZmljYXRlIG1pc21hdGNoKS5cbiAgICAgICAgICBhZGRIZWFydGJlYXROb3RpZmljYXRpb24oSEVBUlRCRUFUX05PVElGSUNBVElPTl9FUlJPUiwgY29kZSxcbiAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbiBSZXNldCBFcnJvciEhPGJyLz5UaGlzIGNvdWxkIGJlIGNhdXNlZCBieSB0aGUgY2xpZW50IGNlcnRpZmljYXRlIG1pc21hdGNoaW5nIHRoZSBzZXJ2ZXIgY2VydGlmaWNhdGUuPGJyLz4nICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIHJlbG9hZCBOdWNsaWRlIHRvIHJlc3RvcmUgeW91ciByZW1vdGUgcHJvamVjdCBjb25uZWN0aW9uIScgK1xuICAgICAgICAgICAgICAgIHJlbG9hZEtleXN0cm9rZUxhYmVsLFxuICAgICAgICAgICAgICAgIC8qZGlzbWlzc2FibGUqLyB0cnVlKTtcbiAgICAgICAgICAgIC8vIFRPRE8obW9zdCk6IHJlY29ubmVjdCBSZW1vdGVDb25uZWN0aW9uLCByZXN0b3JlIHRoZSBjdXJyZW50IHByb2plY3Qgc3RhdGUuXG4gICAgICAgICAgICAvLyBhbmQgZmluYWxseSBjaGFuZ2UgZGlzbWlzc2FibGUgdG8gZmFsc2UgYW5kIHR5cGUgdG8gJ1dBUk5JTkcnLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG5vdGlmeU5ldHdvcmtBd2F5KGNvZGUpO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignVW5yZWNvbmduaXplZCBoZWFydGJlYXQgZXJyb3IgY29kZTogJyArIGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgc29ja2V0Lm9uKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XG4gICAgc29ja2V0Lm9uKCdoZWFydGJlYXQuZXJyb3InLCBvbkhlYXJ0YmVhdEVycm9yKTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKG5ldyBEaXNwb3NhYmxlKCgpID0+IHtcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0Jywgb25IZWFydGJlYXQpO1xuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQuZXJyb3InLCBvbkhlYXJ0YmVhdEVycm9yKTtcbiAgICB9KSk7XG4gIH1cblxuICBnZXRVcmlPZlJlbW90ZVBhdGgocmVtb3RlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG51Y2xpZGU6Ly8ke3RoaXMuZ2V0UmVtb3RlSG9zdCgpfSR7cmVtb3RlUGF0aH1gO1xuICB9XG5cbiAgZ2V0UGF0aE9mVXJpKHVyaTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmVtb3RlVXJpLnBhcnNlKHVyaSkucGF0aDtcbiAgfVxuXG4gIGNyZWF0ZURpcmVjdG9yeSh1cmk6IHN0cmluZyk6IFJlbW90ZURpcmVjdG9yeSB7XG4gICAgbGV0IHtwYXRofSA9IHJlbW90ZVVyaS5wYXJzZSh1cmkpO1xuICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJykubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgbGV0IGVudHJ5ID0gdGhpcy5fZW50cmllc1twYXRoXTtcbiAgICBpZiAoIWVudHJ5IHx8IGVudHJ5LmdldExvY2FsUGF0aCgpICE9PSBwYXRoKSB7XG4gICAgICB0aGlzLl9lbnRyaWVzW3BhdGhdID0gZW50cnkgPSBuZXcgUmVtb3RlRGlyZWN0b3J5KFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLmdldFVyaU9mUmVtb3RlUGF0aChwYXRoKSxcbiAgICAgICAge2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uOiB0aGlzLl9oZ1JlcG9zaXRvcnlEZXNjcmlwdGlvbn1cbiAgICAgICk7XG4gICAgICAvLyBUT0RPOiBXZSBzaG91bGQgYWRkIHRoZSBmb2xsb3dpbmcgbGluZSB0byBrZWVwIHRoZSBjYWNoZSB1cC10by1kYXRlLlxuICAgICAgLy8gV2UgbmVlZCB0byBpbXBsZW1lbnQgb25EaWRSZW5hbWUgYW5kIG9uRGlkRGVsZXRlIGluIFJlbW90ZURpcmVjdG9yeVxuICAgICAgLy8gZmlyc3QuIEl0J3Mgb2sgdGhhdCB3ZSBkb24ndCBhZGQgdGhlIGhhbmRsZXJzIGZvciBub3cgc2luY2Ugd2UgaGF2ZVxuICAgICAgLy8gdGhlIGNoZWNrIGBlbnRyeS5nZXRMb2NhbFBhdGgoKSAhPT0gcGF0aGAgYWJvdmUuXG4gICAgICAvL1xuICAgICAgLy8gdGhpcy5fYWRkSGFuZGxlcnNGb3JFbnRyeShlbnRyeSk7XG4gICAgfVxuXG4gICAgaWYgKCFlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggaXMgbm90IGEgZGlyZWN0b3J5OicgKyB1cmkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuXG4gIC8vIEEgd29ya2Fyb3VuZCBiZWZvcmUgQXRvbSAyLjA6IHNlZSA6OmdldEhnUmVwb0luZm8gb2YgbWFpbi5qcy5cbiAgX3NldEhnUmVwb3NpdG9yeURlc2NyaXB0aW9uKGhnUmVwb3NpdG9yeURlc2NyaXB0aW9uOiBIZ1JlcG9zaXRvcnlEZXNjcmlwdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uID0gaGdSZXBvc2l0b3J5RGVzY3JpcHRpb247XG4gIH1cblxuICBjcmVhdGVGaWxlKHVyaTogc3RyaW5nKTogUmVtb3RlRmlsZSB7XG4gICAgbGV0IHtwYXRofSA9IHJlbW90ZVVyaS5wYXJzZSh1cmkpO1xuICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJykubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgbGV0IGVudHJ5ID0gdGhpcy5fZW50cmllc1twYXRoXTtcbiAgICBpZiAoIWVudHJ5IHx8IGVudHJ5LmdldExvY2FsUGF0aCgpICE9PSBwYXRoKSB7XG4gICAgICB0aGlzLl9lbnRyaWVzW3BhdGhdID0gZW50cnkgPSBuZXcgUmVtb3RlRmlsZSh0aGlzLCB0aGlzLmdldFVyaU9mUmVtb3RlUGF0aChwYXRoKSk7XG4gICAgICB0aGlzLl9hZGRIYW5kbGVyc0ZvckVudHJ5KGVudHJ5KTtcbiAgICB9XG5cbiAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGlzIG5vdCBhIGZpbGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnk7XG4gIH1cblxuICBfYWRkSGFuZGxlcnNGb3JFbnRyeShlbnRyeTogUmVtb3RlRmlsZSB8IFJlbW90ZURpcmVjdG9yeSk6IHZvaWQge1xuICAgIGNvbnN0IG9sZFBhdGggPSBlbnRyeS5nZXRMb2NhbFBhdGgoKTtcbiAgICBjb25zdCByZW5hbWVTdWJzY3JpcHRpb24gPSBlbnRyeS5vbkRpZFJlbmFtZSgoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fZW50cmllc1tvbGRQYXRoXTtcbiAgICAgIHRoaXMuX2VudHJpZXNbZW50cnkuZ2V0TG9jYWxQYXRoKCldID0gZW50cnk7XG4gICAgfSk7XG4gICAgY29uc3QgZGVsZXRlU3Vic2NyaXB0aW9uID0gZW50cnkub25EaWREZWxldGUoKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX2VudHJpZXNbZW50cnkuZ2V0TG9jYWxQYXRoKCldO1xuICAgICAgcmVuYW1lU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFJpZ2h0IG5vdyB3ZSBkb24ndCByZS1oYW5kc2hha2UuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICBjb25zdCBjbGllbnQgPSB0aGlzLl9nZXRDbGllbnQoKTtcblxuICAgICAgLy8gVGVzdCBjb25uZWN0aW9uIGZpcnN0LiBGaXJzdCB0aW1lIHdlIGdldCBoZXJlIHdlJ3JlIGNoZWNraW5nIHRvIHJlZXN0YWJsaXNoXG4gICAgICAvLyBjb25uZWN0aW9uIHVzaW5nIGNhY2hlZCBjcmVkZW50aWFscy4gVGhpcyB3aWxsIGZhaWwgZmFzdCAoZmFzdGVyIHRoYW4gaW5mb1NlcnZpY2UpXG4gICAgICAvLyB3aGVuIHdlIGRvbid0IGhhdmUgY2FjaGVkIGNyZWRlbnRpYWxzIHlldC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC50ZXN0Q29ubmVjdGlvbigpO1xuXG4gICAgICAgIC8vIERvIHZlcnNpb24gY2hlY2suXG4gICAgICAgIGxldCBzZXJ2ZXJWZXJzaW9uO1xuXG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IGluaXRpYWxpemVkIHRvIHRydWUgb3B0aW1pc3RpY2FsbHkgc28gdGhhdCB3ZSBjYW4gZ2V0IHRoZSBJbmZvU2VydmljZS5cbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkbid0IG5lZWQgdGhlIGNsaWVudCB0byBnZXQgYSBzZXJ2aWNlLlxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGluZm9TZXJ2aWNlID0gdGhpcy5nZXRTZXJ2aWNlKCdJbmZvU2VydmljZScpO1xuICAgICAgICBzZXJ2ZXJWZXJzaW9uID0gYXdhaXQgaW5mb1NlcnZpY2UuZ2V0U2VydmVyVmVyc2lvbigpO1xuXG4gICAgICAgIGNvbnN0IGNsaWVudFZlcnNpb24gPSBnZXRWZXJzaW9uKCk7XG4gICAgICAgIGlmIChjbGllbnRWZXJzaW9uICE9PSBzZXJ2ZXJWZXJzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFZlcnNpb24gbWlzbWF0Y2guIENsaWVudCBhdCAke2NsaWVudFZlcnNpb259IHdoaWxlIHNlcnZlciBhdCAke3NlcnZlclZlcnNpb259LmApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNsaWVudC5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG5cbiAgICAgIGNvbnN0IEZpbGVTeXN0ZW1TZXJ2aWNlID0gdGhpcy5nZXRTZXJ2aWNlKCdGaWxlU3lzdGVtU2VydmljZScpO1xuICAgICAgdGhpcy5fY29uZmlnLmN3ZCA9IGF3YWl0IEZpbGVTeXN0ZW1TZXJ2aWNlLnJlc29sdmVSZWFsUGF0aCh0aGlzLl9jb25maWcuY3dkKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGZ1dHVyZSB1c2FnZS5cbiAgICAgIHNldENvbm5lY3Rpb25Db25maWcodGhpcy5fY29uZmlnKTtcblxuICAgICAgdGhpcy5fbW9uaXRvckNvbm5lY3Rpb25IZWFydGJlYXQoKTtcblxuICAgICAgLy8gQSB3b3JrYXJvdW5kIGJlZm9yZSBBdG9tIDIuMDogc2VlIDo6Z2V0SGdSZXBvSW5mby5cbiAgICAgIGF3YWl0IHRoaXMuX3NldEhnUmVwb0luZm8oKTtcblxuICAgICAgLy8gUmVnaXN0ZXIgTnVjbGlkZVVyaSB0eXBlIGNvbnZlcnNpb25zLlxuICAgICAgY2xpZW50LnJlZ2lzdGVyVHlwZSgnTnVjbGlkZVVyaScsXG4gICAgICAgIHVyaSA9PiB0aGlzLmdldFBhdGhPZlVyaSh1cmkpLCBwYXRoID0+IHRoaXMuZ2V0VXJpT2ZSZW1vdGVQYXRoKHBhdGgpKTtcblxuICAgICAgLy8gU2F2ZSB0byBjYWNoZS5cbiAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb24oKTtcbiAgICAgIHRoaXMuX3dhdGNoUm9vdFByb2plY3REaXJlY3RvcnkoKTtcbiAgICB9XG4gIH1cblxuICBfYWRkQ29ubmVjdGlvbigpIHtcbiAgICBfY29ubmVjdGlvbnMucHVzaCh0aGlzKTtcbiAgICBfZW1pdHRlci5lbWl0KCdkaWQtYWRkJywgdGhpcyk7XG4gIH1cblxuICBfd2F0Y2hSb290UHJvamVjdERpcmVjdG9yeSgpOiB2b2lkIHtcbiAgICAvLyBUT0RPKHBldGVyaGFsKTogbW92ZSBzaW5nbGV0b24gZnJvbSBtYWluLmpzIHRvIGNsaWVudC5qc1xuICAgIGNvbnN0IHtnZXRTZXJ2aWNlQnlOdWNsaWRlVXJpfSA9IHJlcXVpcmUoJy4vc2VydmljZS1tYW5hZ2VyJyk7XG4gICAgY29uc3Qgcm9vdERpcmVjdG9yeVVyaSA9IHRoaXMuZ2V0VXJpRm9ySW5pdGlhbFdvcmtpbmdEaXJlY3RvcnkoKTtcbiAgICBjb25zdCB7d2F0Y2hEaXJlY3RvcnlSZWN1cnNpdmV9ID0gZ2V0U2VydmljZUJ5TnVjbGlkZVVyaShcbiAgICAgICdGaWxlV2F0Y2hlclNlcnZpY2UnLCByb290RGlyZWN0b3J5VXJpXG4gICAgKTtcbiAgICAvLyBTdGFydCB3YXRjaGluZyB0aGUgcHJvamVjdCBmb3IgY2hhbmdlcyBhbmQgaW5pdGlhbGl6ZSB0aGUgcm9vdCB3YXRjaGVyXG4gICAgLy8gZm9yIG5leHQgY2FsbHMgdG8gYHdhdGNoRmlsZWAgYW5kIGB3YXRjaERpcmVjdG9yeWAuXG4gICAgY29uc3Qgd2F0Y2hTdHJlYW0gPSB3YXRjaERpcmVjdG9yeVJlY3Vyc2l2ZShyb290RGlyZWN0b3J5VXJpKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB3YXRjaFN0cmVhbS5zdWJzY3JpYmUod2F0Y2hVcGRhdGUgPT4ge1xuICAgICAgLy8gTm90aGluZyBuZWVkcyB0byBiZSBkb25lIGlmIHRoZSByb290IGRpcmVjdG9yeSB3YXMgd2F0Y2hlZCBjb3JyZWN0bHkuXG4gICAgICAvLyBMZXQncyBqdXN0IGNvbnNvbGUgbG9nIGl0IGFueXdheS5cbiAgICAgIGxvZ2dlci5pbmZvKGBXYXRjaGVyIEZlYXR1cmVzIEluaXRpYWxpemVkIGZvciBwcm9qZWN0OiAke3Jvb3REaXJlY3RvcnlVcml9YCwgd2F0Y2hVcGRhdGUpO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGxldCB3YXJuaW5nTWVzc2FnZVRvVXNlciA9IGBZb3UganVzdCBjb25uZWN0ZWQgdG8gYSByZW1vdGUgcHJvamVjdCBgICtcbiAgICAgICAgYCgke3Jvb3REaXJlY3RvcnlVcml9KSwgYnV0IHdlIHJlY29tbWVuZCB5b3UgcmVtb3ZlIHRoaXMgZGlyZWN0b3J5IG5vdyFgICtcbiAgICAgICAgYDxici8+PGJyLz4gVGhlIGRpcmVjdG9yeSB5b3UgY29ubmVjdGVkIHRvIGNvdWxkIG5vdCBiZSB3YXRjaGVkIGJ5IHdhdGNobWFuLCBgICtcbiAgICAgICAgYHNvIGNydWNpYWwgZmVhdHVyZXMgbGlrZSBzeW5jZWQgcmVtb3RlIGZpbGUgZWRpdGluZywgZmlsZSBzZWFyY2gsIGAgK1xuICAgICAgICBgYW5kIE1lcmN1cmlhbC1yZWxhdGVkIHVwZGF0ZXMgd2lsbCBub3Qgd29yay5gO1xuICAgICAgY29uc3QgbG9nZ2VkRXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCBlcnJvcjtcbiAgICAgIGlmIChsb2dnZWRFcnJvck1lc3NhZ2UubWF0Y2goV0FUQ0hNQU5fRVJST1JfTUVTU0FHRV9GT1JfRU5GT1JDRV9ST09UX0ZJTEVTX1JFR0VYKSkge1xuICAgICAgICB3YXJuaW5nTWVzc2FnZVRvVXNlciArPSBgPGJyLz48YnIvPllvdSBuZWVkIHRvIGNvbm5lY3QgdG8gYSBkaWZmZXJlbnQgcm9vdCBkaXJlY3RvcnksIGAgK1xuICAgICAgICBgYmVjYXVzZSB0aGUgd2F0Y2htYW4gb24gdGhlIHNlcnZlciB5b3UgYXJlIGNvbm5lY3RpbmcgdG8gaXMgY29uZmlndXJlZCB0byBub3QgYWxsb3cgYCArXG4gICAgICAgIGB5b3UgdG8gd2F0Y2ggJHtyb290RGlyZWN0b3J5VXJpfS4gWW91IG1heSBoYXZlIGx1Y2sgY29ubmVjdGluZyB0byBhIGRlZXBlciBgICtcbiAgICAgICAgYGRpcmVjdG9yeSwgYmVjYXVzZSBvZnRlbiB3YXRjaG1hbiBpcyBjb25maWd1cmVkIHRvIG9ubHkgYWxsb3cgd2F0Y2hpbmcgYCArXG4gICAgICAgIGBjZXJ0YWluIHN1YmRpcmVjdG9yaWVzIChvZnRlbiByb290cyBvciBzdWJkaXJlY3RvcmllcyBvZiBzb3VyY2UgY29udHJvbCByZXBvc2l0b3JpZXMpLmA7XG4gICAgICB9XG4gICAgICAvLyBBZGQgYSBwZXJzaXN0ZW50IHdhcm5pbmcgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhlIHVzZXIgc2VlcyBpdCBiZWZvcmUgZGlzbWlzc2luZy5cbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRXYXJuaW5nKHdhcm5pbmdNZXNzYWdlVG9Vc2VyLCB7ZGlzbWlzc2FibGU6IHRydWV9KTtcbiAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICBgV2F0Y2hlciBmYWlsZWQgdG8gc3RhcnQgLSB3YXRjaGVyIGZlYXR1cmVzIGRpc2FibGVkISBFcnJvcjogJHtsb2dnZWRFcnJvck1lc3NhZ2V9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgLy8gTm90aGluZyBuZWVkcyB0byBiZSBkb25lIGlmIHRoZSByb290IGRpcmVjdG9yeSB3YXRjaCBoYXMgZW5kZWQuXG4gICAgICBsb2dnZXIuaW5mbyhgV2F0Y2hlciBGZWF0dXJlcyBFbmRlZCBmb3IgcHJvamVjdDogJHtyb290RGlyZWN0b3J5VXJpfWApO1xuICAgIH0pO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gIH1cblxuICBjbG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbG9zZSB0aGUgZXZlbnRidXMgdGhhdCB3aWxsIHN0b3AgdGhlIGhlYXJ0YmVhdCBpbnRlcnZhbCwgd2Vic29ja2V0IHJlY29ubmVjdCB0cmlhbHMsIC4uZXRjLlxuICAgIGlmICh0aGlzLl9jbGllbnQpIHtcbiAgICAgIHRoaXMuX2NsaWVudC5jbG9zZSgpO1xuICAgICAgdGhpcy5fY2xpZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIC8vIEZ1dHVyZSBnZXRDbGllbnQgY2FsbHMgc2hvdWxkIGZhaWwsIGlmIGl0IGhhcyBhIGNhY2hlZCBSZW1vdGVDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIF9jb25uZWN0aW9ucyB0byBub3QgYmUgY29uc2lkZXJlZCBpbiBmdXR1cmUgY29ubmVjdGlvbiBxdWVyaWVzLlxuICAgICAgX2Nvbm5lY3Rpb25zLnNwbGljZShfY29ubmVjdGlvbnMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICBfZW1pdHRlci5lbWl0KCdkaWQtY2xvc2UnLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBnZXRDbGllbnQoKTogTnVjbGlkZUNsaWVudCB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3RlIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2xpZW50KCk7XG4gICAgfVxuICB9XG5cbiAgX2dldENsaWVudCgpOiBOdWNsaWRlQ2xpZW50IHtcbiAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgbGV0IHVyaTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcblxuICAgICAgLy8gVXNlIGh0dHBzIGlmIHdlIGhhdmUga2V5LCBjZXJ0LCBhbmQgY2FcbiAgICAgIGlmICh0aGlzLl9pc1NlY3VyZSgpKSB7XG4gICAgICAgIG9wdGlvbnMuY2VydGlmaWNhdGVBdXRob3JpdHlDZXJ0aWZpY2F0ZSA9IHRoaXMuX2NvbmZpZy5jZXJ0aWZpY2F0ZUF1dGhvcml0eUNlcnRpZmljYXRlO1xuICAgICAgICBvcHRpb25zLmNsaWVudENlcnRpZmljYXRlID0gdGhpcy5fY29uZmlnLmNsaWVudENlcnRpZmljYXRlO1xuICAgICAgICBvcHRpb25zLmNsaWVudEtleSA9IHRoaXMuX2NvbmZpZy5jbGllbnRLZXk7XG4gICAgICAgIHVyaSA9IGBodHRwczovLyR7dGhpcy5nZXRSZW1vdGVIb3N0KCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGBodHRwOi8vJHt0aGlzLmdldFJlbW90ZUhvc3QoKX1gO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVtb3RlIGNvbm5lY3Rpb24gYW5kIGNsaWVudCBhcmUgaWRlbnRpZmllZCBieSBib3RoIHRoZSByZW1vdGUgaG9zdCBhbmQgdGhlIGluaXRhbCB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5nZXRSZW1vdGVIb3N0KCkgKyB0aGlzLmdldFBhdGhGb3JJbml0aWFsV29ya2luZ0RpcmVjdG9yeSgpO1xuICAgICAgdGhpcy5fY2xpZW50ID0gbmV3IE51Y2xpZGVDbGllbnQoY2xpZW50SWQsIG5ldyBOdWNsaWRlUmVtb3RlRXZlbnRidXModXJpLCBvcHRpb25zKSwge2N3ZDogdGhpcy5fY29uZmlnLmN3ZH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgcnBjIGNhbGwgdGhyb3VnaCB0aGlzIGNvbm5lY3Rpb24gZ2l2ZW4gc2VydmljZVVyaSBpbiBmb3JtIG9mIGAkc2VydmljZU5hbWUvJG1ldGhvZE5hbWVgXG4gICAqIGFuZCBhcmdzIGFzIGFyZ3VtZW50cyBsaXN0LlxuICAgKi9cbiAgbWFrZVJwYyhzZXJ2aWNlVXJpOiBzdHJpbmcsIGFyZ3M6IEFycmF5PGFueT4sIHNlcnZpY2VPcHRpb25zOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldENsaWVudCgpLm1ha2VScGMoc2VydmljZVVyaSwgYXJncywgc2VydmljZU9wdGlvbnMpO1xuICB9XG5cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVyKGV2ZW50TmFtZTogc3RyaW5nLCBjYWxsYmFjazogKHBheWxvYWQ6IGFueSkgPT4gdm9pZCwgc2VydmljZU9wdGlvbnM6IGFueSk6IERpc3Bvc2FibGUge1xuICAgIHJldHVybiB0aGlzLmdldENsaWVudCgpLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCBzZXJ2aWNlT3B0aW9ucyk7XG4gIH1cblxuXG4gIF9pc1NlY3VyZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgIHRoaXMuX2NvbmZpZy5jZXJ0aWZpY2F0ZUF1dGhvcml0eUNlcnRpZmljYXRlXG4gICAgICAgICYmIHRoaXMuX2NvbmZpZy5jbGllbnRDZXJ0aWZpY2F0ZVxuICAgICAgICAmJiB0aGlzLl9jb25maWcuY2xpZW50S2V5XG4gICAgKTtcbiAgfVxuXG4gIGdldFJlbW90ZUhvc3QoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fY29uZmlnLmhvc3R9OiR7dGhpcy5fY29uZmlnLnBvcnR9YDtcbiAgfVxuXG4gIGdldFJlbW90ZUhvc3RuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5ob3N0O1xuICB9XG5cbiAgZ2V0VXJpRm9ySW5pdGlhbFdvcmtpbmdEaXJlY3RvcnkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRVcmlPZlJlbW90ZVBhdGgodGhpcy5nZXRQYXRoRm9ySW5pdGlhbFdvcmtpbmdEaXJlY3RvcnkoKSk7XG4gIH1cblxuICBnZXRQYXRoRm9ySW5pdGlhbFdvcmtpbmdEaXJlY3RvcnkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmN3ZDtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBSZW1vdGVDb25uZWN0aW9uQ29uZmlndXJhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgfVxuXG4gIHN0YXRpYyBvbkRpZEFkZFJlbW90ZUNvbm5lY3Rpb24oaGFuZGxlcjogKGNvbm5lY3Rpb246IFJlbW90ZUNvbm5lY3Rpb24pID0+IHZvaWQpOiBEaXNwb3NhYmxlIHtcbiAgICBfZW1pdHRlci5vbignZGlkLWFkZCcsIGhhbmRsZXIpO1xuICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICBfZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZGlkLWFkZCcsIGhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIG9uRGlkQ2xvc2VSZW1vdGVDb25uZWN0aW9uKGhhbmRsZXI6IChjb25uZWN0aW9uOiBSZW1vdGVDb25uZWN0aW9uKSA9PiB2b2lkKTogRGlzcG9zYWJsZSB7XG4gICAgX2VtaXR0ZXIub24oJ2RpZC1jbG9zZScsIGhhbmRsZXIpO1xuICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICBfZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZGlkLWNsb3NlJywgaGFuZGxlcik7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0Rm9yVXJpKHVyaTogc3RyaW5nKTogP1JlbW90ZUNvbm5lY3Rpb24ge1xuICAgIGNvbnN0IHtob3N0bmFtZSwgcGF0aH0gPSByZW1vdGVVcmkucGFyc2UodXJpKTtcbiAgICByZXR1cm4gUmVtb3RlQ29ubmVjdGlvbi5nZXRCeUhvc3RuYW1lQW5kUGF0aChob3N0bmFtZSwgcGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNhY2hlZCBjb25uZWN0aW9uIG1hdGNoIHRoZSBob3N0bmFtZSBhbmQgdGhlIHBhdGggaGFzIHRoZSBwcmVmaXggb2YgY29ubmVjdGlvbi5jd2QuXG4gICAqIEBwYXJhbSBob3N0bmFtZSBUaGUgY29ubmVjdGVkIHNlcnZlciBob3N0IG5hbWUuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBhYnNvbHV0ZSBwYXRoIHRoYXQncyBoYXMgdGhlIHByZWZpeCBvZiBjd2Qgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAqICAgSWYgcGF0aCBpcyBudWxsLCBlbXB0eSBvciB1bmRlZmluZWQsIHRoZW4gcmV0dXJuIHRoZSBjb25uZWN0aW9uIHdoaWNoIG1hdGNoZXNcbiAgICogICB0aGUgaG9zdG5hbWUgYW5kIGlnbm9yZSB0aGUgaW5pdGlhbCB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICovXG4gIHN0YXRpYyBnZXRCeUhvc3RuYW1lQW5kUGF0aChob3N0bmFtZTogc3RyaW5nLCBwYXRoOiA/c3RyaW5nKTogP1JlbW90ZUNvbm5lY3Rpb24ge1xuICAgIHJldHVybiBfY29ubmVjdGlvbnMuZmlsdGVyKGNvbm5lY3Rpb24gPT4ge1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uZ2V0UmVtb3RlSG9zdG5hbWUoKSA9PT0gaG9zdG5hbWUgJiZcbiAgICAgICAgICAoIXBhdGggfHwgcGF0aC5zdGFydHNXaXRoKGNvbm5lY3Rpb24uZ2V0UGF0aEZvckluaXRpYWxXb3JraW5nRGlyZWN0b3J5KCkpKTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRCeUhvc3RuYW1lKGhvc3RuYW1lOiBzdHJpbmcpOiBBcnJheTxSZW1vdGVDb25uZWN0aW9uPiB7XG4gICAgcmV0dXJuIF9jb25uZWN0aW9ucy5maWx0ZXIoY29ubmVjdGlvbiA9PiBjb25uZWN0aW9uLmdldFJlbW90ZUhvc3RuYW1lKCkgPT09IGhvc3RuYW1lKTtcbiAgfVxuXG4gIC8vIFRPRE8ocGV0ZXJoYWwpOiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIG1vdmUgZnJvbSBzZXJ2aWNlLW1hbmFnZXIgdG8gaGVyZVxuICAvLyBob3dldmVyIHdlIHNob3VsZCB3YWl0IHVudGlsIHdlIHJlbW92ZSB0aGUgZXZlbnQtYnVzIGFuZCB2MiBycGMgZnJhbWV3b3JrXG4gIC8vIGJlZm9yZSBtYWtpbmcgdGhhdCBjaGFuZ2UuXG4gIGdldFNlcnZpY2Uoc2VydmljZU5hbWU6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3Qge2dldFJlbW90ZVNlcnZpY2VCeVJlbW90ZUNvbm5lY3Rpb259ID0gcmVxdWlyZSgnLi9zZXJ2aWNlLW1hbmFnZXInKTtcbiAgICByZXR1cm4gZ2V0UmVtb3RlU2VydmljZUJ5UmVtb3RlQ29ubmVjdGlvbihzZXJ2aWNlTmFtZSwgdGhpcyk7XG4gIH1cbn1cblxuLy8gRXhwb3NlIGxvY2FsIHZhcmlhYmxlcyBmb3IgdGVzdGFiaWxpdHkuXG5SZW1vdGVDb25uZWN0aW9uLnRlc3QgPSB7XG4gIGNvbm5lY3Rpb25zOiBfY29ubmVjdGlvbnMsXG4gIGdldFJlbG9hZEtleXN0cm9rZUxhYmVsLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVDb25uZWN0aW9uO1xuIl19
