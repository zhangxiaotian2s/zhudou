Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _utils = require('./utils');

var _Connection = require('./Connection');

var _ConnectionUtils = require('./ConnectionUtils');

var _DbgpSocket = require('./DbgpSocket');

var _events = require('events');

var _child_process = require('child_process');

var _ClientCallback = require('./ClientCallback');

'use babel';

var _require = require('./BreakpointStore');

var BreakpointStore = _require.BreakpointStore;

var _require2 = require('./DbgpConnector');

var DbgpConnector = _require2.DbgpConnector;

var CONNECTION_MUX_STATUS_EVENT = 'connection-mux-status';

// The ConnectionMultiplexer makes multiple debugger connections appear to be
// a single connection to the debugger UI.
//
// The initialization sequence occurs as follows:
//  - the constructor is called
//  - onStatus is called to hook up event handlers
//  - initial breakpoints may be added here.
//  - listen() is called indicating that all initial Breakpoints have been set
//    and debugging may commence.
//
// Once initialized, the ConnectionMultiplexer can be in one of 3 main states:
// running, break-disabled, and break-enabled.
//
// Running state means that all connections are in the running state.
// Note that running includes the state where there are no connections.
//
// Break-disabled state has at least one connection in break state.
// And none of the connections is enabled. Once in break-disabled state,
// the connection mux will immediately enable one of the broken connections
// and move to break-enabled state.
//
// Break-enabled state has a single connection which is in break-enabled
// state. There may be connections in break-disabled state and running state
// as well. The enabled connection will be shown in the debugger UI and all
// commands will go to the enabled connection.
//
// The ConnectionMultiplexer will close only if there are no connections
// and if the DbgpConnector is closed. The DbgpConnector will likely only
// close if HHVM crashes or is stopped.

var ConnectionMultiplexer = (function () {
  function ConnectionMultiplexer(config, clientCallback) {
    _classCallCheck(this, ConnectionMultiplexer);

    this._config = config;
    this._clientCallback = clientCallback;
    this._status = _DbgpSocket.STATUS_STARTING;
    this._emitter = new _events.EventEmitter();
    this._enabledConnection = null;
    this._dummyConnection = null;
    this._connections = new Map();
    this._connector = null;
    this._dummyRequestProcess = null;

    this._breakpointStore = new BreakpointStore();
  }

  _createClass(ConnectionMultiplexer, [{
    key: 'onStatus',
    value: function onStatus(callback) {
      return require('nuclide-commons').event.attachEvent(this._emitter, CONNECTION_MUX_STATUS_EVENT, callback);
    }
  }, {
    key: 'listen',
    value: function listen() {
      var connector = new DbgpConnector(this._config);
      connector.onAttach(this._onAttach.bind(this));
      connector.onClose(this._disposeConnector.bind(this));
      connector.onError(this._handleAttachError.bind(this));
      this._connector = connector;
      this._status = _DbgpSocket.STATUS_RUNNING;

      connector.listen();

      this._clientCallback.sendUserMessage('console', {
        level: 'warning',
        text: 'Pre-loading, please wait...'
      });
      this._dummyRequestProcess = (0, _ConnectionUtils.sendDummyRequest)();
    }
  }, {
    key: '_handleDummyConnection',
    value: _asyncToGenerator(function* (socket) {
      (0, _utils.log)('ConnectionMultiplexer successfully got dummy connection.');
      var dummyConnection = new _Connection.Connection(socket);
      // Continue from loader breakpoint to hit xdebug_break()
      // which will load whole www repo for evaluation if possible.
      yield dummyConnection.sendContinuationCommand(_DbgpSocket.COMMAND_RUN);
      this._dummyConnection = dummyConnection;

      this._clientCallback.sendUserMessage('console', {
        level: 'warning',
        text: 'Pre-loading is done. You can use console window now.'
      });
    })

    // For testing purpose.
  }, {
    key: 'getDummyConnection',
    value: function getDummyConnection() {
      return this._dummyConnection;
    }
  }, {
    key: '_onAttach',
    value: _asyncToGenerator(function* (params) {
      var _this = this;

      var socket = params.socket;
      var message = params.message;

      if (!(0, _ConnectionUtils.isCorrectConnection)(this._config, message)) {
        (0, _ConnectionUtils.failConnection)(socket, 'Discarding connection ' + JSON.stringify(message));
        return;
      }

      if ((0, _ConnectionUtils.isDummyConnection)(message)) {
        this._handleDummyConnection(socket);
      } else {
        yield* (function* () {
          var connection = new _Connection.Connection(socket);
          _this._breakpointStore.addConnection(connection);

          var info = {
            connection: connection,
            onStatusDisposable: connection.onStatus(function (status) {
              _this._connectionOnStatus(connection, status);
            }),
            status: _DbgpSocket.STATUS_STARTING
          };
          _this._connections.set(connection, info);

          var status = undefined;
          try {
            status = yield connection.getStatus();
          } catch (e) {
            (0, _utils.logError)('Error getting initial connection status: ' + e.message);
            status = _DbgpSocket.STATUS_ERROR;
          }
          _this._connectionOnStatus(connection, status);
        })();
      }
    })
  }, {
    key: '_connectionOnStatus',
    value: function _connectionOnStatus(connection, status) {
      (0, _utils.log)('Mux got status: ' + status + ' on connection ' + connection.getId());
      this._connections.get(connection).status = status;

      switch (status) {
        case _DbgpSocket.STATUS_STARTING:
          // Starting status has no stack.
          // step before reporting initial status to get to the first instruction.
          // TODO: Use loader breakpoint configuration to choose between step/run.
          connection.sendContinuationCommand(_DbgpSocket.COMMAND_RUN);
          return;
        case _DbgpSocket.STATUS_STOPPING:
          // TODO: May want to enable post-mortem features?
          connection.sendContinuationCommand(_DbgpSocket.COMMAND_RUN);
          return;
        case _DbgpSocket.STATUS_RUNNING:
          if (connection === this._enabledConnection) {
            this._disableConnection();
          }
          break;
        case _DbgpSocket.STATUS_BREAK:
          if (connection === this._enabledConnection) {
            // This can happen when we step.
            (0, _utils.log)('Mux break on enabled connection');
            this._emitStatus(_DbgpSocket.STATUS_BREAK);
            return;
          }
          break;
        case _DbgpSocket.STATUS_STOPPED:
        case _DbgpSocket.STATUS_ERROR:
        case _DbgpSocket.STATUS_END:
          this._removeConnection(connection);
          break;
      }

      this._updateStatus();
    }
  }, {
    key: '_updateStatus',
    value: function _updateStatus() {
      if (this._status === _DbgpSocket.STATUS_END) {
        return;
      }

      if (this._status === _DbgpSocket.STATUS_BREAK) {
        (0, _utils.log)('Mux already in break status');
        return;
      }

      // now check if we can move from running to break...
      for (var connectionInfo of this._connections.values()) {
        if (connectionInfo.status === _DbgpSocket.STATUS_BREAK) {
          this._enableConnection(connectionInfo.connection);
          break;
        }
      }
    }
  }, {
    key: '_enableConnection',
    value: function _enableConnection(connection) {
      (0, _utils.log)('Mux enabling connection');
      this._enabledConnection = connection;
      this._setStatus(_DbgpSocket.STATUS_BREAK);
    }
  }, {
    key: '_setStatus',
    value: function _setStatus(status) {
      if (status !== this._status) {
        this._status = status;
        this._emitStatus(status);
      }
    }
  }, {
    key: '_handleAttachError',
    value: function _handleAttachError(error) {
      this._clientCallback.sendUserMessage('notification', {
        type: 'error',
        message: error
      });
    }
  }, {
    key: '_emitStatus',
    value: function _emitStatus(status) {
      this._emitter.emit(CONNECTION_MUX_STATUS_EVENT, status);
    }
  }, {
    key: 'runtimeEvaluate',
    value: _asyncToGenerator(function* (expression) {
      (0, _utils.log)('runtimeEvaluate() on dummy connection for: ' + expression);
      if (this._dummyConnection) {
        // Global runtime evaluation on dummy connection does not care about
        // which frame it is being evaluated on so choose top frame here.
        var result = yield this._dummyConnection.evaluateOnCallFrame(0, expression);
        this._reportEvaluationFailureIfNeeded(expression, result);
        return result;
      } else {
        throw this._noConnectionError();
      }
    })
  }, {
    key: 'evaluateOnCallFrame',
    value: _asyncToGenerator(function* (frameIndex, expression) {
      if (this._enabledConnection) {
        var result = yield this._enabledConnection.evaluateOnCallFrame(frameIndex, expression);
        this._reportEvaluationFailureIfNeeded(expression, result);
        return result;
      } else {
        throw this._noConnectionError();
      }
    })
  }, {
    key: '_reportEvaluationFailureIfNeeded',
    value: function _reportEvaluationFailureIfNeeded(expression, result) {
      if (result.wasThrown) {
        var _message = 'Failed to evaluate "' + expression + '": (' + result.error.$.code + ') ' + result.error.message[0];
        this._clientCallback.sendUserMessage('console', {
          level: 'error',
          text: _message
        });
      }
    }
  }, {
    key: 'setPauseOnExceptions',
    value: function setPauseOnExceptions(state) {
      return this._breakpointStore.setPauseOnExceptions(state);
    }
  }, {
    key: 'setBreakpoint',
    value: function setBreakpoint(filename, lineNumber) {
      return this._breakpointStore.setBreakpoint(filename, lineNumber);
    }
  }, {
    key: 'removeBreakpoint',
    value: function removeBreakpoint(breakpointId) {
      return this._breakpointStore.removeBreakpoint(breakpointId);
    }
  }, {
    key: 'getStackFrames',
    value: function getStackFrames() {
      if (this._enabledConnection) {
        return this._enabledConnection.getStackFrames();
      } else {
        // This occurs on startup with the loader breakpoint.
        return Promise.resolve({ stack: [] });
      }
    }
  }, {
    key: 'getScopesForFrame',
    value: function getScopesForFrame(frameIndex) {
      if (this._enabledConnection) {
        return this._enabledConnection.getScopesForFrame(frameIndex);
      } else {
        throw this._noConnectionError();
      }
    }
  }, {
    key: 'getStatus',
    value: function getStatus() {
      return this._status;
    }
  }, {
    key: 'sendContinuationCommand',
    value: function sendContinuationCommand(command) {
      if (this._enabledConnection) {
        this._enabledConnection.sendContinuationCommand(command);
      } else {
        throw this._noConnectionError();
      }
    }
  }, {
    key: 'sendBreakCommand',
    value: function sendBreakCommand() {
      if (this._enabledConnection) {
        return this._enabledConnection.sendBreakCommand();
      } else {
        return Promise.resolve(false);
      }
    }
  }, {
    key: 'getProperties',
    value: function getProperties(remoteId) {
      if (this._enabledConnection && this._status === _DbgpSocket.STATUS_BREAK) {
        return this._enabledConnection.getProperties(remoteId);
      } else if (this._dummyConnection) {
        return this._dummyConnection.getProperties(remoteId);
      } else {
        throw this._noConnectionError();
      }
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      for (var _connection of this._connections.keys()) {
        this._removeConnection(_connection);
      }
      if (this._dummyRequestProcess) {
        this._dummyRequestProcess.kill('SIGKILL');
      }
      this._disposeConnector();
    }
  }, {
    key: '_removeConnection',
    value: function _removeConnection(connection) {
      var info = this._connections.get(connection);
      info.onStatusDisposable.dispose();
      connection.dispose();
      this._connections['delete'](connection);

      if (connection === this._enabledConnection) {
        this._disableConnection();
      }
      this._checkForEnd();
    }
  }, {
    key: '_disableConnection',
    value: function _disableConnection() {
      (0, _utils.log)('Mux disabling connection');
      this._enabledConnection = null;
      this._setStatus(_DbgpSocket.STATUS_RUNNING);
    }
  }, {
    key: '_disposeConnector',
    value: function _disposeConnector() {
      // Avoid recursion with connector's onClose event.
      var connector = this._connector;
      if (connector) {
        this._connector = null;
        connector.dispose();
      }
      this._checkForEnd();
    }
  }, {
    key: '_checkForEnd',
    value: function _checkForEnd() {
      if (this._connections.size === 0 && (!this._connector || this._config.endDebugWhenNoRequests)) {
        this._setStatus(_DbgpSocket.STATUS_END);
      }
    }
  }, {
    key: '_noConnectionError',
    value: function _noConnectionError() {
      // This is an indication of a bug in the state machine.
      // .. we are seeing a request in a state that should not generate
      // that request.
      return new Error('No connection');
    }
  }]);

  return ConnectionMultiplexer;
})();

exports.ConnectionMultiplexer = ConnectionMultiplexer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWRlYnVnZ2VyLWhodm0tcHJveHkvbGliL0Nvbm5lY3Rpb25NdWx0aXBsZXhlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBVzRCLFNBQVM7OzBCQUNaLGNBQWM7OytCQU1oQyxtQkFBbUI7OzBCQW9CbkIsY0FBYzs7c0JBQ00sUUFBUTs7NkJBQ1IsZUFBZTs7OEJBQ2Isa0JBQWtCOztBQXpDL0MsV0FBVyxDQUFDOztlQTBCYyxPQUFPLENBQUMsbUJBQW1CLENBQUM7O0lBQS9DLGVBQWUsWUFBZixlQUFlOztnQkFDRSxPQUFPLENBQUMsaUJBQWlCLENBQUM7O0lBQTNDLGFBQWEsYUFBYixhQUFhOztBQWlCcEIsSUFBTSwyQkFBMkIsR0FBRyx1QkFBdUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpRC9DLHFCQUFxQjtBQVlyQixXQVpBLHFCQUFxQixDQVlwQixNQUF3QixFQUFFLGNBQThCLEVBQUU7MEJBWjNELHFCQUFxQjs7QUFhOUIsUUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdEIsUUFBSSxDQUFDLGVBQWUsR0FBRyxjQUFjLENBQUM7QUFDdEMsUUFBSSxDQUFDLE9BQU8sZUE5RWQsZUFBZSxBQThFaUIsQ0FBQztBQUMvQixRQUFJLENBQUMsUUFBUSxHQUFHLFlBdEVaLFlBQVksRUFzRWtCLENBQUM7QUFDbkMsUUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztBQUMvQixRQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO0FBQzdCLFFBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUM5QixRQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztBQUN2QixRQUFJLENBQUMsb0JB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QUFBQyxFQUFFO0FBQzVELFlBQUksQ0FBQyxVQUFVLGFBcFhuQixVQUFVLENBb1hxQixDQUFDO09BQzdCO0tBQ0Y7OztXQUVpQiw4QkFBVTs7OztBQUkxQixhQUFPLElBQUksS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ25DOzs7U0FwVVUscUJBQXFCIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWRlYnVnZ2VyLWhodm0tcHJveHkvbGliL0Nvbm5lY3Rpb25NdWx0aXBsZXhlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7bG9nLCBsb2dFcnJvcn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge0Nvbm5lY3Rpb259IGZyb20gJy4vQ29ubmVjdGlvbic7XG5pbXBvcnQge1xuICBpc0R1bW15Q29ubmVjdGlvbixcbiAgc2VuZER1bW15UmVxdWVzdCxcbiAgaXNDb3JyZWN0Q29ubmVjdGlvbixcbiAgZmFpbENvbm5lY3Rpb24sXG59IGZyb20gJy4vQ29ubmVjdGlvblV0aWxzJztcblxuaW1wb3J0IHR5cGUge1NvY2tldH0gZnJvbSAnbmV0JztcbmltcG9ydCB0eXBlIFNjb3BlIGZyb20gJy4vRGF0YUNhY2hlJztcbmltcG9ydCB0eXBlIFByb3BlcnR5RGVzY3JpcHRvciBmcm9tICcuL0RhdGFDYWNoZSc7XG5pbXBvcnQgdHlwZSBSZW1vdGVPYmplY3RJZCBmcm9tICcuL0RhdGFDYWNoZSc7XG5pbXBvcnQgdHlwZSB7RGlzcG9zYWJsZX0gZnJvbSAnbnVjbGlkZS1jb21tb25zJztcbmltcG9ydCB0eXBlIHtFeGNlcHRpb25TdGF0ZX0gZnJvbSAnLi9CcmVha3BvaW50U3RvcmUnO1xuY29uc3Qge0JyZWFrcG9pbnRTdG9yZX0gPSByZXF1aXJlKCcuL0JyZWFrcG9pbnRTdG9yZScpO1xuY29uc3Qge0RiZ3BDb25uZWN0b3J9ID0gcmVxdWlyZSgnLi9EYmdwQ29ubmVjdG9yJyk7XG5pbXBvcnQgdHlwZSB7Q29ubmVjdGlvbkNvbmZpZ30gZnJvbSAnLi9EYmdwQ29ubmVjdG9yJztcbmltcG9ydCB7XG4gIFNUQVRVU19TVEFSVElORyxcbiAgU1RBVFVTX1NUT1BQSU5HLFxuICBTVEFUVVNfU1RPUFBFRCxcbiAgU1RBVFVTX1JVTk5JTkcsXG4gIFNUQVRVU19CUkVBSyxcbiAgU1RBVFVTX0VSUk9SLFxuICBTVEFUVVNfRU5ELFxuICBDT01NQU5EX1JVTixcbn0gZnJvbSAnLi9EYmdwU29ja2V0JztcbmltcG9ydCB7RXZlbnRFbWl0dGVyfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtDaGlsZFByb2Nlc3N9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHtDbGllbnRDYWxsYmFja30gZnJvbSAnLi9DbGllbnRDYWxsYmFjayc7XG5cblxuY29uc3QgQ09OTkVDVElPTl9NVVhfU1RBVFVTX0VWRU5UID0gJ2Nvbm5lY3Rpb24tbXV4LXN0YXR1cyc7XG5cbnR5cGUgQ29ubmVjdGlvbkluZm8gPSB7XG4gIGNvbm5lY3Rpb246IENvbm5lY3Rpb247XG4gIG9uU3RhdHVzRGlzcG9zYWJsZTogRGlzcG9zYWJsZTtcbiAgc3RhdHVzOiBzdHJpbmc7XG59O1xuXG50eXBlIERiZ3BFcnJvciA9IHtcbiAgJDoge1xuICAgIGNvZGU6IG51bWJlcixcbiAgfTtcbiAgbWVzc2FnZTogQXJyYXk8c3RyaW5nPjtcbn07XG5cbnR5cGUgRXZhbHVhdGlvbkZhaWx1cmVSZXN1bHQgPSB7XG4gIGVycm9yOiBEYmdwRXJyb3I7XG4gIHdhc1Rocm93bjogYm9vbGVhbjtcbn07XG5cbi8vIFRoZSBDb25uZWN0aW9uTXVsdGlwbGV4ZXIgbWFrZXMgbXVsdGlwbGUgZGVidWdnZXIgY29ubmVjdGlvbnMgYXBwZWFyIHRvIGJlXG4vLyBhIHNpbmdsZSBjb25uZWN0aW9uIHRvIHRoZSBkZWJ1Z2dlciBVSS5cbi8vXG4vLyBUaGUgaW5pdGlhbGl6YXRpb24gc2VxdWVuY2Ugb2NjdXJzIGFzIGZvbGxvd3M6XG4vLyAgLSB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkXG4vLyAgLSBvblN0YXR1cyBpcyBjYWxsZWQgdG8gaG9vayB1cCBldmVudCBoYW5kbGVyc1xuLy8gIC0gaW5pdGlhbCBicmVha3BvaW50cyBtYXkgYmUgYWRkZWQgaGVyZS5cbi8vICAtIGxpc3RlbigpIGlzIGNhbGxlZCBpbmRpY2F0aW5nIHRoYXQgYWxsIGluaXRpYWwgQnJlYWtwb2ludHMgaGF2ZSBiZWVuIHNldFxuLy8gICAgYW5kIGRlYnVnZ2luZyBtYXkgY29tbWVuY2UuXG4vL1xuLy8gT25jZSBpbml0aWFsaXplZCwgdGhlIENvbm5lY3Rpb25NdWx0aXBsZXhlciBjYW4gYmUgaW4gb25lIG9mIDMgbWFpbiBzdGF0ZXM6XG4vLyBydW5uaW5nLCBicmVhay1kaXNhYmxlZCwgYW5kIGJyZWFrLWVuYWJsZWQuXG4vL1xuLy8gUnVubmluZyBzdGF0ZSBtZWFucyB0aGF0IGFsbCBjb25uZWN0aW9ucyBhcmUgaW4gdGhlIHJ1bm5pbmcgc3RhdGUuXG4vLyBOb3RlIHRoYXQgcnVubmluZyBpbmNsdWRlcyB0aGUgc3RhdGUgd2hlcmUgdGhlcmUgYXJlIG5vIGNvbm5lY3Rpb25zLlxuLy9cbi8vIEJyZWFrLWRpc2FibGVkIHN0YXRlIGhhcyBhdCBsZWFzdCBvbmUgY29ubmVjdGlvbiBpbiBicmVhayBzdGF0ZS5cbi8vIEFuZCBub25lIG9mIHRoZSBjb25uZWN0aW9ucyBpcyBlbmFibGVkLiBPbmNlIGluIGJyZWFrLWRpc2FibGVkIHN0YXRlLFxuLy8gdGhlIGNvbm5lY3Rpb24gbXV4IHdpbGwgaW1tZWRpYXRlbHkgZW5hYmxlIG9uZSBvZiB0aGUgYnJva2VuIGNvbm5lY3Rpb25zXG4vLyBhbmQgbW92ZSB0byBicmVhay1lbmFibGVkIHN0YXRlLlxuLy9cbi8vIEJyZWFrLWVuYWJsZWQgc3RhdGUgaGFzIGEgc2luZ2xlIGNvbm5lY3Rpb24gd2hpY2ggaXMgaW4gYnJlYWstZW5hYmxlZFxuLy8gc3RhdGUuIFRoZXJlIG1heSBiZSBjb25uZWN0aW9ucyBpbiBicmVhay1kaXNhYmxlZCBzdGF0ZSBhbmQgcnVubmluZyBzdGF0ZVxuLy8gYXMgd2VsbC4gVGhlIGVuYWJsZWQgY29ubmVjdGlvbiB3aWxsIGJlIHNob3duIGluIHRoZSBkZWJ1Z2dlciBVSSBhbmQgYWxsXG4vLyBjb21tYW5kcyB3aWxsIGdvIHRvIHRoZSBlbmFibGVkIGNvbm5lY3Rpb24uXG4vL1xuLy8gVGhlIENvbm5lY3Rpb25NdWx0aXBsZXhlciB3aWxsIGNsb3NlIG9ubHkgaWYgdGhlcmUgYXJlIG5vIGNvbm5lY3Rpb25zXG4vLyBhbmQgaWYgdGhlIERiZ3BDb25uZWN0b3IgaXMgY2xvc2VkLiBUaGUgRGJncENvbm5lY3RvciB3aWxsIGxpa2VseSBvbmx5XG4vLyBjbG9zZSBpZiBISFZNIGNyYXNoZXMgb3IgaXMgc3RvcHBlZC5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uTXVsdGlwbGV4ZXIge1xuICBfY29uZmlnOiBDb25uZWN0aW9uQ29uZmlnO1xuICBfY2xpZW50Q2FsbGJhY2s6IENsaWVudENhbGxiYWNrO1xuICBfYnJlYWtwb2ludFN0b3JlOiBCcmVha3BvaW50U3RvcmU7XG4gIF9lbWl0dGVyOiBFdmVudEVtaXR0ZXI7XG4gIF9zdGF0dXM6IHN0cmluZztcbiAgX2VuYWJsZWRDb25uZWN0aW9uOiA/Q29ubmVjdGlvbjtcbiAgX2R1bW15Q29ubmVjdGlvbjogP0Nvbm5lY3Rpb247XG4gIF9jb25uZWN0aW9uczogTWFwPENvbm5lY3Rpb24sIENvbm5lY3Rpb25JbmZvPjtcbiAgX2Nvbm5lY3RvcjogP0RiZ3BDb25uZWN0b3I7XG4gIF9kdW1teVJlcXVlc3RQcm9jZXNzOiA/Q2hpbGRQcm9jZXNzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZywgY2xpZW50Q2FsbGJhY2s6IENsaWVudENhbGxiYWNrKSB7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX2NsaWVudENhbGxiYWNrID0gY2xpZW50Q2FsbGJhY2s7XG4gICAgdGhpcy5fc3RhdHVzID0gU1RBVFVTX1NUQVJUSU5HO1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5fZW5hYmxlZENvbm5lY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuX2R1bW15Q29ubmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY29ubmVjdG9yID0gbnVsbDtcbiAgICB0aGlzLl9kdW1teVJlcXVlc3RQcm9jZXNzID0gbnVsbDtcblxuICAgIHRoaXMuX2JyZWFrcG9pbnRTdG9yZSA9IG5ldyBCcmVha3BvaW50U3RvcmUoKTtcbiAgfVxuXG4gIG9uU3RhdHVzKGNhbGxiYWNrOiAoc3RhdHVzOiBzdHJpbmcpID0+IG1peGVkKTogRGlzcG9zYWJsZSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpLmV2ZW50LmF0dGFjaEV2ZW50KHRoaXMuX2VtaXR0ZXIsXG4gICAgICBDT05ORUNUSU9OX01VWF9TVEFUVVNfRVZFTlQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGxpc3RlbigpOiB2b2lkIHtcbiAgICBjb25zdCBjb25uZWN0b3IgPSBuZXcgRGJncENvbm5lY3Rvcih0aGlzLl9jb25maWcpO1xuICAgIGNvbm5lY3Rvci5vbkF0dGFjaCh0aGlzLl9vbkF0dGFjaC5iaW5kKHRoaXMpKTtcbiAgICBjb25uZWN0b3Iub25DbG9zZSh0aGlzLl9kaXNwb3NlQ29ubmVjdG9yLmJpbmQodGhpcykpO1xuICAgIGNvbm5lY3Rvci5vbkVycm9yKHRoaXMuX2hhbmRsZUF0dGFjaEVycm9yLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2Nvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICB0aGlzLl9zdGF0dXMgPSBTVEFUVVNfUlVOTklORztcblxuICAgIGNvbm5lY3Rvci5saXN0ZW4oKTtcblxuICAgIHRoaXMuX2NsaWVudENhbGxiYWNrLnNlbmRVc2VyTWVzc2FnZSgnY29uc29sZScsIHtcbiAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICB0ZXh0OiAnUHJlLWxvYWRpbmcsIHBsZWFzZSB3YWl0Li4uJyxcbiAgICB9KTtcbiAgICB0aGlzLl9kdW1teVJlcXVlc3RQcm9jZXNzID0gc2VuZER1bW15UmVxdWVzdCgpO1xuICB9XG5cbiAgYXN5bmMgX2hhbmRsZUR1bW15Q29ubmVjdGlvbihzb2NrZXQ6IFNvY2tldCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZygnQ29ubmVjdGlvbk11bHRpcGxleGVyIHN1Y2Nlc3NmdWxseSBnb3QgZHVtbXkgY29ubmVjdGlvbi4nKTtcbiAgICBjb25zdCBkdW1teUNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihzb2NrZXQpO1xuICAgIC8vIENvbnRpbnVlIGZyb20gbG9hZGVyIGJyZWFrcG9pbnQgdG8gaGl0IHhkZWJ1Z19icmVhaygpXG4gICAgLy8gd2hpY2ggd2lsbCBsb2FkIHdob2xlIHd3dyByZXBvIGZvciBldmFsdWF0aW9uIGlmIHBvc3NpYmxlLlxuICAgIGF3YWl0IGR1bW15Q29ubmVjdGlvbi5zZW5kQ29udGludWF0aW9uQ29tbWFuZChDT01NQU5EX1JVTik7XG4gICAgdGhpcy5fZHVtbXlDb25uZWN0aW9uID0gZHVtbXlDb25uZWN0aW9uO1xuXG4gICAgdGhpcy5fY2xpZW50Q2FsbGJhY2suc2VuZFVzZXJNZXNzYWdlKCdjb25zb2xlJywge1xuICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgIHRleHQ6ICdQcmUtbG9hZGluZyBpcyBkb25lLiBZb3UgY2FuIHVzZSBjb25zb2xlIHdpbmRvdyBub3cuJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZvciB0ZXN0aW5nIHB1cnBvc2UuXG4gIGdldER1bW15Q29ubmVjdGlvbigpOiA/Q29ubmVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2R1bW15Q29ubmVjdGlvbjtcbiAgfVxuXG4gIGFzeW5jIF9vbkF0dGFjaChwYXJhbXM6IHtzb2NrZXQ6IFNvY2tldCwgbWVzc2FnZTogT2JqZWN0fSk6IFByb21pc2Uge1xuICAgIGNvbnN0IHtzb2NrZXQsIG1lc3NhZ2V9ID0gcGFyYW1zO1xuICAgIGlmICghaXNDb3JyZWN0Q29ubmVjdGlvbih0aGlzLl9jb25maWcsIG1lc3NhZ2UpKSB7XG4gICAgICBmYWlsQ29ubmVjdGlvbihzb2NrZXQsICdEaXNjYXJkaW5nIGNvbm5lY3Rpb24gJyArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNEdW1teUNvbm5lY3Rpb24obWVzc2FnZSkpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUR1bW15Q29ubmVjdGlvbihzb2NrZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oc29ja2V0KTtcbiAgICAgIHRoaXMuX2JyZWFrcG9pbnRTdG9yZS5hZGRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuXG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICBvblN0YXR1c0Rpc3Bvc2FibGU6IGNvbm5lY3Rpb24ub25TdGF0dXMoc3RhdHVzID0+IHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uT25TdGF0dXMoY29ubmVjdGlvbiwgc3RhdHVzKTtcbiAgICAgICAgfSksXG4gICAgICAgIHN0YXR1czogU1RBVFVTX1NUQVJUSU5HLFxuICAgICAgfTtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zLnNldChjb25uZWN0aW9uLCBpbmZvKTtcblxuICAgICAgbGV0IHN0YXR1cztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXR1cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0U3RhdHVzKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ0Vycm9yKCdFcnJvciBnZXR0aW5nIGluaXRpYWwgY29ubmVjdGlvbiBzdGF0dXM6ICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICBzdGF0dXMgPSBTVEFUVVNfRVJST1I7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0aW9uT25TdGF0dXMoY29ubmVjdGlvbiwgc3RhdHVzKTtcbiAgICB9XG4gIH1cblxuICBfY29ubmVjdGlvbk9uU3RhdHVzKGNvbm5lY3Rpb246IENvbm5lY3Rpb24sIHN0YXR1czogc3RyaW5nKTogdm9pZCB7XG4gICAgbG9nKGBNdXggZ290IHN0YXR1czogJHtzdGF0dXN9IG9uIGNvbm5lY3Rpb24gJHtjb25uZWN0aW9uLmdldElkKCl9YCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuZ2V0KGNvbm5lY3Rpb24pLnN0YXR1cyA9IHN0YXR1cztcblxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFNUQVRVU19TVEFSVElORzpcbiAgICAgICAgLy8gU3RhcnRpbmcgc3RhdHVzIGhhcyBubyBzdGFjay5cbiAgICAgICAgLy8gc3RlcCBiZWZvcmUgcmVwb3J0aW5nIGluaXRpYWwgc3RhdHVzIHRvIGdldCB0byB0aGUgZmlyc3QgaW5zdHJ1Y3Rpb24uXG4gICAgICAgIC8vIFRPRE86IFVzZSBsb2FkZXIgYnJlYWtwb2ludCBjb25maWd1cmF0aW9uIHRvIGNob29zZSBiZXR3ZWVuIHN0ZXAvcnVuLlxuICAgICAgICBjb25uZWN0aW9uLnNlbmRDb250aW51YXRpb25Db21tYW5kKENPTU1BTkRfUlVOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBTVEFUVVNfU1RPUFBJTkc6XG4gICAgICAgIC8vIFRPRE86IE1heSB3YW50IHRvIGVuYWJsZSBwb3N0LW1vcnRlbSBmZWF0dXJlcz9cbiAgICAgICAgY29ubmVjdGlvbi5zZW5kQ29udGludWF0aW9uQ29tbWFuZChDT01NQU5EX1JVTik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgU1RBVFVTX1JVTk5JTkc6XG4gICAgICAgIGlmIChjb25uZWN0aW9uID09PSB0aGlzLl9lbmFibGVkQ29ubmVjdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Rpc2FibGVDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUQVRVU19CUkVBSzpcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24gPT09IHRoaXMuX2VuYWJsZWRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2Ugc3RlcC5cbiAgICAgICAgICBsb2coJ011eCBicmVhayBvbiBlbmFibGVkIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICB0aGlzLl9lbWl0U3RhdHVzKFNUQVRVU19CUkVBSyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVEFUVVNfU1RPUFBFRDpcbiAgICAgIGNhc2UgU1RBVFVTX0VSUk9SOlxuICAgICAgY2FzZSBTVEFUVVNfRU5EOlxuICAgICAgICB0aGlzLl9yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTdGF0dXMoKTtcbiAgfVxuXG4gIF91cGRhdGVTdGF0dXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gU1RBVFVTX0VORCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IFNUQVRVU19CUkVBSykge1xuICAgICAgbG9nKCdNdXggYWxyZWFkeSBpbiBicmVhayBzdGF0dXMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgY2FuIG1vdmUgZnJvbSBydW5uaW5nIHRvIGJyZWFrLi4uXG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uSW5mbyBvZiB0aGlzLl9jb25uZWN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGNvbm5lY3Rpb25JbmZvLnN0YXR1cyA9PT0gU1RBVFVTX0JSRUFLKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZUNvbm5lY3Rpb24oY29ubmVjdGlvbkluZm8uY29ubmVjdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbmFibGVDb25uZWN0aW9uKGNvbm5lY3Rpb246IENvbm5lY3Rpb24pOiB2b2lkIHtcbiAgICBsb2coJ011eCBlbmFibGluZyBjb25uZWN0aW9uJyk7XG4gICAgdGhpcy5fZW5hYmxlZENvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuX3NldFN0YXR1cyhTVEFUVVNfQlJFQUspO1xuICB9XG5cbiAgX3NldFN0YXR1cyhzdGF0dXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChzdGF0dXMgIT09IHRoaXMuX3N0YXR1cykge1xuICAgICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzO1xuICAgICAgdGhpcy5fZW1pdFN0YXR1cyhzdGF0dXMpO1xuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVBdHRhY2hFcnJvcihlcnJvcjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fY2xpZW50Q2FsbGJhY2suc2VuZFVzZXJNZXNzYWdlKCdub3RpZmljYXRpb24nLCB7XG4gICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgbWVzc2FnZTogZXJyb3IsXG4gICAgfSk7XG4gIH1cblxuICBfZW1pdFN0YXR1cyhzdGF0dXM6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChDT05ORUNUSU9OX01VWF9TVEFUVVNfRVZFTlQsIHN0YXR1cyk7XG4gIH1cblxuICBhc3luYyBydW50aW1lRXZhbHVhdGUoZXhwcmVzc2lvbjogc3RyaW5nKTogUHJvbWlzZTxPYmplY3Q+IHtcbiAgICBsb2coYHJ1bnRpbWVFdmFsdWF0ZSgpIG9uIGR1bW15IGNvbm5lY3Rpb24gZm9yOiAke2V4cHJlc3Npb259YCk7XG4gICAgaWYgKHRoaXMuX2R1bW15Q29ubmVjdGlvbikge1xuICAgICAgLy8gR2xvYmFsIHJ1bnRpbWUgZXZhbHVhdGlvbiBvbiBkdW1teSBjb25uZWN0aW9uIGRvZXMgbm90IGNhcmUgYWJvdXRcbiAgICAgIC8vIHdoaWNoIGZyYW1lIGl0IGlzIGJlaW5nIGV2YWx1YXRlZCBvbiBzbyBjaG9vc2UgdG9wIGZyYW1lIGhlcmUuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kdW1teUNvbm5lY3Rpb24uZXZhbHVhdGVPbkNhbGxGcmFtZSgwLCBleHByZXNzaW9uKTtcbiAgICAgIHRoaXMuX3JlcG9ydEV2YWx1YXRpb25GYWlsdXJlSWZOZWVkZWQoZXhwcmVzc2lvbiwgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHRoaXMuX25vQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGVPbkNhbGxGcmFtZShmcmFtZUluZGV4OiBudW1iZXIsIGV4cHJlc3Npb246IHN0cmluZyk6IFByb21pc2U8T2JqZWN0PiB7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWRDb25uZWN0aW9uKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9lbmFibGVkQ29ubmVjdGlvbi5ldmFsdWF0ZU9uQ2FsbEZyYW1lKGZyYW1lSW5kZXgsIGV4cHJlc3Npb24pO1xuICAgICAgdGhpcy5fcmVwb3J0RXZhbHVhdGlvbkZhaWx1cmVJZk5lZWRlZChleHByZXNzaW9uLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdGhpcy5fbm9Db25uZWN0aW9uRXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBfcmVwb3J0RXZhbHVhdGlvbkZhaWx1cmVJZk5lZWRlZChleHByZXNzaW9uOiBzdHJpbmcsIHJlc3VsdDogRXZhbHVhdGlvbkZhaWx1cmVSZXN1bHQpOiB2b2lkIHtcbiAgICBpZiAocmVzdWx0Lndhc1Rocm93bikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgIGBGYWlsZWQgdG8gZXZhbHVhdGUgXCIke2V4cHJlc3Npb259XCI6ICgke3Jlc3VsdC5lcnJvci4kLmNvZGV9KSAke3Jlc3VsdC5lcnJvci5tZXNzYWdlWzBdfWA7XG4gICAgICB0aGlzLl9jbGllbnRDYWxsYmFjay5zZW5kVXNlck1lc3NhZ2UoJ2NvbnNvbGUnLCB7XG4gICAgICAgIGxldmVsOiAnZXJyb3InLFxuICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc2V0UGF1c2VPbkV4Y2VwdGlvbnMoc3RhdGU6IEV4Y2VwdGlvblN0YXRlKTogUHJvbWlzZSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyZWFrcG9pbnRTdG9yZS5zZXRQYXVzZU9uRXhjZXB0aW9ucyhzdGF0ZSk7XG4gIH1cblxuICBzZXRCcmVha3BvaW50KGZpbGVuYW1lOiBzdHJpbmcsIGxpbmVOdW1iZXI6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2JyZWFrcG9pbnRTdG9yZS5zZXRCcmVha3BvaW50KGZpbGVuYW1lLCBsaW5lTnVtYmVyKTtcbiAgfVxuXG4gIHJlbW92ZUJyZWFrcG9pbnQoYnJlYWtwb2ludElkOiBzdHJpbmcpOiBQcm9taXNlIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWtwb2ludFN0b3JlLnJlbW92ZUJyZWFrcG9pbnQoYnJlYWtwb2ludElkKTtcbiAgfVxuXG4gIGdldFN0YWNrRnJhbWVzKCk6IFByb21pc2U8e3N0YWNrOiBBcnJheTxPYmplY3Q+fT4ge1xuICAgIGlmICh0aGlzLl9lbmFibGVkQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWRDb25uZWN0aW9uLmdldFN0YWNrRnJhbWVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgb2NjdXJzIG9uIHN0YXJ0dXAgd2l0aCB0aGUgbG9hZGVyIGJyZWFrcG9pbnQuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGFjazogW119KTtcbiAgICB9XG4gIH1cblxuICBnZXRTY29wZXNGb3JGcmFtZShmcmFtZUluZGV4OiBudW1iZXIpOiBQcm9taXNlPFNjb3BlPiB7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWRDb25uZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZENvbm5lY3Rpb24uZ2V0U2NvcGVzRm9yRnJhbWUoZnJhbWVJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHRoaXMuX25vQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdHVzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuXG4gIHNlbmRDb250aW51YXRpb25Db21tYW5kKGNvbW1hbmQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9lbmFibGVkQ29ubmVjdGlvbikge1xuICAgICAgdGhpcy5fZW5hYmxlZENvbm5lY3Rpb24uc2VuZENvbnRpbnVhdGlvbkNvbW1hbmQoY29tbWFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHRoaXMuX25vQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgc2VuZEJyZWFrQ29tbWFuZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodGhpcy5fZW5hYmxlZENvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkQ29ubmVjdGlvbi5zZW5kQnJlYWtDb21tYW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGdldFByb3BlcnRpZXMocmVtb3RlSWQ6IFJlbW90ZU9iamVjdElkKTogUHJvbWlzZTxBcnJheTxQcm9wZXJ0eURlc2NyaXB0b3I+PiB7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWRDb25uZWN0aW9uICYmIHRoaXMuX3N0YXR1cyA9PT0gU1RBVFVTX0JSRUFLKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZENvbm5lY3Rpb24uZ2V0UHJvcGVydGllcyhyZW1vdGVJZCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kdW1teUNvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9kdW1teUNvbm5lY3Rpb24uZ2V0UHJvcGVydGllcyhyZW1vdGVJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHRoaXMuX25vQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2YgdGhpcy5fY29ubmVjdGlvbnMua2V5cygpKSB7XG4gICAgICB0aGlzLl9yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZHVtbXlSZXF1ZXN0UHJvY2Vzcykge1xuICAgICAgdGhpcy5fZHVtbXlSZXF1ZXN0UHJvY2Vzcy5raWxsKCdTSUdLSUxMJyk7XG4gICAgfVxuICAgIHRoaXMuX2Rpc3Bvc2VDb25uZWN0b3IoKTtcbiAgfVxuXG4gIF9yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb246IENvbm5lY3Rpb24pOiB2b2lkIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5fY29ubmVjdGlvbnMuZ2V0KGNvbm5lY3Rpb24pO1xuICAgIGluZm8ub25TdGF0dXNEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICBjb25uZWN0aW9uLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5kZWxldGUoY29ubmVjdGlvbik7XG5cbiAgICBpZiAoY29ubmVjdGlvbiA9PT0gdGhpcy5fZW5hYmxlZENvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVDb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX2NoZWNrRm9yRW5kKCk7XG4gIH1cblxuICBfZGlzYWJsZUNvbm5lY3Rpb24oKTogdm9pZCB7XG4gICAgbG9nKCdNdXggZGlzYWJsaW5nIGNvbm5lY3Rpb24nKTtcbiAgICB0aGlzLl9lbmFibGVkQ29ubmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fc2V0U3RhdHVzKFNUQVRVU19SVU5OSU5HKTtcbiAgfVxuXG4gIF9kaXNwb3NlQ29ubmVjdG9yKCk6IHZvaWQge1xuICAgIC8vIEF2b2lkIHJlY3Vyc2lvbiB3aXRoIGNvbm5lY3RvcidzIG9uQ2xvc2UgZXZlbnQuXG4gICAgY29uc3QgY29ubmVjdG9yID0gdGhpcy5fY29ubmVjdG9yO1xuICAgIGlmIChjb25uZWN0b3IpIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RvciA9IG51bGw7XG4gICAgICBjb25uZWN0b3IuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLl9jaGVja0ZvckVuZCgpO1xuICB9XG5cbiAgX2NoZWNrRm9yRW5kKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9ucy5zaXplID09PSAwICYmXG4gICAgICAgKCF0aGlzLl9jb25uZWN0b3IgfHwgdGhpcy5fY29uZmlnLmVuZERlYnVnV2hlbk5vUmVxdWVzdHMpKSB7XG4gICAgICB0aGlzLl9zZXRTdGF0dXMoU1RBVFVTX0VORCk7XG4gICAgfVxuICB9XG5cbiAgX25vQ29ubmVjdGlvbkVycm9yKCk6IEVycm9yIHtcbiAgICAvLyBUaGlzIGlzIGFuIGluZGljYXRpb24gb2YgYSBidWcgaW4gdGhlIHN0YXRlIG1hY2hpbmUuXG4gICAgLy8gLi4gd2UgYXJlIHNlZWluZyBhIHJlcXVlc3QgaW4gYSBzdGF0ZSB0aGF0IHNob3VsZCBub3QgZ2VuZXJhdGVcbiAgICAvLyB0aGF0IHJlcXVlc3QuXG4gICAgcmV0dXJuIG5ldyBFcnJvcignTm8gY29ubmVjdGlvbicpO1xuICB9XG59XG4iXX0=
