var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

'use babel';

var logger = require('nuclide-logging').getLogger();
var path = require('path');
var buckProjectModule = require('nuclide-buck-base').BuckProject;

var CLANG_FLAGS_THAT_TAKE_PATHS = new Set(['-F', '-I', '-include', '-iquote', '-isysroot', '-isystem']);

var from = require('nuclide-commons').array.from;

var clangArgs = from(CLANG_FLAGS_THAT_TAKE_PATHS, function (item) {
  return item.length === 2 ? item : null;
}).filter(function (item) {
  return item !== null;
});
var SINGLE_LETTER_CLANG_FLAGS_THAT_TAKE_PATHS = new Set(clangArgs);

var ClangFlagsManager = (function () {
  function ClangFlagsManager(buckUtils) {
    _classCallCheck(this, ClangFlagsManager);

    /**
     * Keys are absolute paths. Values are space-delimited strings of flags.
     */
    this.pathToFlags = {};
    this._buckUtils = buckUtils;
    this._cachedBuckProjects = new Map();
  }

  _createClass(ClangFlagsManager, [{
    key: 'reset',
    value: function reset() {
      // TODO(mbolin): Message clang_server.py to clear its cache.
      this.pathToFlags = {};
    }
  }, {
    key: '_getBuckProject',
    value: _asyncToGenerator(function* (src) {
      // For now, if a user requests the flags for a path outside of a Buck project,
      // such as /Applications/Xcode.app/Contents/Developer/Platforms/..., then
      // return null. Going forward, we probably want to special-case some of the
      // paths under /Applications/Xcode.app so that click-to-symbol works in
      // files like Frameworks/UIKit.framework/Headers/UIImage.h.
      var buckProjectRoot = yield this._buckUtils.getBuckProjectRoot(src);
      if (buckProjectRoot == null) {
        logger.info('Did not try to attempt to get flags from Buck because ' + 'source file %s does not appear to be part of a Buck project.', src);
        return null;
      }

      if (this._cachedBuckProjects.has(buckProjectRoot)) {
        return this._cachedBuckProjects.get(buckProjectRoot);
      }

      var buckProject = new buckProjectModule.BuckProject({ rootPath: buckProjectRoot });
      this._cachedBuckProjects.set(buckProjectRoot, buckProject);
      return buckProject;
    })

    /**
     * @return a space-delimited string of flags or null if nothing is known
     *     about the src file. For example, null will be returned if src is not
     *     under the project root.
     */
  }, {
    key: 'getFlagsForSrc',
    value: _asyncToGenerator(function* (src) {
      var _this = this;

      var flags = this.pathToFlags[src];
      if (flags) {
        return flags;
      }

      var buckProject = yield this._getBuckProject(src);
      if (!buckProject) {
        return null;
      }

      var targets = yield buckProject.getOwner(src);
      if (targets.length === 0) {
        return null;
      }

      // TODO(mbolin): The architecture should be chosen from a dropdown menu like
      // it is in Xcode rather than hardcoding things to iphonesimulator-x86_64.
      var arch = undefined;
      if (process.platform === 'darwin') {
        arch = 'iphonesimulator-x86_64';
      } else {
        arch = 'default';
      }
      // TODO(mbolin): Need logic to make sure results are restricted to
      // apple_library or apple_binary rules. In practice, this should be OK for
      // now. Though once we start supporting ordinary .cpp files, then we
      // likely need to be even more careful about choosing the architecture
      // flavor.
      var buildTarget = targets[0] + '#compilation-database,' + arch;

      var buildReport = yield buckProject.build([buildTarget]);
      if (!buildReport.success) {
        // TODO(mbolin): Frequently failing due to 'Daemon is busy' errors.
        // Ultimately, Buck should queue things up, but for now, Nuclide should.
        var error = 'Failed to build ' + buildTarget;
        logger.error(error);
        throw error;
      }
      var buckProjectRoot = yield buckProject.getPath();
      var pathToCompilationDatabase = buildReport['results'][buildTarget]['output'];
      pathToCompilationDatabase = path.join(buckProjectRoot, pathToCompilationDatabase);

      var readFile = require('nuclide-commons').fsPromise.readFile;

      var compilationDatabaseJsonBuffer = yield readFile(pathToCompilationDatabase);
      var compilationDatabaseJson = compilationDatabaseJsonBuffer.toString('utf8');
      var compilationDatabase = JSON.parse(compilationDatabaseJson);
      compilationDatabase.forEach(function (item) {
        var file = item.file;

        // "args" is a non-standard property that we introduced in an older version of Buck.
        // Fortunately, the clang folks have seen the light and have added support for an identical
        // property that they happened to name "arguments":
        // https://github.com/facebook/buck/issues/437
        // For now, fall back to "args" until we get everyone to use a newer enough version of Buck
        // and then we can remove the support for the old "args" property.
        var command = item.arguments || item.args;
        _this.pathToFlags[file] = ClangFlagsManager.sanitizeCommand(file, command, buckProjectRoot);
      });

      // TODO(mbolin): Currently, src will not be in the map if it corresponds to
      // a header file. Use heuristics or whatever means necessary to fix this.
      return this.pathToFlags[src] || null;
    })
  }], [{
    key: 'sanitizeCommand',
    value: function sanitizeCommand(sourceFile, args, buckProjectRoot) {
      // For safety, create a new copy of the array. We exclude the path to the file to compile from
      // compilation database generated by Buck. It must be removed from the list of command-line
      // arguments passed to libclang.
      var normalizedSourceFile = path.normalize(sourceFile);
      args = args.filter(function (arg) {
        return normalizedSourceFile !== path.resolve(buckProjectRoot, arg);
      });

      // Resolve relative path arguments against the Buck project root.
      args.forEach(function (arg, argIndex) {
        if (CLANG_FLAGS_THAT_TAKE_PATHS.has(arg)) {
          var nextIndex = argIndex + 1;
          var filePath = args[nextIndex];
          if (!path.isAbsolute(filePath)) {
            filePath = path.join(buckProjectRoot, filePath);
            args[nextIndex] = filePath;
          }
        } else if (SINGLE_LETTER_CLANG_FLAGS_THAT_TAKE_PATHS.has(arg.substring(0, 2))) {
          var filePath = arg.substring(2);
          if (!path.isAbsolute(filePath)) {
            filePath = path.join(buckProjectRoot, filePath);
            args[argIndex] = arg.substring(0, 2) + filePath;
          }
        }
      });

      // If an output file is specified, remove that argument.
      var index = args.indexOf('-o');
      if (index !== -1) {
        args.splice(index, 2);
      }

      return args;
    }
  }]);

  return ClangFlagsManager;
})();

module.exports = ClangFlagsManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNsYW5nL2xpYi9DbGFuZ0ZsYWdzTWFuYWdlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLFdBQVcsQ0FBQzs7QUFjWixJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUN0RCxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0IsSUFBTSxpQkFBaUIsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxXQUFXLENBQUM7O0FBRW5FLElBQU0sMkJBQTJCLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FDMUMsSUFBSSxFQUNKLElBQUksRUFDSixVQUFVLEVBQ1YsU0FBUyxFQUNULFdBQVcsRUFDWCxVQUFVLENBQ1gsQ0FBQyxDQUFDOztJQUVJLElBQUksR0FBSSxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxLQUFLLENBQXhDLElBQUk7O0FBQ1gsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLDJCQUEyQixFQUFFLFVBQUEsSUFBSTtTQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJO0NBQUEsQ0FBQyxDQUN2RixNQUFNLENBQUMsVUFBQSxJQUFJO1NBQUksSUFBSSxLQUFLLElBQUk7Q0FBQSxDQUFDLENBQUM7QUFDbkMsSUFBTSx5Q0FBeUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQzs7SUFHL0QsaUJBQWlCO0FBS1YsV0FMUCxpQkFBaUIsQ0FLVCxTQUFvQixFQUFFOzBCQUw5QixpQkFBaUI7Ozs7O0FBU25CLFFBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLFFBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxD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LEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDaEQsZ0JBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxRQUFRLENBQUM7V0FDNUI7U0FDRixNQUFNLElBQUkseUNBQXlDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDN0UsY0FBSSxRQUFRLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQyxjQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTtBQUM5QixvQkFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ2hELGdCQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDO1dBQ2pEO1NBQ0Y7T0FDRixDQUFDLENBQUM7OztBQUdILFVBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsVUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUU7QUFDaEIsWUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7T0FDdkI7O0FBRUQsYUFBTyxJQUFJLENBQUM7S0FDYjs7O1NBMUpHLGlCQUFpQjs7O0FBNkp2QixNQUFNLENBQUMsT0FBTyxHQUFHLGlCQUFpQixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNsYW5nL2xpYi9DbGFuZ0ZsYWdzTWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB0eXBlIEJ1Y2tVdGlscyBmcm9tICdudWNsaWRlLWJ1Y2stYmFzZS9saWIvQnVja1V0aWxzJztcbmltcG9ydCB0eXBlIHtCdWNrUHJvamVjdH0gZnJvbSAnbnVjbGlkZS1idWNrLWJhc2UvbGliL0J1Y2tQcm9qZWN0JztcblxuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnbnVjbGlkZS1sb2dnaW5nJykuZ2V0TG9nZ2VyKCk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgYnVja1Byb2plY3RNb2R1bGUgPSByZXF1aXJlKCdudWNsaWRlLWJ1Y2stYmFzZScpLkJ1Y2tQcm9qZWN0O1xuXG5jb25zdCBDTEFOR19GTEFHU19USEFUX1RBS0VfUEFUSFMgPSBuZXcgU2V0KFtcbiAgJy1GJyxcbiAgJy1JJyxcbiAgJy1pbmNsdWRlJyxcbiAgJy1pcXVvdGUnLFxuICAnLWlzeXNyb290JyxcbiAgJy1pc3lzdGVtJyxcbl0pO1xuXG5jb25zdCB7ZnJvbX0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKS5hcnJheTtcbmNvbnN0IGNsYW5nQXJncyA9IGZyb20oQ0xBTkdfRkxBR1NfVEhBVF9UQUtFX1BBVEhTLCBpdGVtID0+IGl0ZW0ubGVuZ3RoID09PSAyID8gaXRlbSA6IG51bGwpXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IG51bGwpO1xuY29uc3QgU0lOR0xFX0xFVFRFUl9DTEFOR19GTEFHU19USEFUX1RBS0VfUEFUSFMgPSBuZXcgU2V0KGNsYW5nQXJncyk7XG5cblxuY2xhc3MgQ2xhbmdGbGFnc01hbmFnZXIge1xuICBfYnVja1V0aWxzOiBCdWNrVXRpbHM7XG4gIF9jYWNoZWRCdWNrUHJvamVjdHM6IE1hcDxzdHJpbmcsIEJ1Y2tQcm9qZWN0PjtcbiAgcGF0aFRvRmxhZ3M6IHtbcGF0aDogc3RyaW5nXTogQXJyYXk8c3RyaW5nPn07XG5cbiAgY29uc3RydWN0b3IoYnVja1V0aWxzOiBCdWNrVXRpbHMpIHtcbiAgICAvKipcbiAgICAgKiBLZXlzIGFyZSBhYnNvbHV0ZSBwYXRocy4gVmFsdWVzIGFyZSBzcGFjZS1kZWxpbWl0ZWQgc3RyaW5ncyBvZiBmbGFncy5cbiAgICAgKi9cbiAgICB0aGlzLnBhdGhUb0ZsYWdzID0ge307XG4gICAgdGhpcy5fYnVja1V0aWxzID0gYnVja1V0aWxzO1xuICAgIHRoaXMuX2NhY2hlZEJ1Y2tQcm9qZWN0cyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIC8vIFRPRE8obWJvbGluKTogTWVzc2FnZSBjbGFuZ19zZXJ2ZXIucHkgdG8gY2xlYXIgaXRzIGNhY2hlLlxuICAgIHRoaXMucGF0aFRvRmxhZ3MgPSB7fTtcbiAgfVxuXG4gIGFzeW5jIF9nZXRCdWNrUHJvamVjdChzcmM6IHN0cmluZyk6IFByb21pc2U8P0J1Y2tQcm9qZWN0PiB7XG4gICAgLy8gRm9yIG5vdywgaWYgYSB1c2VyIHJlcXVlc3RzIHRoZSBmbGFncyBmb3IgYSBwYXRoIG91dHNpZGUgb2YgYSBCdWNrIHByb2plY3QsXG4gICAgLy8gc3VjaCBhcyAvQXBwbGljYXRpb25zL1hjb2RlLmFwcC9Db250ZW50cy9EZXZlbG9wZXIvUGxhdGZvcm1zLy4uLiwgdGhlblxuICAgIC8vIHJldHVybiBudWxsLiBHb2luZyBmb3J3YXJkLCB3ZSBwcm9iYWJseSB3YW50IHRvIHNwZWNpYWwtY2FzZSBzb21lIG9mIHRoZVxuICAgIC8vIHBhdGhzIHVuZGVyIC9BcHBsaWNhdGlvbnMvWGNvZGUuYXBwIHNvIHRoYXQgY2xpY2stdG8tc3ltYm9sIHdvcmtzIGluXG4gICAgLy8gZmlsZXMgbGlrZSBGcmFtZXdvcmtzL1VJS2l0LmZyYW1ld29yay9IZWFkZXJzL1VJSW1hZ2UuaC5cbiAgICBjb25zdCBidWNrUHJvamVjdFJvb3QgPSBhd2FpdCB0aGlzLl9idWNrVXRpbHMuZ2V0QnVja1Byb2plY3RSb290KHNyYyk7XG4gICAgaWYgKGJ1Y2tQcm9qZWN0Um9vdCA9PSBudWxsKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAnRGlkIG5vdCB0cnkgdG8gYXR0ZW1wdCB0byBnZXQgZmxhZ3MgZnJvbSBCdWNrIGJlY2F1c2UgJyArXG4gICAgICAgICAgJ3NvdXJjZSBmaWxlICVzIGRvZXMgbm90IGFwcGVhciB0byBiZSBwYXJ0IG9mIGEgQnVjayBwcm9qZWN0LicsXG4gICAgICAgICAgc3JjKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWNoZWRCdWNrUHJvamVjdHMuaGFzKGJ1Y2tQcm9qZWN0Um9vdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRCdWNrUHJvamVjdHMuZ2V0KGJ1Y2tQcm9qZWN0Um9vdCk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVja1Byb2plY3QgPSBuZXcgYnVja1Byb2plY3RNb2R1bGUuQnVja1Byb2plY3Qoe3Jvb3RQYXRoOiBidWNrUHJvamVjdFJvb3R9KTtcbiAgICB0aGlzLl9jYWNoZWRCdWNrUHJvamVjdHMuc2V0KGJ1Y2tQcm9qZWN0Um9vdCwgYnVja1Byb2plY3QpO1xuICAgIHJldHVybiBidWNrUHJvamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIGEgc3BhY2UtZGVsaW1pdGVkIHN0cmluZyBvZiBmbGFncyBvciBudWxsIGlmIG5vdGhpbmcgaXMga25vd25cbiAgICogICAgIGFib3V0IHRoZSBzcmMgZmlsZS4gRm9yIGV4YW1wbGUsIG51bGwgd2lsbCBiZSByZXR1cm5lZCBpZiBzcmMgaXMgbm90XG4gICAqICAgICB1bmRlciB0aGUgcHJvamVjdCByb290LlxuICAgKi9cbiAgYXN5bmMgZ2V0RmxhZ3NGb3JTcmMoc3JjOiBzdHJpbmcpOiBQcm9taXNlPD9BcnJheTxzdHJpbmc+PiB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnBhdGhUb0ZsYWdzW3NyY107XG4gICAgaWYgKGZsYWdzKSB7XG4gICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfVxuXG4gICAgY29uc3QgYnVja1Byb2plY3QgPSBhd2FpdCB0aGlzLl9nZXRCdWNrUHJvamVjdChzcmMpO1xuICAgIGlmICghYnVja1Byb2plY3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldHMgPSBhd2FpdCBidWNrUHJvamVjdC5nZXRPd25lcihzcmMpO1xuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETyhtYm9saW4pOiBUaGUgYXJjaGl0ZWN0dXJlIHNob3VsZCBiZSBjaG9zZW4gZnJvbSBhIGRyb3Bkb3duIG1lbnUgbGlrZVxuICAgIC8vIGl0IGlzIGluIFhjb2RlIHJhdGhlciB0aGFuIGhhcmRjb2RpbmcgdGhpbmdzIHRvIGlwaG9uZXNpbXVsYXRvci14ODZfNjQuXG4gICAgbGV0IGFyY2g7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICBhcmNoID0gJ2lwaG9uZXNpbXVsYXRvci14ODZfNjQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmNoID0gJ2RlZmF1bHQnO1xuICAgIH1cbiAgICAvLyBUT0RPKG1ib2xpbik6IE5lZWQgbG9naWMgdG8gbWFrZSBzdXJlIHJlc3VsdHMgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICAvLyBhcHBsZV9saWJyYXJ5IG9yIGFwcGxlX2JpbmFyeSBydWxlcy4gSW4gcHJhY3RpY2UsIHRoaXMgc2hvdWxkIGJlIE9LIGZvclxuICAgIC8vIG5vdy4gVGhvdWdoIG9uY2Ugd2Ugc3RhcnQgc3VwcG9ydGluZyBvcmRpbmFyeSAuY3BwIGZpbGVzLCB0aGVuIHdlXG4gICAgLy8gbGlrZWx5IG5lZWQgdG8gYmUgZXZlbiBtb3JlIGNhcmVmdWwgYWJvdXQgY2hvb3NpbmcgdGhlIGFyY2hpdGVjdHVyZVxuICAgIC8vIGZsYXZvci5cbiAgICBjb25zdCBidWlsZFRhcmdldCA9IHRhcmdldHNbMF0gKyAnI2NvbXBpbGF0aW9uLWRhdGFiYXNlLCcgKyBhcmNoO1xuXG4gICAgY29uc3QgYnVpbGRSZXBvcnQgPSBhd2FpdCBidWNrUHJvamVjdC5idWlsZChbYnVpbGRUYXJnZXRdKTtcbiAgICBpZiAoIWJ1aWxkUmVwb3J0LnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFRPRE8obWJvbGluKTogRnJlcXVlbnRseSBmYWlsaW5nIGR1ZSB0byAnRGFlbW9uIGlzIGJ1c3knIGVycm9ycy5cbiAgICAgIC8vIFVsdGltYXRlbHksIEJ1Y2sgc2hvdWxkIHF1ZXVlIHRoaW5ncyB1cCwgYnV0IGZvciBub3csIE51Y2xpZGUgc2hvdWxkLlxuICAgICAgY29uc3QgZXJyb3IgPSBgRmFpbGVkIHRvIGJ1aWxkICR7YnVpbGRUYXJnZXR9YDtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnVja1Byb2plY3RSb290ID0gYXdhaXQgYnVja1Byb2plY3QuZ2V0UGF0aCgpO1xuICAgIGxldCBwYXRoVG9Db21waWxhdGlvbkRhdGFiYXNlID0gYnVpbGRSZXBvcnRbJ3Jlc3VsdHMnXVtidWlsZFRhcmdldF1bJ291dHB1dCddO1xuICAgIHBhdGhUb0NvbXBpbGF0aW9uRGF0YWJhc2UgPSBwYXRoLmpvaW4oXG4gICAgICAgIGJ1Y2tQcm9qZWN0Um9vdCxcbiAgICAgICAgcGF0aFRvQ29tcGlsYXRpb25EYXRhYmFzZSk7XG5cbiAgICBjb25zdCB7cmVhZEZpbGV9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJykuZnNQcm9taXNlO1xuXG4gICAgY29uc3QgY29tcGlsYXRpb25EYXRhYmFzZUpzb25CdWZmZXIgPSBhd2FpdCByZWFkRmlsZShwYXRoVG9Db21waWxhdGlvbkRhdGFiYXNlKTtcbiAgICBjb25zdCBjb21waWxhdGlvbkRhdGFiYXNlSnNvbiA9IGNvbXBpbGF0aW9uRGF0YWJhc2VKc29uQnVmZmVyLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgY29uc3QgY29tcGlsYXRpb25EYXRhYmFzZSA9IEpTT04ucGFyc2UoY29tcGlsYXRpb25EYXRhYmFzZUpzb24pO1xuICAgIGNvbXBpbGF0aW9uRGF0YWJhc2UuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qge2ZpbGV9ID0gaXRlbTtcbiAgICAgIC8vIFwiYXJnc1wiIGlzIGEgbm9uLXN0YW5kYXJkIHByb3BlcnR5IHRoYXQgd2UgaW50cm9kdWNlZCBpbiBhbiBvbGRlciB2ZXJzaW9uIG9mIEJ1Y2suXG4gICAgICAvLyBGb3J0dW5hdGVseSwgdGhlIGNsYW5nIGZvbGtzIGhhdmUgc2VlbiB0aGUgbGlnaHQgYW5kIGhhdmUgYWRkZWQgc3VwcG9ydCBmb3IgYW4gaWRlbnRpY2FsXG4gICAgICAvLyBwcm9wZXJ0eSB0aGF0IHRoZXkgaGFwcGVuZWQgdG8gbmFtZSBcImFyZ3VtZW50c1wiOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2J1Y2svaXNzdWVzLzQzN1xuICAgICAgLy8gRm9yIG5vdywgZmFsbCBiYWNrIHRvIFwiYXJnc1wiIHVudGlsIHdlIGdldCBldmVyeW9uZSB0byB1c2UgYSBuZXdlciBlbm91Z2ggdmVyc2lvbiBvZiBCdWNrXG4gICAgICAvLyBhbmQgdGhlbiB3ZSBjYW4gcmVtb3ZlIHRoZSBzdXBwb3J0IGZvciB0aGUgb2xkIFwiYXJnc1wiIHByb3BlcnR5LlxuICAgICAgY29uc3QgY29tbWFuZCA9IGl0ZW0uYXJndW1lbnRzIHx8IGl0ZW0uYXJncztcbiAgICAgIHRoaXMucGF0aFRvRmxhZ3NbZmlsZV0gPSBDbGFuZ0ZsYWdzTWFuYWdlci5zYW5pdGl6ZUNvbW1hbmQoXG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgIGJ1Y2tQcm9qZWN0Um9vdCk7XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPKG1ib2xpbik6IEN1cnJlbnRseSwgc3JjIHdpbGwgbm90IGJlIGluIHRoZSBtYXAgaWYgaXQgY29ycmVzcG9uZHMgdG9cbiAgICAvLyBhIGhlYWRlciBmaWxlLiBVc2UgaGV1cmlzdGljcyBvciB3aGF0ZXZlciBtZWFucyBuZWNlc3NhcnkgdG8gZml4IHRoaXMuXG4gICAgcmV0dXJuIHRoaXMucGF0aFRvRmxhZ3Nbc3JjXSB8fCBudWxsO1xuICB9XG5cbiAgc3RhdGljIHNhbml0aXplQ29tbWFuZChcbiAgICBzb3VyY2VGaWxlOiBzdHJpbmcsXG4gICAgYXJnczogQXJyYXk8c3RyaW5nPixcbiAgICBidWNrUHJvamVjdFJvb3Q6IHN0cmluZ1xuICApOiBBcnJheTxzdHJpbmc+IHtcbiAgICAvLyBGb3Igc2FmZXR5LCBjcmVhdGUgYSBuZXcgY29weSBvZiB0aGUgYXJyYXkuIFdlIGV4Y2x1ZGUgdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gY29tcGlsZSBmcm9tXG4gICAgLy8gY29tcGlsYXRpb24gZGF0YWJhc2UgZ2VuZXJhdGVkIGJ5IEJ1Y2suIEl0IG11c3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0IG9mIGNvbW1hbmQtbGluZVxuICAgIC8vIGFyZ3VtZW50cyBwYXNzZWQgdG8gbGliY2xhbmcuXG4gICAgY29uc3Qgbm9ybWFsaXplZFNvdXJjZUZpbGUgPSBwYXRoLm5vcm1hbGl6ZShzb3VyY2VGaWxlKTtcbiAgICBhcmdzID0gYXJncy5maWx0ZXIoKGFyZykgPT4gbm9ybWFsaXplZFNvdXJjZUZpbGUgIT09IHBhdGgucmVzb2x2ZShidWNrUHJvamVjdFJvb3QsIGFyZykpO1xuXG4gICAgLy8gUmVzb2x2ZSByZWxhdGl2ZSBwYXRoIGFyZ3VtZW50cyBhZ2FpbnN0IHRoZSBCdWNrIHByb2plY3Qgcm9vdC5cbiAgICBhcmdzLmZvckVhY2goKGFyZywgYXJnSW5kZXgpID0+IHtcbiAgICAgIGlmIChDTEFOR19GTEFHU19USEFUX1RBS0VfUEFUSFMuaGFzKGFyZykpIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gYXJnSW5kZXggKyAxO1xuICAgICAgICBsZXQgZmlsZVBhdGggPSBhcmdzW25leHRJbmRleF07XG4gICAgICAgIGlmICghcGF0aC5pc0Fic29sdXRlKGZpbGVQYXRoKSkge1xuICAgICAgICAgIGZpbGVQYXRoID0gcGF0aC5qb2luKGJ1Y2tQcm9qZWN0Um9vdCwgZmlsZVBhdGgpO1xuICAgICAgICAgIGFyZ3NbbmV4dEluZGV4XSA9IGZpbGVQYXRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFNJTkdMRV9MRVRURVJfQ0xBTkdfRkxBR1NfVEhBVF9UQUtFX1BBVEhTLmhhcyhhcmcuc3Vic3RyaW5nKDAsIDIpKSkge1xuICAgICAgICBsZXQgZmlsZVBhdGggPSBhcmcuc3Vic3RyaW5nKDIpO1xuICAgICAgICBpZiAoIXBhdGguaXNBYnNvbHV0ZShmaWxlUGF0aCkpIHtcbiAgICAgICAgICBmaWxlUGF0aCA9IHBhdGguam9pbihidWNrUHJvamVjdFJvb3QsIGZpbGVQYXRoKTtcbiAgICAgICAgICBhcmdzW2FyZ0luZGV4XSA9IGFyZy5zdWJzdHJpbmcoMCwgMikgKyBmaWxlUGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSWYgYW4gb3V0cHV0IGZpbGUgaXMgc3BlY2lmaWVkLCByZW1vdmUgdGhhdCBhcmd1bWVudC5cbiAgICBjb25zdCBpbmRleCA9IGFyZ3MuaW5kZXhPZignLW8nKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBhcmdzLnNwbGljZShpbmRleCwgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGFuZ0ZsYWdzTWFuYWdlcjtcbiJdfQ==
