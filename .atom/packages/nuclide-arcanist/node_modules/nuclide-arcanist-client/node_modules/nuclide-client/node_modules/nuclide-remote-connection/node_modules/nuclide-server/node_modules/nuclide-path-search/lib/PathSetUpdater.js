Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _eventKit = require('event-kit');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _nuclideWatchmanHelpers = require('nuclide-watchman-helpers');

/**
 * This class keeps the PathSets passed to it up to date by using file system
 * watchers to observe when relevant file additions and deletions occur.
 * This class currently relies on the Nuclide WatchmanClient, which requires fb-watchman.
 */
// TODO (t7298196) Investigate falling back to Node watchers.
'use babel';

var PathSetUpdater = (function () {
  function PathSetUpdater() {
    _classCallCheck(this, PathSetUpdater);

    this._pathSetToSubscription = new Map();
  }

  _createClass(PathSetUpdater, [{
    key: 'dispose',
    value: function dispose() {
      if (this._watchmanClient) {
        this._watchmanClient.dispose();
      }
    }

    // Section: Add/Remove PathSets

    /**
     * @param pathSet The PathSet to keep updated.
     * @param localDirectory The directory for which we are interested in file
     * changes. This is likely to the be the same as the directory the PathSet
     * was created from.
     * @return Disposable that can be disposed to stop updating the PathSet.
     */
  }, {
    key: 'startUpdatingPathSet',
    value: _asyncToGenerator(function* (pathSet, localDirectory) {
      var _this = this;

      var subscription = yield this._addWatchmanSubscription(localDirectory);
      this._pathSetToSubscription.set(pathSet, subscription);

      subscription.on('change', function (files) {
        return _this._processWatchmanUpdate(subscription.pathFromSubscriptionRootToSubscriptionPath, pathSet, files);
      });
      return new _eventKit.Disposable(function () {
        return _this._stopUpdatingPathSet(pathSet);
      });
    })
  }, {
    key: '_stopUpdatingPathSet',
    value: function _stopUpdatingPathSet(pathSet) {
      var subscription = this._pathSetToSubscription.get(pathSet);
      if (subscription) {
        this._pathSetToSubscription['delete'](pathSet);
        this._removeWatchmanSubscription(subscription);
      }
    }

    // Section: Watchman Subscriptions

  }, {
    key: '_setupWatcherService',
    value: function _setupWatcherService() {
      if (this._watchmanClient) {
        return;
      }
      this._watchmanClient = new _nuclideWatchmanHelpers.WatchmanClient();
    }
  }, {
    key: '_addWatchmanSubscription',
    value: _asyncToGenerator(function* (localDirectory) {
      if (!this._watchmanClient) {
        this._setupWatcherService();
      }
      (0, _assert2['default'])(this._watchmanClient);
      return yield this._watchmanClient.watchDirectoryRecursive(localDirectory);
    })
  }, {
    key: '_removeWatchmanSubscription',
    value: function _removeWatchmanSubscription(subscription) {
      if (!this._watchmanClient) {
        return;
      }
      this._watchmanClient.unwatch(subscription.path);
    }

    // Section: PathSet Updating

    /**
     * Adds or removes paths from the pathSet based on the files in the update.
     * This method assumes the pathSet should be populated with file paths that
     * are *RELATIVE* to the localDirectory passed into PathSetUpdater::startUpdatingPathSet.
     * @param pathFromSubscriptionRootToDir The path from the watched
     *   root directory (what watchman actually watches) to the directory of interest
     *   (i.e. the localDirectory passed to PathSetUpdater::startUpdatingPathSet).
     *   For example, this string should be '' if those are the same.
     * @param pathSet The PathSet that should be updated by this watchman update.
     * @param files The `files` field of an fb-watchman update. Each file in the
     *   update is expected to contain fields for `name`, `new`, and `exists`.
     */
  }, {
    key: '_processWatchmanUpdate',
    value: function _processWatchmanUpdate(pathFromSubscriptionRootToDir, pathSet, files) {
      var newPaths = [];
      var deletedPaths = [];

      files.forEach(function (file) {
        var fileName = file.name;
        // Watchman returns paths relative to the subscription root, which may be
        // different from (i.e. a parent directory of) the localDirectory passed into
        // PathSetUpdater::startUpdatingPathSet. But the PathSet expects paths
        // relative to the localDirectory. Thus we need to do this adjustment.
        var adjustedPath = pathFromSubscriptionRootToDir ? fileName.slice(pathFromSubscriptionRootToDir.length + 1) : fileName;
        if (file['new']) {
          newPaths.push(adjustedPath);
        } else if (!file.exists) {
          deletedPaths.push(adjustedPath);
        }
      });

      if (newPaths.length) {
        pathSet.addPaths(newPaths);
      }
      if (deletedPaths.length) {
        pathSet.removePaths(deletedPaths);
      }
    }
  }]);

  return PathSetUpdater;
})();

exports['default'] = PathSetUpdater;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXBhdGgtc2VhcmNoL2xpYi9QYXRoU2V0VXBkYXRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFjeUIsV0FBVzs7c0JBQ2QsUUFBUTs7OztzQ0FFRCwwQkFBMEI7Ozs7Ozs7O0FBakJ2RCxXQUFXLENBQUM7O0lBeUJTLGNBQWM7QUFJdEIsV0FKUSxjQUFjLEdBSW5COzBCQUpLLGNBQWM7O0FBSy9CLFFBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQ3pDOztlQU5rQixjQUFjOztXQVExQixtQkFBRztBQUNSLFVBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtBQUN4QixZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxDQUFDO09BQ2hDO0tBQ0Y7Ozs7Ozs7Ozs7Ozs7NkJBV3lCLFdBQ3hCLE9BQWdCLEVBQ2hCLGNBQXNCLEVBQ0Q7OztBQUNyQixVQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN6RSxVQUFJLENBQUMsc0JBQXNCLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQzs7QUFFdkQsa0JBQVksQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLFVBQUMsS0FBSztlQUFLLE1BQUssc0JBQXNCLENBQzlELFlBQVksQ0FBQywwQ0FBMEMsRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUN4RTtPQUFBLENBQUMsQ0FBQztBQUNILGFBQU8sY0E1Q0gsVUFBVSxDQTRDUTtlQUFNLE1BQUssb0JBQW9CLENBQUMsT0FBTyxDQUFDO09BQUEsQ0FBQyxDQUFDO0tBQ2pFOzs7V0FFbUIsOEJBQUMsT0FBZ0IsRUFBRTtBQUNyQyxVQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzlELFVBQUksWUFBWSxFQUFFO0FBQ2hCLFlBQUksQ0FBQyxzQkFBc0IsVUFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzVDLFlBQUksQ0FBQywyQkFBMkIsQ0FBQyxZQUFZLENBQUMsQ0FBQztPQUNoRDtLQUNGOzs7Ozs7V0FLbUIsZ0NBQUc7QUFDckIsVUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQ3hCLGVBQU87T0FDUjtBQUNELFVBQUksQ0FBQyxlQUFlLEdBQUcsNEJBM0RuQixjQUFjLEVBMkR5QixDQUFDO0tBQzdDOzs7NkJBRTZCLFdBQUMsY0FBc0IsRUFBaUM7QUFDcEYsVUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUU7QUFDekIsWUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7T0FDN0I7QUFDRCwrQkFBVSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDaEMsYUFBTyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsdUJBQXVCLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDM0U7OztXQUUwQixxQ0FBQyxZQUFrQyxFQUFRO0FBQ3BFLFVBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQ3pCLGVBQU87T0FDUjtBQUNELFVBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNqRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBaUJxQixnQ0FDcEIsNkJBQXNDLEVBQ3RDLE9BQWdCLEVBQ2hCLEtBQVUsRUFDSjtBQUNOLFVBQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUNwQixVQUFNLFlBQVksR0FBRyxFQUFFLENBQUM7O0FBRXhCLFdBQUssQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFDcEIsWUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQzs7Ozs7QUFLM0IsWUFBTSxZQUFZLEdBQUcsNkJBQTZCLEdBQ2hELFFBQVEsQ0FBQyxLQUFLLENBQUMsNkJBQTZCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUN4RCxRQUFRLENBQUM7QUFDWCxZQUFJLElBQUksT0FBSSxFQUFFO0FBQ1osa0JBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDN0IsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUN2QixzQkFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNqQztPQUNGLENBQUMsQ0FBQzs7QUFFSCxVQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUU7QUFDbkIsZUFBTyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUM1QjtBQUNELFVBQUksWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUN2QixlQUFPLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO09BQ25DO0tBQ0Y7OztTQWxIa0IsY0FBYzs7O3FCQUFkLGNBQWMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtcGF0aC1zZWFyY2gvbGliL1BhdGhTZXRVcGRhdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHR5cGUgUGF0aFNldCBmcm9tICcuL1BhdGhTZXQnO1xuaW1wb3J0IHR5cGUge1dhdGNobWFuU3Vic2NyaXB0aW9ufSBmcm9tICdudWNsaWRlLXdhdGNobWFuLWhlbHBlcnMnO1xuXG5pbXBvcnQge0Rpc3Bvc2FibGV9IGZyb20gJ2V2ZW50LWtpdCc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCB7V2F0Y2htYW5DbGllbnR9IGZyb20gJ251Y2xpZGUtd2F0Y2htYW4taGVscGVycyc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBrZWVwcyB0aGUgUGF0aFNldHMgcGFzc2VkIHRvIGl0IHVwIHRvIGRhdGUgYnkgdXNpbmcgZmlsZSBzeXN0ZW1cbiAqIHdhdGNoZXJzIHRvIG9ic2VydmUgd2hlbiByZWxldmFudCBmaWxlIGFkZGl0aW9ucyBhbmQgZGVsZXRpb25zIG9jY3VyLlxuICogVGhpcyBjbGFzcyBjdXJyZW50bHkgcmVsaWVzIG9uIHRoZSBOdWNsaWRlIFdhdGNobWFuQ2xpZW50LCB3aGljaCByZXF1aXJlcyBmYi13YXRjaG1hbi5cbiAqL1xuLy8gVE9ETyAodDcyOTgxOTYpIEludmVzdGlnYXRlIGZhbGxpbmcgYmFjayB0byBOb2RlIHdhdGNoZXJzLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aFNldFVwZGF0ZXIge1xuICBfcGF0aFNldFRvU3Vic2NyaXB0aW9uOiBNYXA8UGF0aFNldCwgV2F0Y2htYW5TdWJzY3JpcHRpb24+O1xuICBfd2F0Y2htYW5DbGllbnQ6ID9XYXRjaG1hbkNsaWVudDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXRoU2V0VG9TdWJzY3JpcHRpb24gPSBuZXcgTWFwKCk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl93YXRjaG1hbkNsaWVudCkge1xuICAgICAgdGhpcy5fd2F0Y2htYW5DbGllbnQuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNlY3Rpb246IEFkZC9SZW1vdmUgUGF0aFNldHNcblxuICAvKipcbiAgICogQHBhcmFtIHBhdGhTZXQgVGhlIFBhdGhTZXQgdG8ga2VlcCB1cGRhdGVkLlxuICAgKiBAcGFyYW0gbG9jYWxEaXJlY3RvcnkgVGhlIGRpcmVjdG9yeSBmb3Igd2hpY2ggd2UgYXJlIGludGVyZXN0ZWQgaW4gZmlsZVxuICAgKiBjaGFuZ2VzLiBUaGlzIGlzIGxpa2VseSB0byB0aGUgYmUgdGhlIHNhbWUgYXMgdGhlIGRpcmVjdG9yeSB0aGUgUGF0aFNldFxuICAgKiB3YXMgY3JlYXRlZCBmcm9tLlxuICAgKiBAcmV0dXJuIERpc3Bvc2FibGUgdGhhdCBjYW4gYmUgZGlzcG9zZWQgdG8gc3RvcCB1cGRhdGluZyB0aGUgUGF0aFNldC5cbiAgICovXG4gIGFzeW5jIHN0YXJ0VXBkYXRpbmdQYXRoU2V0KFxuICAgIHBhdGhTZXQ6IFBhdGhTZXQsXG4gICAgbG9jYWxEaXJlY3Rvcnk6IHN0cmluZ1xuICApOiBQcm9taXNlPERpc3Bvc2FibGU+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCB0aGlzLl9hZGRXYXRjaG1hblN1YnNjcmlwdGlvbihsb2NhbERpcmVjdG9yeSk7XG4gICAgdGhpcy5fcGF0aFNldFRvU3Vic2NyaXB0aW9uLnNldChwYXRoU2V0LCBzdWJzY3JpcHRpb24pO1xuXG4gICAgc3Vic2NyaXB0aW9uLm9uKCdjaGFuZ2UnLCAoZmlsZXMpID0+IHRoaXMuX3Byb2Nlc3NXYXRjaG1hblVwZGF0ZShcbiAgICAgIHN1YnNjcmlwdGlvbi5wYXRoRnJvbVN1YnNjcmlwdGlvblJvb3RUb1N1YnNjcmlwdGlvblBhdGgsIHBhdGhTZXQsIGZpbGVzXG4gICAgKSk7XG4gICAgcmV0dXJuIG5ldyBEaXNwb3NhYmxlKCgpID0+IHRoaXMuX3N0b3BVcGRhdGluZ1BhdGhTZXQocGF0aFNldCkpO1xuICB9XG5cbiAgX3N0b3BVcGRhdGluZ1BhdGhTZXQocGF0aFNldDogUGF0aFNldCkge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3BhdGhTZXRUb1N1YnNjcmlwdGlvbi5nZXQocGF0aFNldCk7XG4gICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fcGF0aFNldFRvU3Vic2NyaXB0aW9uLmRlbGV0ZShwYXRoU2V0KTtcbiAgICAgIHRoaXMuX3JlbW92ZVdhdGNobWFuU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICB9XG5cblxuICAvLyBTZWN0aW9uOiBXYXRjaG1hbiBTdWJzY3JpcHRpb25zXG5cbiAgX3NldHVwV2F0Y2hlclNlcnZpY2UoKSB7XG4gICAgaWYgKHRoaXMuX3dhdGNobWFuQ2xpZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3dhdGNobWFuQ2xpZW50ID0gbmV3IFdhdGNobWFuQ2xpZW50KCk7XG4gIH1cblxuICBhc3luYyBfYWRkV2F0Y2htYW5TdWJzY3JpcHRpb24obG9jYWxEaXJlY3Rvcnk6IHN0cmluZyk6IFByb21pc2U8V2F0Y2htYW5TdWJzY3JpcHRpb24+IHtcbiAgICBpZiAoIXRoaXMuX3dhdGNobWFuQ2xpZW50KSB7XG4gICAgICB0aGlzLl9zZXR1cFdhdGNoZXJTZXJ2aWNlKCk7XG4gICAgfVxuICAgIGludmFyaWFudCh0aGlzLl93YXRjaG1hbkNsaWVudCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhdGNobWFuQ2xpZW50LndhdGNoRGlyZWN0b3J5UmVjdXJzaXZlKGxvY2FsRGlyZWN0b3J5KTtcbiAgfVxuXG4gIF9yZW1vdmVXYXRjaG1hblN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb246IFdhdGNobWFuU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl93YXRjaG1hbkNsaWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl93YXRjaG1hbkNsaWVudC51bndhdGNoKHN1YnNjcmlwdGlvbi5wYXRoKTtcbiAgfVxuXG5cbiAgLy8gU2VjdGlvbjogUGF0aFNldCBVcGRhdGluZ1xuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHJlbW92ZXMgcGF0aHMgZnJvbSB0aGUgcGF0aFNldCBiYXNlZCBvbiB0aGUgZmlsZXMgaW4gdGhlIHVwZGF0ZS5cbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGUgcGF0aFNldCBzaG91bGQgYmUgcG9wdWxhdGVkIHdpdGggZmlsZSBwYXRocyB0aGF0XG4gICAqIGFyZSAqUkVMQVRJVkUqIHRvIHRoZSBsb2NhbERpcmVjdG9yeSBwYXNzZWQgaW50byBQYXRoU2V0VXBkYXRlcjo6c3RhcnRVcGRhdGluZ1BhdGhTZXQuXG4gICAqIEBwYXJhbSBwYXRoRnJvbVN1YnNjcmlwdGlvblJvb3RUb0RpciBUaGUgcGF0aCBmcm9tIHRoZSB3YXRjaGVkXG4gICAqICAgcm9vdCBkaXJlY3RvcnkgKHdoYXQgd2F0Y2htYW4gYWN0dWFsbHkgd2F0Y2hlcykgdG8gdGhlIGRpcmVjdG9yeSBvZiBpbnRlcmVzdFxuICAgKiAgIChpLmUuIHRoZSBsb2NhbERpcmVjdG9yeSBwYXNzZWQgdG8gUGF0aFNldFVwZGF0ZXI6OnN0YXJ0VXBkYXRpbmdQYXRoU2V0KS5cbiAgICogICBGb3IgZXhhbXBsZSwgdGhpcyBzdHJpbmcgc2hvdWxkIGJlICcnIGlmIHRob3NlIGFyZSB0aGUgc2FtZS5cbiAgICogQHBhcmFtIHBhdGhTZXQgVGhlIFBhdGhTZXQgdGhhdCBzaG91bGQgYmUgdXBkYXRlZCBieSB0aGlzIHdhdGNobWFuIHVwZGF0ZS5cbiAgICogQHBhcmFtIGZpbGVzIFRoZSBgZmlsZXNgIGZpZWxkIG9mIGFuIGZiLXdhdGNobWFuIHVwZGF0ZS4gRWFjaCBmaWxlIGluIHRoZVxuICAgKiAgIHVwZGF0ZSBpcyBleHBlY3RlZCB0byBjb250YWluIGZpZWxkcyBmb3IgYG5hbWVgLCBgbmV3YCwgYW5kIGBleGlzdHNgLlxuICAgKi9cbiAgX3Byb2Nlc3NXYXRjaG1hblVwZGF0ZShcbiAgICBwYXRoRnJvbVN1YnNjcmlwdGlvblJvb3RUb0RpcjogP3N0cmluZyxcbiAgICBwYXRoU2V0OiBQYXRoU2V0LFxuICAgIGZpbGVzOiBhbnksXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IG5ld1BhdGhzID0gW107XG4gICAgY29uc3QgZGVsZXRlZFBhdGhzID0gW107XG5cbiAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAvLyBXYXRjaG1hbiByZXR1cm5zIHBhdGhzIHJlbGF0aXZlIHRvIHRoZSBzdWJzY3JpcHRpb24gcm9vdCwgd2hpY2ggbWF5IGJlXG4gICAgICAvLyBkaWZmZXJlbnQgZnJvbSAoaS5lLiBhIHBhcmVudCBkaXJlY3Rvcnkgb2YpIHRoZSBsb2NhbERpcmVjdG9yeSBwYXNzZWQgaW50b1xuICAgICAgLy8gUGF0aFNldFVwZGF0ZXI6OnN0YXJ0VXBkYXRpbmdQYXRoU2V0LiBCdXQgdGhlIFBhdGhTZXQgZXhwZWN0cyBwYXRoc1xuICAgICAgLy8gcmVsYXRpdmUgdG8gdGhlIGxvY2FsRGlyZWN0b3J5LiBUaHVzIHdlIG5lZWQgdG8gZG8gdGhpcyBhZGp1c3RtZW50LlxuICAgICAgY29uc3QgYWRqdXN0ZWRQYXRoID0gcGF0aEZyb21TdWJzY3JpcHRpb25Sb290VG9EaXIgP1xuICAgICAgICBmaWxlTmFtZS5zbGljZShwYXRoRnJvbVN1YnNjcmlwdGlvblJvb3RUb0Rpci5sZW5ndGggKyAxKSA6XG4gICAgICAgIGZpbGVOYW1lO1xuICAgICAgaWYgKGZpbGUubmV3KSB7XG4gICAgICAgIG5ld1BhdGhzLnB1c2goYWRqdXN0ZWRQYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZpbGUuZXhpc3RzKSB7XG4gICAgICAgIGRlbGV0ZWRQYXRocy5wdXNoKGFkanVzdGVkUGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobmV3UGF0aHMubGVuZ3RoKSB7XG4gICAgICBwYXRoU2V0LmFkZFBhdGhzKG5ld1BhdGhzKTtcbiAgICB9XG4gICAgaWYgKGRlbGV0ZWRQYXRocy5sZW5ndGgpIHtcbiAgICAgIHBhdGhTZXQucmVtb3ZlUGF0aHMoZGVsZXRlZFBhdGhzKTtcbiAgICB9XG4gIH1cblxufVxuIl19
