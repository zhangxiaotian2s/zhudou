

/**
 * @param revision A string representation of the revision desired. See
 * Mercurial documentation for ways to specify a revision.
 * @return The content of the filePath at the given revision. Returns null
 * if the operation fails for whatever reason, including invalid input (e.g. if
 * you pass an invalid revision).
 */

var fetchFilesChangedAtRevision = _asyncToGenerator(function* (revision, workingDirectory) {
  var args = ['log', '--template', REVISION_FILE_CHANGES_TEMPLATE, '--rev', revision];
  var execOptions = {
    cwd: workingDirectory
  };
  var output = yield hgAsyncExecute(args, execOptions);
  if (output) {
    output = parseRevisionFileChangeOutput(output, workingDirectory);
  }
  return output;
}

/**
 * @param output Raw output string from 'hg log' call in `fetchFilesChangedAtRevision`.
 * @param workingDirectory The absolute path to the working directory of the hg repository.
 * @return A RevisionFileChanges object where the paths are all absolute paths.
 */
);

var hgAsyncExecute = _asyncToGenerator(function* (args, execOptions) {
  var output = undefined;
  try {
    output = yield asyncExecute('hg', args, execOptions);
  } catch (e) {
    logger.error('Hg command: failed with error: ', e.stderr);
    return null;
  }
  return output.stdout;
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

'use babel';

var _require = require('nuclide-commons');

var asyncExecute = _require.asyncExecute;

var logger = require('nuclide-logging').getLogger();
var path = require('path');

var ALL_FILES_LABEL = 'files:';
var FILE_ADDS_LABEL = 'file-adds:';
var FILE_DELETES_LABEL = 'file-dels:';
var FILE_COPIES_LABEL = 'file-copies:';
var FILE_MODS_LABEL = 'file-mods:';
var REVISION_FILE_CHANGES_TEMPLATE = ALL_FILES_LABEL + ' {files}\n' + FILE_ADDS_LABEL + ' {file_adds}\n' + FILE_DELETES_LABEL + ' {file_dels}\n' + FILE_COPIES_LABEL + ' {file_copies}\n' + FILE_MODS_LABEL + ' {file_mods}';
// Regex for: "new_file (previous_file", with two capture groups, one for each file.
var COPIED_FILE_PAIR_REGEX = /(.+) \((.+)/;

/**
 * @param filePath An absolute path to a file.
 * @param revision A string representation of the revision desired. See
 * Mercurial documentation for ways to specify a revision.
 * @param The working directory (aka root directory) of the Hg repository.
 * @return The content of the filePath at the given revision. Returns null
 * if the operation fails for whatever reason, including invalid input (e.g. if
 * you pass a filePath that does not exist at the given revision).
 */
function fetchFileContentAtRevision(filePath, revision, workingDirectory) {
  var args = ['cat', filePath];
  if (revision) {
    args.splice(1, 0, '--rev', revision);
  }
  var execOptions = {
    cwd: workingDirectory
  };
  return hgAsyncExecute(args, execOptions);
}function parseRevisionFileChangeOutput(output, workingDirectory) {
  var lines = output.trim().split('\n');
  var allFiles = lines[0].slice(ALL_FILES_LABEL.length + 1).trim();
  allFiles = allFiles.length ? allFiles.split(' ') : [];
  allFiles = absolutizeAll(allFiles, workingDirectory);

  var addedFiles = lines[1].slice(FILE_ADDS_LABEL.length + 1).trim();
  addedFiles = addedFiles.length ? addedFiles.split(' ') : [];
  addedFiles = absolutizeAll(addedFiles, workingDirectory);

  var deletedFiles = lines[2].slice(FILE_DELETES_LABEL.length + 1).trim();
  deletedFiles = deletedFiles.length ? deletedFiles.split(' ') : [];
  deletedFiles = absolutizeAll(deletedFiles, workingDirectory);

  // Copied files are in the form: new_file (previous_file)new_file2 (previous_file2)[...]
  // There is no space between entries.
  var copiedFiles = lines[3].slice(FILE_COPIES_LABEL.length + 1).trim();
  copiedFiles = copiedFiles.length ? copiedFiles.split(')') : [];
  // We expect the string to end with a ')', so the last entry in copiedFiles will
  // be an empty string. Remove this.
  copiedFiles.pop();
  // Parse the lines, now in the form: new_file (previous_file)
  copiedFiles = copiedFiles.map(function (filePathPair) {
    var fileNameMatches = filePathPair.match(COPIED_FILE_PAIR_REGEX);
    (0, _assert2['default'])(fileNameMatches);
    return {
      from: absolutize(fileNameMatches[2], workingDirectory),
      to: absolutize(fileNameMatches[1], workingDirectory)
    };
  });

  var modifiedFiles = lines[4].slice(FILE_MODS_LABEL.length + 1).trim();
  modifiedFiles = modifiedFiles.length ? modifiedFiles.split(' ') : [];
  modifiedFiles = absolutizeAll(modifiedFiles, workingDirectory);

  return {
    all: allFiles,
    added: addedFiles,
    deleted: deletedFiles,
    copied: copiedFiles,
    modified: modifiedFiles
  };
}

function absolutize(filePath, workingDirectory) {
  return path.join(workingDirectory, filePath);
}

function absolutizeAll(filePaths, workingDirectory) {
  return filePaths.map(function (filePath) {
    return absolutize(filePath, workingDirectory);
  });
}

module.exports = {
  fetchFileContentAtRevision: fetchFileContentAtRevision,
  fetchFilesChangedAtRevision: fetchFilesChangedAtRevision,
  parseRevisionFileChangeOutput: parseRevisionFileChangeOutput };
// exposed for testing
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvaGctcmV2aXNpb24tc3RhdGUtaGVscGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBaUVlLDJCQUEyQixxQkFBMUMsV0FDRSxRQUFnQixFQUNoQixnQkFBd0IsRUFDTztBQUMvQixNQUFNLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUUsOEJBQThCLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ3RGLE1BQU0sV0FBVyxHQUFHO0FBQ2xCLE9BQUcsRUFBRSxnQkFBZ0I7R0FDdEIsQ0FBQztBQUNGLE1BQUksTUFBTSxHQUFHLE1BQU0sY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztBQUNyRCxNQUFJLE1BQU0sRUFBRTtBQUNWLFVBQU0sR0FBRyw2QkFBNkIsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztHQUNsRTtBQUNELFNBQU8sTUFBTSxDQUFDO0NBQ2Y7Ozs7Ozs7OztJQXVEYyxjQUFjLHFCQUE3QixXQUE4QixJQUFtQixFQUFFLFdBQWdCLEVBQWdCO0FBQ2pGLE1BQUksTUFBTSxZQUFBLENBQUM7QUFDWCxNQUFJO0FBQ0YsVUFBTSxHQUFHLE1BQU0sWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7R0FDdEQsQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUNWLFVBQU0sQ0FBQyxLQUFLLENBQUMsaUNBQWlDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzFELFdBQU8sSUFBSSxDQUFDO0dBQ2I7QUFDRCxTQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7Q0FDdEI7Ozs7Ozs7Ozs7Ozs7O3NCQTdIcUIsUUFBUTs7OztBQWpCOUIsV0FBVyxD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O1dBQUksVUFBVSxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQztHQUFBLENBQUMsQ0FBQztDQUMxRTs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHO0FBQ2YsNEJBQTBCLEVBQTFCLDBCQUEwQjtBQUMxQiw2QkFBMkIsRUFBM0IsMkJBQTJCO0FBQzNCLCtCQUE2QixFQUE3Qiw2QkFBNkIsRUFDOUIsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1oZy1yZXBvc2l0b3J5LWJhc2UvbGliL2hnLXJldmlzaW9uLXN0YXRlLWhlbHBlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7UmV2aXNpb25GaWxlQ2hhbmdlc30gZnJvbSAnLi9oZy1jb25zdGFudHMnO1xuaW1wb3J0IHR5cGUge051Y2xpZGVVcml9IGZyb20gJ251Y2xpZGUtcmVtb3RlLXVyaSc7XG5cbmNvbnN0IHthc3luY0V4ZWN1dGV9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IEFMTF9GSUxFU19MQUJFTCA9ICdmaWxlczonO1xuY29uc3QgRklMRV9BRERTX0xBQkVMID0gJ2ZpbGUtYWRkczonO1xuY29uc3QgRklMRV9ERUxFVEVTX0xBQkVMID0gJ2ZpbGUtZGVsczonO1xuY29uc3QgRklMRV9DT1BJRVNfTEFCRUwgPSAnZmlsZS1jb3BpZXM6JztcbmNvbnN0IEZJTEVfTU9EU19MQUJFTCA9ICdmaWxlLW1vZHM6JztcbmNvbnN0IFJFVklTSU9OX0ZJTEVfQ0hBTkdFU19URU1QTEFURSA9XG5gJHtBTExfRklMRVNfTEFCRUx9IHtmaWxlc31cbiR7RklMRV9BRERTX0xBQkVMfSB7ZmlsZV9hZGRzfVxuJHtGSUxFX0RFTEVURVNfTEFCRUx9IHtmaWxlX2RlbHN9XG4ke0ZJTEVfQ09QSUVTX0xBQkVMfSB7ZmlsZV9jb3BpZXN9XG4ke0ZJTEVfTU9EU19MQUJFTH0ge2ZpbGVfbW9kc31gO1xuLy8gUmVnZXggZm9yOiBcIm5ld19maWxlIChwcmV2aW91c19maWxlXCIsIHdpdGggdHdvIGNhcHR1cmUgZ3JvdXBzLCBvbmUgZm9yIGVhY2ggZmlsZS5cbmNvbnN0IENPUElFRF9GSUxFX1BBSVJfUkVHRVggPSAvKC4rKSBcXCgoLispLztcblxuXG4vKipcbiAqIEBwYXJhbSBmaWxlUGF0aCBBbiBhYnNvbHV0ZSBwYXRoIHRvIGEgZmlsZS5cbiAqIEBwYXJhbSByZXZpc2lvbiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmV2aXNpb24gZGVzaXJlZC4gU2VlXG4gKiBNZXJjdXJpYWwgZG9jdW1lbnRhdGlvbiBmb3Igd2F5cyB0byBzcGVjaWZ5IGEgcmV2aXNpb24uXG4gKiBAcGFyYW0gVGhlIHdvcmtpbmcgZGlyZWN0b3J5IChha2Egcm9vdCBkaXJlY3RvcnkpIG9mIHRoZSBIZyByZXBvc2l0b3J5LlxuICogQHJldHVybiBUaGUgY29udGVudCBvZiB0aGUgZmlsZVBhdGggYXQgdGhlIGdpdmVuIHJldmlzaW9uLiBSZXR1cm5zIG51bGxcbiAqIGlmIHRoZSBvcGVyYXRpb24gZmFpbHMgZm9yIHdoYXRldmVyIHJlYXNvbiwgaW5jbHVkaW5nIGludmFsaWQgaW5wdXQgKGUuZy4gaWZcbiAqIHlvdSBwYXNzIGEgZmlsZVBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCBhdCB0aGUgZ2l2ZW4gcmV2aXNpb24pLlxuICovXG5mdW5jdGlvbiBmZXRjaEZpbGVDb250ZW50QXRSZXZpc2lvbihcbiAgZmlsZVBhdGg6IE51Y2xpZGVVcmksXG4gIHJldmlzaW9uOiA/c3RyaW5nLFxuICB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcsXG4pOiBQcm9taXNlPD9zdHJpbmc+IHtcbiAgY29uc3QgYXJncyA9IFsnY2F0JywgZmlsZVBhdGhdO1xuICBpZiAocmV2aXNpb24pIHtcbiAgICBhcmdzLnNwbGljZSgxLCAwLCAnLS1yZXYnLCByZXZpc2lvbik7XG4gIH1cbiAgY29uc3QgZXhlY09wdGlvbnMgPSB7XG4gICAgY3dkOiB3b3JraW5nRGlyZWN0b3J5LFxuICB9O1xuICByZXR1cm4gaGdBc3luY0V4ZWN1dGUoYXJncywgZXhlY09wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSByZXZpc2lvbiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmV2aXNpb24gZGVzaXJlZC4gU2VlXG4gKiBNZXJjdXJpYWwgZG9jdW1lbnRhdGlvbiBmb3Igd2F5cyB0byBzcGVjaWZ5IGEgcmV2aXNpb24uXG4gKiBAcmV0dXJuIFRoZSBjb250ZW50IG9mIHRoZSBmaWxlUGF0aCBhdCB0aGUgZ2l2ZW4gcmV2aXNpb24uIFJldHVybnMgbnVsbFxuICogaWYgdGhlIG9wZXJhdGlvbiBmYWlscyBmb3Igd2hhdGV2ZXIgcmVhc29uLCBpbmNsdWRpbmcgaW52YWxpZCBpbnB1dCAoZS5nLiBpZlxuICogeW91IHBhc3MgYW4gaW52YWxpZCByZXZpc2lvbikuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRmlsZXNDaGFuZ2VkQXRSZXZpc2lvbihcbiAgcmV2aXNpb246IHN0cmluZyxcbiAgd29ya2luZ0RpcmVjdG9yeTogc3RyaW5nLFxuKTogUHJvbWlzZTw/UmV2aXNpb25GaWxlQ2hhbmdlcz4ge1xuICBjb25zdCBhcmdzID0gWydsb2cnLCAnLS10ZW1wbGF0ZScsIFJFVklTSU9OX0ZJTEVfQ0hBTkdFU19URU1QTEFURSwgJy0tcmV2JywgcmV2aXNpb25dO1xuICBjb25zdCBleGVjT3B0aW9ucyA9IHtcbiAgICBjd2Q6IHdvcmtpbmdEaXJlY3RvcnksXG4gIH07XG4gIGxldCBvdXRwdXQgPSBhd2FpdCBoZ0FzeW5jRXhlY3V0ZShhcmdzLCBleGVjT3B0aW9ucyk7XG4gIGlmIChvdXRwdXQpIHtcbiAgICBvdXRwdXQgPSBwYXJzZVJldmlzaW9uRmlsZUNoYW5nZU91dHB1dChvdXRwdXQsIHdvcmtpbmdEaXJlY3RvcnkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIG91dHB1dCBSYXcgb3V0cHV0IHN0cmluZyBmcm9tICdoZyBsb2cnIGNhbGwgaW4gYGZldGNoRmlsZXNDaGFuZ2VkQXRSZXZpc2lvbmAuXG4gKiBAcGFyYW0gd29ya2luZ0RpcmVjdG9yeSBUaGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgd29ya2luZyBkaXJlY3Rvcnkgb2YgdGhlIGhnIHJlcG9zaXRvcnkuXG4gKiBAcmV0dXJuIEEgUmV2aXNpb25GaWxlQ2hhbmdlcyBvYmplY3Qgd2hlcmUgdGhlIHBhdGhzIGFyZSBhbGwgYWJzb2x1dGUgcGF0aHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmV2aXNpb25GaWxlQ2hhbmdlT3V0cHV0KFxuICBvdXRwdXQ6IHN0cmluZyxcbiAgd29ya2luZ0RpcmVjdG9yeTogc3RyaW5nLFxuKTogUmV2aXNpb25GaWxlQ2hhbmdlcyB7XG4gIGNvbnN0IGxpbmVzID0gb3V0cHV0LnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gIGxldCBhbGxGaWxlcyA9IGxpbmVzWzBdLnNsaWNlKEFMTF9GSUxFU19MQUJFTC5sZW5ndGggKyAxKS50cmltKCk7XG4gIGFsbEZpbGVzID0gYWxsRmlsZXMubGVuZ3RoID8gYWxsRmlsZXMuc3BsaXQoJyAnKSA6IFtdO1xuICBhbGxGaWxlcyA9IGFic29sdXRpemVBbGwoYWxsRmlsZXMsIHdvcmtpbmdEaXJlY3RvcnkpO1xuXG4gIGxldCBhZGRlZEZpbGVzID0gbGluZXNbMV0uc2xpY2UoRklMRV9BRERTX0xBQkVMLmxlbmd0aCArIDEpLnRyaW0oKTtcbiAgYWRkZWRGaWxlcyA9IGFkZGVkRmlsZXMubGVuZ3RoID8gYWRkZWRGaWxlcy5zcGxpdCgnICcpIDogW107XG4gIGFkZGVkRmlsZXMgPSBhYnNvbHV0aXplQWxsKGFkZGVkRmlsZXMsIHdvcmtpbmdEaXJlY3RvcnkpO1xuXG4gIGxldCBkZWxldGVkRmlsZXMgPSBsaW5lc1syXS5zbGljZShGSUxFX0RFTEVURVNfTEFCRUwubGVuZ3RoICsgMSkudHJpbSgpO1xuICBkZWxldGVkRmlsZXMgPSBkZWxldGVkRmlsZXMubGVuZ3RoID8gZGVsZXRlZEZpbGVzLnNwbGl0KCcgJykgOiBbXTtcbiAgZGVsZXRlZEZpbGVzID0gYWJzb2x1dGl6ZUFsbChkZWxldGVkRmlsZXMsIHdvcmtpbmdEaXJlY3RvcnkpO1xuXG4gIC8vIENvcGllZCBmaWxlcyBhcmUgaW4gdGhlIGZvcm06IG5ld19maWxlIChwcmV2aW91c19maWxlKW5ld19maWxlMiAocHJldmlvdXNfZmlsZTIpWy4uLl1cbiAgLy8gVGhlcmUgaXMgbm8gc3BhY2UgYmV0d2VlbiBlbnRyaWVzLlxuICBsZXQgY29waWVkRmlsZXMgPSBsaW5lc1szXS5zbGljZShGSUxFX0NPUElFU19MQUJFTC5sZW5ndGggKyAxKS50cmltKCk7XG4gIGNvcGllZEZpbGVzID0gY29waWVkRmlsZXMubGVuZ3RoID8gY29waWVkRmlsZXMuc3BsaXQoJyknKSA6IFtdO1xuICAvLyBXZSBleHBlY3QgdGhlIHN0cmluZyB0byBlbmQgd2l0aCBhICcpJywgc28gdGhlIGxhc3QgZW50cnkgaW4gY29waWVkRmlsZXMgd2lsbFxuICAvLyBiZSBhbiBlbXB0eSBzdHJpbmcuIFJlbW92ZSB0aGlzLlxuICBjb3BpZWRGaWxlcy5wb3AoKTtcbiAgLy8gUGFyc2UgdGhlIGxpbmVzLCBub3cgaW4gdGhlIGZvcm06IG5ld19maWxlIChwcmV2aW91c19maWxlKVxuICBjb3BpZWRGaWxlcyA9IGNvcGllZEZpbGVzLm1hcCgoZmlsZVBhdGhQYWlyKSA9PiB7XG4gICAgY29uc3QgZmlsZU5hbWVNYXRjaGVzID0gZmlsZVBhdGhQYWlyLm1hdGNoKENPUElFRF9GSUxFX1BBSVJfUkVHRVgpO1xuICAgIGludmFyaWFudChmaWxlTmFtZU1hdGNoZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBhYnNvbHV0aXplKGZpbGVOYW1lTWF0Y2hlc1syXSwgd29ya2luZ0RpcmVjdG9yeSksXG4gICAgICB0bzogYWJzb2x1dGl6ZShmaWxlTmFtZU1hdGNoZXNbMV0sIHdvcmtpbmdEaXJlY3RvcnkpLFxuICAgIH07XG4gIH0pO1xuXG4gIGxldCBtb2RpZmllZEZpbGVzID0gbGluZXNbNF0uc2xpY2UoRklMRV9NT0RTX0xBQkVMLmxlbmd0aCArIDEpLnRyaW0oKTtcbiAgbW9kaWZpZWRGaWxlcyA9IG1vZGlmaWVkRmlsZXMubGVuZ3RoID8gbW9kaWZpZWRGaWxlcy5zcGxpdCgnICcpIDogW107XG4gIG1vZGlmaWVkRmlsZXMgPSBhYnNvbHV0aXplQWxsKG1vZGlmaWVkRmlsZXMsIHdvcmtpbmdEaXJlY3RvcnkpO1xuXG4gIHJldHVybiB7XG4gICAgYWxsOiBhbGxGaWxlcyxcbiAgICBhZGRlZDogYWRkZWRGaWxlcyxcbiAgICBkZWxldGVkOiBkZWxldGVkRmlsZXMsXG4gICAgY29waWVkOiBjb3BpZWRGaWxlcyxcbiAgICBtb2RpZmllZDogbW9kaWZpZWRGaWxlcyxcbiAgfTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBoZ0FzeW5jRXhlY3V0ZShhcmdzOiBBcnJheTxzdHJpbmc+LCBleGVjT3B0aW9uczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgbGV0IG91dHB1dDtcbiAgdHJ5IHtcbiAgICBvdXRwdXQgPSBhd2FpdCBhc3luY0V4ZWN1dGUoJ2hnJywgYXJncywgZXhlY09wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdIZyBjb21tYW5kOiBmYWlsZWQgd2l0aCBlcnJvcjogJywgZS5zdGRlcnIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBvdXRwdXQuc3Rkb3V0O1xufVxuXG5mdW5jdGlvbiBhYnNvbHV0aXplKGZpbGVQYXRoOiBzdHJpbmcsIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmpvaW4od29ya2luZ0RpcmVjdG9yeSwgZmlsZVBhdGgpO1xufVxuXG5mdW5jdGlvbiBhYnNvbHV0aXplQWxsKGZpbGVQYXRoczogQXJyYXk8c3RyaW5nPiwgd29ya2luZ0RpcmVjdG9yeTogc3RyaW5nKSB7XG4gIHJldHVybiBmaWxlUGF0aHMubWFwKGZpbGVQYXRoID0+IGFic29sdXRpemUoZmlsZVBhdGgsIHdvcmtpbmdEaXJlY3RvcnkpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZldGNoRmlsZUNvbnRlbnRBdFJldmlzaW9uLFxuICBmZXRjaEZpbGVzQ2hhbmdlZEF0UmV2aXNpb24sXG4gIHBhcnNlUmV2aXNpb25GaWxlQ2hhbmdlT3V0cHV0LCAvLyBleHBvc2VkIGZvciB0ZXN0aW5nXG59O1xuIl19
