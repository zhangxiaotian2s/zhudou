Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

exports.expressionForRevisionsBeforeHead = expressionForRevisionsBeforeHead;

// Section: Revision Sets

/**
 * @param revision The revision expression of a revision of interest.
 * @param workingDirectory The working directory of the Hg repository.
 * @return An expression for the common ancestor of the revision of interest and
 * the current Hg head.
 */

var fetchCommonAncestorOfHeadAndRevision = _asyncToGenerator(function* (revision, workingDirectory) {
  var _require = require('nuclide-commons');

  var asyncExecute = _require.asyncExecute;

  var ancestorExpression = 'ancestor(' + revision + ', ' + HG_CURRENT_WORKING_DIRECTORY_PARENT + ')';
  // shell-escape does not wrap ancestorExpression in quotes without this toString conversion.
  ancestorExpression = ancestorExpression.toString();

  // shell-escape does not wrap '{rev}' in quotes unless it is double-quoted.
  var args = ['log', '--template', '{rev}', '--rev', ancestorExpression];
  var options = {
    cwd: workingDirectory
  };

  try {
    var _ref = yield asyncExecute('hg', args, options);

    var ancestorRevisionNumber = _ref.stdout;

    return ancestorRevisionNumber;
  } catch (e) {
    logger.warn('Failed to get hg common ancestor: ', e.stderr, e.command);
    throw new Error('Could not fetch common ancestor of head and revision: ' + revision);
  }
}

/**
 * @param revisionFrom The revision expression of the "start" (older) revision.
 * @param revisionTo The revision expression of the "end" (newer) revision.
 * @param workingDirectory The working directory of the Hg repository.
 * @return An array of revision info between revisionFrom and
 *   revisionTo, plus revisionFrom and revisionTo;
 * "Between" means that revisionFrom is an ancestor of, and
 *   revisionTo is a descendant of.
 * For each RevisionInfo, the `bookmarks` field will contain the list
 * of bookmark names applied to that revision.
 */
);

exports.fetchCommonAncestorOfHeadAndRevision = fetchCommonAncestorOfHeadAndRevision;

var fetchRevisionInfoBetweenRevisions = _asyncToGenerator(function* (revisionFrom, revisionTo, workingDirectory) {
  var _require2 = require('nuclide-commons');

  var asyncExecute = _require2.asyncExecute;

  var revisionExpression = revisionFrom + '::' + revisionTo;
  var revisionLogArgs = ['log', '--template', REVISION_INFO_TEMPLATE, '--rev', revisionExpression];
  var bookmarksArgs = ['bookmarks'];
  var options = {
    cwd: workingDirectory
  };

  try {
    var _ref2 = yield Promise.all([asyncExecute('hg', revisionLogArgs, options), asyncExecute('hg', bookmarksArgs, options)]);

    var _ref22 = _slicedToArray(_ref2, 2);

    var revisionsResult = _ref22[0];
    var bookmarksResult = _ref22[1];

    var revisionsInfo = parseRevisionInfoOutput(revisionsResult.stdout);
    var bookmarksInfo = parseBookmarksOutput(bookmarksResult.stdout);
    for (var revisionInfo of revisionsInfo) {
      revisionInfo.bookmarks = bookmarksInfo.get(revisionInfo.id) || [];
    }
    return revisionsInfo;
  } catch (e) {
    logger.warn('Failed to get revision info between two revisions: ', e.stderr || e, e.command);
    throw new Error('Could not fetch revision numbers between the revisions: ' + revisionFrom + ', ' + revisionTo);
  }
}

/**
 * Helper function to `fetchRevisionInfoBetweenRevisions`.
 */
);

exports.fetchRevisionInfoBetweenRevisions = fetchRevisionInfoBetweenRevisions;
exports.parseRevisionInfoOutput = parseRevisionInfoOutput;
exports.parseBookmarksOutput = parseBookmarksOutput;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

'use babel';

var logger = require('nuclide-logging').getLogger();

/**
 * This file contains utilities for getting an expression to specify a certain
 * revision in Hg (i.e. something that can be passed to the '--rev' option of
 * an Hg command).
 * Note: "Head" in this set of helper functions refers to the "current working
 * directory parent" in Hg terms.
 */

// Section: Expression Formation

var HG_CURRENT_WORKING_DIRECTORY_PARENT = '.';

var INFO_ID_PREFIX = 'id:';
var INFO_HASH_PREFIX = 'hash:';
var INFO_TITLE_PREFIX = 'title:';
var INFO_AUTHOR_PREFIX = 'author:';
var INFO_DATE_PREFIX = 'date:';

var REVISION_INFO_TEMPLATE = INFO_ID_PREFIX + '{rev}\n' + INFO_TITLE_PREFIX + '{desc|firstline}\n' + INFO_AUTHOR_PREFIX + '{author}\n' + INFO_DATE_PREFIX + '{date|isodate}\n' + INFO_HASH_PREFIX + '{node|short}\n\n';

/**
 * @param revisionExpression An expression that can be passed to hg as an argument
 * to the '--rev' option.
 * @param numberOfRevsBefore The number of revisions before the current revision
 * that you want a revision expression for. Passing 0 here will simply return 'revisionExpression'.
 * @return An expression for the 'numberOfRevsBefore'th revision before the given revision.
 */
function expressionForRevisionsBefore(revisionExpression, numberOfRevsBefore) {
  if (numberOfRevsBefore === 0) {
    return revisionExpression;
  } else {
    return revisionExpression + '~' + numberOfRevsBefore.toString();
  }
}

function expressionForRevisionsBeforeHead(numberOfRevsBefore) {
  if (numberOfRevsBefore < 0) {
    numberOfRevsBefore = 0;
  }
  return expressionForRevisionsBefore(HG_CURRENT_WORKING_DIRECTORY_PARENT, numberOfRevsBefore);
}

function parseRevisionInfoOutput(revisionsInfoOutput) {
  var revisions = revisionsInfoOutput.split('\n\n');
  var revisionInfo = [];
  for (var chunk of revisions) {
    var revisionLines = chunk.trim().split('\n');
    if (revisionLines.length !== 5) {
      continue;
    }
    revisionInfo.push({
      id: parseInt(revisionLines[0].slice(INFO_ID_PREFIX.length), 10),
      title: revisionLines[1].slice(INFO_TITLE_PREFIX.length),
      author: revisionLines[2].slice(INFO_AUTHOR_PREFIX.length),
      date: new Date(revisionLines[3].slice(INFO_DATE_PREFIX.length)),
      hash: revisionLines[4].slice(INFO_HASH_PREFIX.length),
      bookmarks: []
    });
  }
  return revisionInfo;
}

// Capture the local commit id and bookmark name from the `hg bookmarks` output.
var BOOKMARK_MATCH_REGEX = /^ . ([^ ]+)\s+(\d+):([0-9a-f]+)$/;

/**
 * Parse the result of `hg bookmarks` into a `Map` from
 * revision id to a array of bookmark names applied to revision.
 */

function parseBookmarksOutput(bookmarksOutput) {
  var bookmarksLines = bookmarksOutput.split('\n');
  var commitsToBookmarks = new Map();
  for (var bookmarkLine of bookmarksLines) {
    var match = BOOKMARK_MATCH_REGEX.exec(bookmarkLine);
    if (match == null) {
      continue;
    }

    var _match = _slicedToArray(match, 3);

    var bookmarkString = _match[1];
    var commitIdString = _match[2];

    var commitId = parseInt(commitIdString, 10);
    if (!commitsToBookmarks.has(commitId)) {
      commitsToBookmarks.set(commitId, []);
    }
    var bookmarks = commitsToBookmarks.get(commitId);
    bookmarks.push(bookmarkString);
  }
  return commitsToBookmarks;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvaGctcmV2aXNpb24tZXhwcmVzc2lvbi1oZWxwZXJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwRXNCLG9DQUFvQyxxQkFBbkQsV0FDTCxRQUFnQixFQUNoQixnQkFBd0IsRUFDUDtpQkFDTSxPQUFPLENBQUMsaUJBQWlCLENBQUM7O01BQTFDLFlBQVksWUFBWixZQUFZOztBQUVuQixNQUFJLGtCQUFrQixpQkFBZSxRQUFRLFVBQUssbUNBQW1DLE1BQUcsQ0FBQzs7QUFFekYsb0JBQWtCLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLENBQUM7OztBQUduRCxNQUFNLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pFLE1BQU0sT0FBTyxHQUFHO0FBQ2QsT0FBRyxFQUFFLGdCQUFnQjtHQUN0QixDQUFDOztBQUVGLE1BQUk7ZUFDdUMsTUFBTSxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7O1FBQWpFLHNCQUFzQixRQUE5QixNQUFNOztBQUNiLFdBQU8sc0JBQXNCLENBQUM7R0FDL0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUNWLFVBQU0sQ0FBQyxJQUFJLENBQUMsb0NBQW9DLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkUsVUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsR0FBRyxRQUFRLENBQUMsQ0FBQztHQUN0RjtDQUNGOzs7Ozs7Ozs7Ozs7Ozs7OztJQWFxQixpQ0FBaUMscUJBQWhELFdBQ0wsWUFBb0IsRUFDcEIsVUFBa0IsRUFD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LFlBQVksQ0FBQyxDQUFDO0FBQ3RELFFBQUksS0FBSyxJQUFJLElBQUksRUFBRTtBQUNqQixlQUFTO0tBQ1Y7O2dDQUMwQyxLQUFLOztRQUF2QyxjQUFjO1FBQUUsY0FBYzs7QUFDdkMsUUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM5QyxRQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQ3JDLHdCQUFrQixDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDdEM7QUFDRCxRQUFNLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbkQsYUFBUyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztHQUNoQztBQUNELFNBQU8sa0JBQWtCLENBQUM7Q0FDM0IiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtaGctcmVwb3NpdG9yeS1iYXNlL2xpYi9oZy1yZXZpc2lvbi1leHByZXNzaW9uLWhlbHBlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7UmV2aXNpb25JbmZvfSBmcm9tICcuL2hnLWNvbnN0YW50cyc7XG5cbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgZm9yIGdldHRpbmcgYW4gZXhwcmVzc2lvbiB0byBzcGVjaWZ5IGEgY2VydGFpblxuICogcmV2aXNpb24gaW4gSGcgKGkuZS4gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgJy0tcmV2JyBvcHRpb24gb2ZcbiAqIGFuIEhnIGNvbW1hbmQpLlxuICogTm90ZTogXCJIZWFkXCIgaW4gdGhpcyBzZXQgb2YgaGVscGVyIGZ1bmN0aW9ucyByZWZlcnMgdG8gdGhlIFwiY3VycmVudCB3b3JraW5nXG4gKiBkaXJlY3RvcnkgcGFyZW50XCIgaW4gSGcgdGVybXMuXG4gKi9cblxuLy8gU2VjdGlvbjogRXhwcmVzc2lvbiBGb3JtYXRpb25cblxuY29uc3QgSEdfQ1VSUkVOVF9XT1JLSU5HX0RJUkVDVE9SWV9QQVJFTlQgPSAnLic7XG5cbmNvbnN0IElORk9fSURfUFJFRklYID0gJ2lkOic7XG5jb25zdCBJTkZPX0hBU0hfUFJFRklYID0gJ2hhc2g6JztcbmNvbnN0IElORk9fVElUTEVfUFJFRklYID0gJ3RpdGxlOic7XG5jb25zdCBJTkZPX0FVVEhPUl9QUkVGSVggPSAnYXV0aG9yOic7XG5jb25zdCBJTkZPX0RBVEVfUFJFRklYID0gJ2RhdGU6JztcblxuY29uc3QgUkVWSVNJT05fSU5GT19URU1QTEFURSA9IGAke0lORk9fSURfUFJFRklYfXtyZXZ9XG4ke0lORk9fVElUTEVfUFJFRklYfXtkZXNjfGZpcnN0bGluZX1cbiR7SU5GT19BVVRIT1JfUFJFRklYfXthdXRob3J9XG4ke0lORk9fREFURV9QUkVGSVh9e2RhdGV8aXNvZGF0ZX1cbiR7SU5GT19IQVNIX1BSRUZJWH17bm9kZXxzaG9ydH1cblxuYDtcblxuLyoqXG4gKiBAcGFyYW0gcmV2aXNpb25FeHByZXNzaW9uIEFuIGV4cHJlc3Npb24gdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGhnIGFzIGFuIGFyZ3VtZW50XG4gKiB0byB0aGUgJy0tcmV2JyBvcHRpb24uXG4gKiBAcGFyYW0gbnVtYmVyT2ZSZXZzQmVmb3JlIFRoZSBudW1iZXIgb2YgcmV2aXNpb25zIGJlZm9yZSB0aGUgY3VycmVudCByZXZpc2lvblxuICogdGhhdCB5b3Ugd2FudCBhIHJldmlzaW9uIGV4cHJlc3Npb24gZm9yLiBQYXNzaW5nIDAgaGVyZSB3aWxsIHNpbXBseSByZXR1cm4gJ3JldmlzaW9uRXhwcmVzc2lvbicuXG4gKiBAcmV0dXJuIEFuIGV4cHJlc3Npb24gZm9yIHRoZSAnbnVtYmVyT2ZSZXZzQmVmb3JlJ3RoIHJldmlzaW9uIGJlZm9yZSB0aGUgZ2l2ZW4gcmV2aXNpb24uXG4gKi9cbmZ1bmN0aW9uIGV4cHJlc3Npb25Gb3JSZXZpc2lvbnNCZWZvcmUoXG4gIHJldmlzaW9uRXhwcmVzc2lvbjogc3RyaW5nLFxuICBudW1iZXJPZlJldnNCZWZvcmU6IG51bWJlcixcbik6IHN0cmluZyB7XG4gIGlmIChudW1iZXJPZlJldnNCZWZvcmUgPT09IDApIHtcbiAgICByZXR1cm4gcmV2aXNpb25FeHByZXNzaW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXZpc2lvbkV4cHJlc3Npb24gKyAnficgKyBudW1iZXJPZlJldnNCZWZvcmUudG9TdHJpbmcoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZvclJldmlzaW9uc0JlZm9yZUhlYWQobnVtYmVyT2ZSZXZzQmVmb3JlOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAobnVtYmVyT2ZSZXZzQmVmb3JlIDwgMCkge1xuICAgIG51bWJlck9mUmV2c0JlZm9yZSA9IDA7XG4gIH1cbiAgcmV0dXJuIGV4cHJlc3Npb25Gb3JSZXZpc2lvbnNCZWZvcmUoSEdfQ1VSUkVOVF9XT1JLSU5HX0RJUkVDVE9SWV9QQVJFTlQsIG51bWJlck9mUmV2c0JlZm9yZSk7XG59XG5cbi8vIFNlY3Rpb246IFJldmlzaW9uIFNldHNcblxuLyoqXG4gKiBAcGFyYW0gcmV2aXNpb24gVGhlIHJldmlzaW9uIGV4cHJlc3Npb24gb2YgYSByZXZpc2lvbiBvZiBpbnRlcmVzdC5cbiAqIEBwYXJhbSB3b3JraW5nRGlyZWN0b3J5IFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB0aGUgSGcgcmVwb3NpdG9yeS5cbiAqIEByZXR1cm4gQW4gZXhwcmVzc2lvbiBmb3IgdGhlIGNvbW1vbiBhbmNlc3RvciBvZiB0aGUgcmV2aXNpb24gb2YgaW50ZXJlc3QgYW5kXG4gKiB0aGUgY3VycmVudCBIZyBoZWFkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21tb25BbmNlc3Rvck9mSGVhZEFuZFJldmlzaW9uKFxuICByZXZpc2lvbjogc3RyaW5nLFxuICB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCB7YXN5bmNFeGVjdXRlfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpO1xuXG4gIGxldCBhbmNlc3RvckV4cHJlc3Npb24gPSBgYW5jZXN0b3IoJHtyZXZpc2lvbn0sICR7SEdfQ1VSUkVOVF9XT1JLSU5HX0RJUkVDVE9SWV9QQVJFTlR9KWA7XG4gIC8vIHNoZWxsLWVzY2FwZSBkb2VzIG5vdCB3cmFwIGFuY2VzdG9yRXhwcmVzc2lvbiBpbiBxdW90ZXMgd2l0aG91dCB0aGlzIHRvU3RyaW5nIGNvbnZlcnNpb24uXG4gIGFuY2VzdG9yRXhwcmVzc2lvbiA9IGFuY2VzdG9yRXhwcmVzc2lvbi50b1N0cmluZygpO1xuXG4gIC8vIHNoZWxsLWVzY2FwZSBkb2VzIG5vdCB3cmFwICd7cmV2fScgaW4gcXVvdGVzIHVubGVzcyBpdCBpcyBkb3VibGUtcXVvdGVkLlxuICBjb25zdCBhcmdzID0gWydsb2cnLCAnLS10ZW1wbGF0ZScsICd7cmV2fScsICctLXJldicsIGFuY2VzdG9yRXhwcmVzc2lvbl07XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgY3dkOiB3b3JraW5nRGlyZWN0b3J5LFxuICB9O1xuXG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dDogYW5jZXN0b3JSZXZpc2lvbk51bWJlcn0gPSBhd2FpdCBhc3luY0V4ZWN1dGUoJ2hnJywgYXJncywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGFuY2VzdG9yUmV2aXNpb25OdW1iZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIud2FybignRmFpbGVkIHRvIGdldCBoZyBjb21tb24gYW5jZXN0b3I6ICcsIGUuc3RkZXJyLCBlLmNvbW1hbmQpO1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZldGNoIGNvbW1vbiBhbmNlc3RvciBvZiBoZWFkIGFuZCByZXZpc2lvbjogJyArIHJldmlzaW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSByZXZpc2lvbkZyb20gVGhlIHJldmlzaW9uIGV4cHJlc3Npb24gb2YgdGhlIFwic3RhcnRcIiAob2xkZXIpIHJldmlzaW9uLlxuICogQHBhcmFtIHJldmlzaW9uVG8gVGhlIHJldmlzaW9uIGV4cHJlc3Npb24gb2YgdGhlIFwiZW5kXCIgKG5ld2VyKSByZXZpc2lvbi5cbiAqIEBwYXJhbSB3b3JraW5nRGlyZWN0b3J5IFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB0aGUgSGcgcmVwb3NpdG9yeS5cbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgcmV2aXNpb24gaW5mbyBiZXR3ZWVuIHJldmlzaW9uRnJvbSBhbmRcbiAqICAgcmV2aXNpb25UbywgcGx1cyByZXZpc2lvbkZyb20gYW5kIHJldmlzaW9uVG87XG4gKiBcIkJldHdlZW5cIiBtZWFucyB0aGF0IHJldmlzaW9uRnJvbSBpcyBhbiBhbmNlc3RvciBvZiwgYW5kXG4gKiAgIHJldmlzaW9uVG8gaXMgYSBkZXNjZW5kYW50IG9mLlxuICogRm9yIGVhY2ggUmV2aXNpb25JbmZvLCB0aGUgYGJvb2ttYXJrc2AgZmllbGQgd2lsbCBjb250YWluIHRoZSBsaXN0XG4gKiBvZiBib29rbWFyayBuYW1lcyBhcHBsaWVkIHRvIHRoYXQgcmV2aXNpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJldmlzaW9uSW5mb0JldHdlZW5SZXZpc2lvbnMoXG4gIHJldmlzaW9uRnJvbTogc3RyaW5nLFxuICByZXZpc2lvblRvOiBzdHJpbmcsXG4gIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZyxcbik6IFByb21pc2U8QXJyYXk8UmV2aXNpb25JbmZvPj4ge1xuICBjb25zdCB7YXN5bmNFeGVjdXRlfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpO1xuXG4gIGNvbnN0IHJldmlzaW9uRXhwcmVzc2lvbiA9IGAke3JldmlzaW9uRnJvbX06OiR7cmV2aXNpb25Ub31gO1xuICBjb25zdCByZXZpc2lvbkxvZ0FyZ3MgPSBbXG4gICAgJ2xvZycsICctLXRlbXBsYXRlJywgUkVWSVNJT05fSU5GT19URU1QTEFURSxcbiAgICAnLS1yZXYnLCByZXZpc2lvbkV4cHJlc3Npb24sXG4gIF07XG4gIGNvbnN0IGJvb2ttYXJrc0FyZ3MgPSBbJ2Jvb2ttYXJrcyddO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGN3ZDogd29ya2luZ0RpcmVjdG9yeSxcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IFtyZXZpc2lvbnNSZXN1bHQsIGJvb2ttYXJrc1Jlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBhc3luY0V4ZWN1dGUoJ2hnJywgcmV2aXNpb25Mb2dBcmdzLCBvcHRpb25zKSxcbiAgICAgIGFzeW5jRXhlY3V0ZSgnaGcnLCBib29rbWFya3NBcmdzLCBvcHRpb25zKSxcbiAgICBdKTtcbiAgICBjb25zdCByZXZpc2lvbnNJbmZvID0gcGFyc2VSZXZpc2lvbkluZm9PdXRwdXQocmV2aXNpb25zUmVzdWx0LnN0ZG91dCk7XG4gICAgY29uc3QgYm9va21hcmtzSW5mbyA9IHBhcnNlQm9va21hcmtzT3V0cHV0KGJvb2ttYXJrc1Jlc3VsdC5zdGRvdXQpO1xuICAgIGZvciAoY29uc3QgcmV2aXNpb25JbmZvIG9mIHJldmlzaW9uc0luZm8pIHtcbiAgICAgIHJldmlzaW9uSW5mby5ib29rbWFya3MgPSBib29rbWFya3NJbmZvLmdldChyZXZpc2lvbkluZm8uaWQpIHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmV2aXNpb25zSW5mbztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gZ2V0IHJldmlzaW9uIGluZm8gYmV0d2VlbiB0d28gcmV2aXNpb25zOiAnLCBlLnN0ZGVyciB8fCBlLCBlLmNvbW1hbmQpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDb3VsZCBub3QgZmV0Y2ggcmV2aXNpb24gbnVtYmVycyBiZXR3ZWVuIHRoZSByZXZpc2lvbnM6ICR7cmV2aXNpb25Gcm9tfSwgJHtyZXZpc2lvblRvfWBcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGBmZXRjaFJldmlzaW9uSW5mb0JldHdlZW5SZXZpc2lvbnNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZXZpc2lvbkluZm9PdXRwdXQocmV2aXNpb25zSW5mb091dHB1dDogc3RyaW5nKTogQXJyYXk8UmV2aXNpb25JbmZvPiB7XG4gIGNvbnN0IHJldmlzaW9ucyA9IHJldmlzaW9uc0luZm9PdXRwdXQuc3BsaXQoJ1xcblxcbicpO1xuICBjb25zdCByZXZpc2lvbkluZm8gPSBbXTtcbiAgZm9yIChjb25zdCBjaHVuayBvZiByZXZpc2lvbnMpIHtcbiAgICBjb25zdCByZXZpc2lvbkxpbmVzID0gY2h1bmsudHJpbSgpLnNwbGl0KCdcXG4nKTtcbiAgICBpZiAocmV2aXNpb25MaW5lcy5sZW5ndGggIT09IDUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXZpc2lvbkluZm8ucHVzaCh7XG4gICAgICBpZDogcGFyc2VJbnQocmV2aXNpb25MaW5lc1swXS5zbGljZShJTkZPX0lEX1BSRUZJWC5sZW5ndGgpLCAxMCksXG4gICAgICB0aXRsZTogcmV2aXNpb25MaW5lc1sxXS5zbGljZShJTkZPX1RJVExFX1BSRUZJWC5sZW5ndGgpLFxuICAgICAgYXV0aG9yOiByZXZpc2lvbkxpbmVzWzJdLnNsaWNlKElORk9fQVVUSE9SX1BSRUZJWC5sZW5ndGgpLFxuICAgICAgZGF0ZTogbmV3IERhdGUocmV2aXNpb25MaW5lc1szXS5zbGljZShJTkZPX0RBVEVfUFJFRklYLmxlbmd0aCkpLFxuICAgICAgaGFzaDogcmV2aXNpb25MaW5lc1s0XS5zbGljZShJTkZPX0hBU0hfUFJFRklYLmxlbmd0aCksXG4gICAgICBib29rbWFya3M6IFtdLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXZpc2lvbkluZm87XG59XG5cbi8vIENhcHR1cmUgdGhlIGxvY2FsIGNvbW1pdCBpZCBhbmQgYm9va21hcmsgbmFtZSBmcm9tIHRoZSBgaGcgYm9va21hcmtzYCBvdXRwdXQuXG5jb25zdCBCT09LTUFSS19NQVRDSF9SRUdFWCA9IC9eIC4gKFteIF0rKVxccysoXFxkKyk6KFswLTlhLWZdKykkLztcblxuLyoqXG4gKiBQYXJzZSB0aGUgcmVzdWx0IG9mIGBoZyBib29rbWFya3NgIGludG8gYSBgTWFwYCBmcm9tXG4gKiByZXZpc2lvbiBpZCB0byBhIGFycmF5IG9mIGJvb2ttYXJrIG5hbWVzIGFwcGxpZWQgdG8gcmV2aXNpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJvb2ttYXJrc091dHB1dChib29rbWFya3NPdXRwdXQ6IHN0cmluZyk6IE1hcDxudW1iZXIsIEFycmF5PHN0cmluZz4+IHtcbiAgY29uc3QgYm9va21hcmtzTGluZXMgPSBib29rbWFya3NPdXRwdXQuc3BsaXQoJ1xcbicpO1xuICBjb25zdCBjb21taXRzVG9Cb29rbWFya3MgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgYm9va21hcmtMaW5lIG9mIGJvb2ttYXJrc0xpbmVzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBCT09LTUFSS19NQVRDSF9SRUdFWC5leGVjKGJvb2ttYXJrTGluZSk7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBbLCBib29rbWFya1N0cmluZywgY29tbWl0SWRTdHJpbmddID0gbWF0Y2g7XG4gICAgY29uc3QgY29tbWl0SWQgPSBwYXJzZUludChjb21taXRJZFN0cmluZywgMTApO1xuICAgIGlmICghY29tbWl0c1RvQm9va21hcmtzLmhhcyhjb21taXRJZCkpIHtcbiAgICAgIGNvbW1pdHNUb0Jvb2ttYXJrcy5zZXQoY29tbWl0SWQsIFtdKTtcbiAgICB9XG4gICAgY29uc3QgYm9va21hcmtzID0gY29tbWl0c1RvQm9va21hcmtzLmdldChjb21taXRJZCk7XG4gICAgYm9va21hcmtzLnB1c2goYm9va21hcmtTdHJpbmcpO1xuICB9XG4gIHJldHVybiBjb21taXRzVG9Cb29rbWFya3M7XG59XG4iXX0=
