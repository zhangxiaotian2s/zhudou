Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.exists = exists;
exports.findNearestFile = findNearestFile;
exports.lstat = lstat;
exports.mkdir = mkdir;
exports.mkdirp = mkdirp;

/**
 * If no file (or directory) at the specified path exists, creates the parent
 * directories (if necessary) and then writes an empty file at the specified
 * path.
 *
 * @return A boolean indicating whether the file was created.
 */

var newFile = _asyncToGenerator(function* (filePath) {
  var isExistingFile = yield fsPromise.exists(filePath);
  if (isExistingFile) {
    return false;
  }
  yield fsPromise.mkdirp(pathUtil.dirname(filePath));
  yield fsPromise.writeFile(filePath, '');
  return true;
}

/**
 * The readdir endpoint accepts the following query parameters:
 *
 *   path: path to the folder to list entries inside.
 *
 * Body contains a JSON encoded array of objects with file: and stats: entries.
 * file: has the file or directory name, stats: has the stats of the file/dir,
 * isSymbolicLink: true if the entry is a symlink to another filesystem location.
 */
);

exports.newFile = newFile;

var readdir = _asyncToGenerator(function* (path) {
  var files = yield fsPromise.readdir(path);
  var entries = yield Promise.all(files.map(_asyncToGenerator(function* (file) {
    var fullpath = pathUtil.join(path, file);
    var lstats = yield fsPromise.lstat(fullpath);
    if (!lstats.isSymbolicLink()) {
      return { file: file, stats: lstats, isSymbolicLink: false };
    } else {
      try {
        var stats = yield fsPromise.stat(fullpath);
        return { file: file, stats: stats, isSymbolicLink: true };
      } catch (error) {
        return { file: file, stats: undefined, isSymbolicLink: true, error: error };
      }
    }
  })));
  // TODO: Return entries directly and change client to handle error.
  return entries.filter(function (entry) {
    return entry.error === undefined;
  }).map(function (entry) {
    return { file: entry.file, stats: entry.stats, isSymbolicLink: entry.isSymbolicLink };
  });
}

/**
 * Gets the real path of a file path.
 * It could be different than the given path if the file is a symlink
 * or exists in a symlinked directory.
 */
);

exports.readdir = readdir;
exports.realpath = realpath;
exports.resolveRealPath = resolveRealPath;
exports.rename = rename;

/**
 * Runs the equivalent of `cp sourcePath destinationPath`.
 */

var copy = _asyncToGenerator(function* (sourcePath, destinationPath) {
  var isExistingFile = yield fsPromise.exists(destinationPath);
  if (isExistingFile) {
    return false;
  }
  yield new Promise(function (resolve, reject) {
    var fsPlus = require('fs-plus');
    fsPlus.copy(sourcePath, destinationPath, function (error) {
      error ? reject(error) : resolve();
    });
  });
  return true;
}

/**
 * Removes directories even if they are non-empty. Does not fail if the directory doesn't exist.
 */
);

exports.copy = copy;
exports.rmdir = rmdir;
exports.stat = stat;
exports.unlink = unlink;
exports.readFile = readFile;

/**
 * The writeFile endpoint accepts the following query parameters:
 *
 *   path: path to the file to read (it must be url encoded).
 *   options: options to pass to fs.writeFile
 *
 * TODO: move to nuclide-commons and rename to writeFileAtomic
 */

var writeFile = _asyncToGenerator(function* (path, data, options) {

  var complete = false;
  var tempFilePath = yield fsPromise.tempfile('nuclide');
  try {
    yield fsPromise.writeFile(tempFilePath, data, options);

    // Ensure file still has original permissions:
    // https://github.com/facebook/nuclide/issues/157
    // We update the mode of the temp file rather than the destination file because
    // if we did the mv() then the chmod(), there would be a brief period between
    // those two operations where the destination file might have the wrong permissions.
    var permissions = null;
    try {
      permissions = (yield fsPromise.stat(path)).mode;
    } catch (e) {
      // If the file does not exist, then ENOENT will be thrown.
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
    if (permissions != null) {
      yield fsPromise.chmod(tempFilePath, permissions);
    }

    // TODO(mikeo): put renames into a queue so we don't write older save over new save.
    // Use mv as fs.rename doesn't work across partitions.
    yield mvPromise(tempFilePath, path);
    complete = true;
  } finally {
    if (!complete) {
      yield fsPromise.unlink(tempFilePath);
    }
  }
});

exports.writeFile = writeFile;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

///////////////////
//
// Services
//
//////////////////

/**
 * Checks a certain path for existence and returns 'true'/'false' accordingly
 */
'use babel';

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/**
 * This code implements the NuclideFs service.  It exports the FS on http via
 * the endpoint: http://your.server:your_port/fs/method where method is one of
 * readFile, writeFile, etc.
 */

var mv = require('mv');
var fs = require('fs');
var pathUtil = require('path');

var _require = require('nuclide-commons');

var fsPromise = _require.fsPromise;

function exists(path) {
  return fsPromise.exists(path);
}

function findNearestFile(fileName, pathToDirectory) {
  return fsPromise.findNearestFile(fileName, pathToDirectory);
}

/**
 * The lstat endpoint is the same as the stat endpoint except it will return
 * the stat of a link instead of the file the link points to.
 */

function lstat(path) {
  return fsPromise.lstat(path);
}

/**
 * Creates a new directory with the given path.
 * Throws EEXIST error if the directory already exists.
 * Throws ENOENT if the path given is nested in a non-existing directory.
 */

function mkdir(path) {
  return fsPromise.mkdir(path);
}

/**
 * Runs the equivalent of `mkdir -p` with the given path.
 *
 * Like most implementations of mkdirp, if it fails, it is possible that
 * directories were created for some prefix of the given path.
 * @return true if the path was created; false if it already existed.
 */

function mkdirp(path) {
  return fsPromise.mkdirp(path);
}

function realpath(path) {
  return fsPromise.realpath(path);
}

function resolveRealPath(path) {
  return fsPromise.realpath(fsPromise.expandHomeDir(path));
}

/**
 * Runs the equivalent of `mv sourcePath destinationPath`.
 */

function rename(sourcePath, destinationPath) {
  return new Promise(function (resolve, reject) {
    var fsPlus = require('fs-plus');
    fsPlus.move(sourcePath, destinationPath, function (error) {
      error ? reject(error) : resolve();
    });
  });
}

function rmdir(path) {
  return fsPromise.rmdir(path);
}

/**
 * The stat endpoint accepts the following query parameters:
 *
 *   path: path to the file to read
 *
 */

function stat(path) {
  return fsPromise.stat(path);
}

/**
 * Removes files. Does not fail if the file doesn't exist.
 */

function unlink(path) {
  return fsPromise.unlink(path)['catch'](function (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
  });
}

/**
 *   path: the path to the file to read
 *   options: options to pass to fs.readFile.
 *      Note that options does NOT include 'encoding' this ensures that the return value
 *      is always a Buffer and never a string.
 *
 *   Callers who want a string should call buffer.toString('utf8').
 */

function readFile(path, options) {
  return fsPromise.readFile(path, options);
}

// TODO: Move to nuclide-commons
function mvPromise(sourcePath, destinationPath) {
  return new Promise(function (resolve, reject) {
    mv(sourcePath, destinationPath, { mkdirp: false }, function (error) {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZlci9saWIvc2VydmljZXMvRmlsZVN5c3RlbVNlcnZpY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE2RXNCLE9BQU8scUJBQXRCLFdBQXVCLFFBQWdCLEVBQW9CO0FBQ2hFLE1BQU0sY0FBYyxHQUFHLE1BQU0sU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN4RCxNQUFJLGNBQWMsRUFBRTtBQUNsQixXQUFPLEtBQUssQ0FBQztHQUNkO0FBQ0QsUUFBTSxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNuRCxRQUFNLFNBQVMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3hDLFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7Ozs7Ozs7OztJQVdxQixPQUFPLHFCQUF0QixXQUF1QixJQUFZLEVBQWlDO0FBQ3pFLE1BQU0sS0FBSyxHQUFHLE1BQU0sU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QyxNQUFNLE9BQU8sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsbUJBQUMsV0FBTyxJQUFJLEVBQUs7QUFDMUQsUUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDM0MsUUFBTSxNQUFNLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQy9DLFFBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUU7QUFDNUIsYUFBTyxFQUFDLElBQUksRUFBSixJQUFJLEVBQUUsS0FBSyxFQUFFLE1B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S0FBSyxFQUFJO0FBQ3hELFVBQUksS0FBSyxFQUFFO0FBQ1QsY0FBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO09BQ2YsTUFBTTtBQUNMLGVBQU8sRUFBRSxDQUFDO09BQ1g7S0FDRixDQUFDLENBQUM7R0FDSixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1zZXJ2ZXIvbGliL3NlcnZpY2VzL0ZpbGVTeXN0ZW1TZXJ2aWNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGNvZGUgaW1wbGVtZW50cyB0aGUgTnVjbGlkZUZzIHNlcnZpY2UuICBJdCBleHBvcnRzIHRoZSBGUyBvbiBodHRwIHZpYVxuICogdGhlIGVuZHBvaW50OiBodHRwOi8veW91ci5zZXJ2ZXI6eW91cl9wb3J0L2ZzL21ldGhvZCB3aGVyZSBtZXRob2QgaXMgb25lIG9mXG4gKiByZWFkRmlsZSwgd3JpdGVGaWxlLCBldGMuXG4gKi9cblxuY29uc3QgbXYgPSByZXF1aXJlKCdtdicpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aFV0aWwgPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7ZnNQcm9taXNlfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpO1xuXG5pbXBvcnQgdHlwZSBGaWxlV2l0aFN0YXRzIGZyb20gJy4vRmlsZVN5c3RlbVNlcnZpY2VUeXBlJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gU2VydmljZXNcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDaGVja3MgYSBjZXJ0YWluIHBhdGggZm9yIGV4aXN0ZW5jZSBhbmQgcmV0dXJucyAndHJ1ZScvJ2ZhbHNlJyBhY2NvcmRpbmdseVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICByZXR1cm4gZnNQcm9taXNlLmV4aXN0cyhwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROZWFyZXN0RmlsZShmaWxlTmFtZTogc3RyaW5nLCBwYXRoVG9EaXJlY3Rvcnk6IHN0cmluZyk6IFByb21pc2U8P3N0cmluZz4ge1xuICByZXR1cm4gZnNQcm9taXNlLmZpbmROZWFyZXN0RmlsZShmaWxlTmFtZSwgcGF0aFRvRGlyZWN0b3J5KTtcbn1cblxuLyoqXG4gKiBUaGUgbHN0YXQgZW5kcG9pbnQgaXMgdGhlIHNhbWUgYXMgdGhlIHN0YXQgZW5kcG9pbnQgZXhjZXB0IGl0IHdpbGwgcmV0dXJuXG4gKiB0aGUgc3RhdCBvZiBhIGxpbmsgaW5zdGVhZCBvZiB0aGUgZmlsZSB0aGUgbGluayBwb2ludHMgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsc3RhdChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPGZzLlN0YXRzPiB7XG4gIHJldHVybiBmc1Byb21pc2UubHN0YXQocGF0aCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBkaXJlY3Rvcnkgd2l0aCB0aGUgZ2l2ZW4gcGF0aC5cbiAqIFRocm93cyBFRVhJU1QgZXJyb3IgaWYgdGhlIGRpcmVjdG9yeSBhbHJlYWR5IGV4aXN0cy5cbiAqIFRocm93cyBFTk9FTlQgaWYgdGhlIHBhdGggZ2l2ZW4gaXMgbmVzdGVkIGluIGEgbm9uLWV4aXN0aW5nIGRpcmVjdG9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1rZGlyKHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gZnNQcm9taXNlLm1rZGlyKHBhdGgpO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGVxdWl2YWxlbnQgb2YgYG1rZGlyIC1wYCB3aXRoIHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIExpa2UgbW9zdCBpbXBsZW1lbnRhdGlvbnMgb2YgbWtkaXJwLCBpZiBpdCBmYWlscywgaXQgaXMgcG9zc2libGUgdGhhdFxuICogZGlyZWN0b3JpZXMgd2VyZSBjcmVhdGVkIGZvciBzb21lIHByZWZpeCBvZiB0aGUgZ2l2ZW4gcGF0aC5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgY3JlYXRlZDsgZmFsc2UgaWYgaXQgYWxyZWFkeSBleGlzdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWtkaXJwKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICByZXR1cm4gZnNQcm9taXNlLm1rZGlycChwYXRoKTtcbn1cblxuLyoqXG4gKiBJZiBubyBmaWxlIChvciBkaXJlY3RvcnkpIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCBleGlzdHMsIGNyZWF0ZXMgdGhlIHBhcmVudFxuICogZGlyZWN0b3JpZXMgKGlmIG5lY2Vzc2FyeSkgYW5kIHRoZW4gd3JpdGVzIGFuIGVtcHR5IGZpbGUgYXQgdGhlIHNwZWNpZmllZFxuICogcGF0aC5cbiAqXG4gKiBAcmV0dXJuIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGZpbGUgd2FzIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdGaWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgaXNFeGlzdGluZ0ZpbGUgPSBhd2FpdCBmc1Byb21pc2UuZXhpc3RzKGZpbGVQYXRoKTtcbiAgaWYgKGlzRXhpc3RpbmdGaWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGF3YWl0IGZzUHJvbWlzZS5ta2RpcnAocGF0aFV0aWwuZGlybmFtZShmaWxlUGF0aCkpO1xuICBhd2FpdCBmc1Byb21pc2Uud3JpdGVGaWxlKGZpbGVQYXRoLCAnJyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSByZWFkZGlyIGVuZHBvaW50IGFjY2VwdHMgdGhlIGZvbGxvd2luZyBxdWVyeSBwYXJhbWV0ZXJzOlxuICpcbiAqICAgcGF0aDogcGF0aCB0byB0aGUgZm9sZGVyIHRvIGxpc3QgZW50cmllcyBpbnNpZGUuXG4gKlxuICogQm9keSBjb250YWlucyBhIEpTT04gZW5jb2RlZCBhcnJheSBvZiBvYmplY3RzIHdpdGggZmlsZTogYW5kIHN0YXRzOiBlbnRyaWVzLlxuICogZmlsZTogaGFzIHRoZSBmaWxlIG9yIGRpcmVjdG9yeSBuYW1lLCBzdGF0czogaGFzIHRoZSBzdGF0cyBvZiB0aGUgZmlsZS9kaXIsXG4gKiBpc1N5bWJvbGljTGluazogdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBzeW1saW5rIHRvIGFub3RoZXIgZmlsZXN5c3RlbSBsb2NhdGlvbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRkaXIocGF0aDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxGaWxlV2l0aFN0YXRzPj4ge1xuICBjb25zdCBmaWxlcyA9IGF3YWl0IGZzUHJvbWlzZS5yZWFkZGlyKHBhdGgpO1xuICBjb25zdCBlbnRyaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoZmlsZXMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgY29uc3QgZnVsbHBhdGggPSBwYXRoVXRpbC5qb2luKHBhdGgsIGZpbGUpO1xuICAgIGNvbnN0IGxzdGF0cyA9IGF3YWl0IGZzUHJvbWlzZS5sc3RhdChmdWxscGF0aCk7XG4gICAgaWYgKCFsc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgcmV0dXJuIHtmaWxlLCBzdGF0czogbHN0YXRzLCBpc1N5bWJvbGljTGluazogZmFsc2V9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzUHJvbWlzZS5zdGF0KGZ1bGxwYXRoKTtcbiAgICAgICAgcmV0dXJuIHtmaWxlLCBzdGF0cywgaXNTeW1ib2xpY0xpbms6IHRydWV9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtmaWxlLCBzdGF0czogdW5kZWZpbmVkLCBpc1N5bWJvbGljTGluazogdHJ1ZSwgZXJyb3J9O1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xuICAvLyBUT0RPOiBSZXR1cm4gZW50cmllcyBkaXJlY3RseSBhbmQgY2hhbmdlIGNsaWVudCB0byBoYW5kbGUgZXJyb3IuXG4gIHJldHVybiBlbnRyaWVzLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5lcnJvciA9PT0gdW5kZWZpbmVkKS5cbiAgICBtYXAoZW50cnkgPT4ge1xuICAgICAgcmV0dXJuIHtmaWxlOiBlbnRyeS5maWxlLCBzdGF0czogZW50cnkuc3RhdHMsIGlzU3ltYm9saWNMaW5rOiBlbnRyeS5pc1N5bWJvbGljTGlua307XG4gICAgfSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcmVhbCBwYXRoIG9mIGEgZmlsZSBwYXRoLlxuICogSXQgY291bGQgYmUgZGlmZmVyZW50IHRoYW4gdGhlIGdpdmVuIHBhdGggaWYgdGhlIGZpbGUgaXMgYSBzeW1saW5rXG4gKiBvciBleGlzdHMgaW4gYSBzeW1saW5rZWQgZGlyZWN0b3J5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhbHBhdGgocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIGZzUHJvbWlzZS5yZWFscGF0aChwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVSZWFsUGF0aChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gZnNQcm9taXNlLnJlYWxwYXRoKGZzUHJvbWlzZS5leHBhbmRIb21lRGlyKHBhdGgpKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBlcXVpdmFsZW50IG9mIGBtdiBzb3VyY2VQYXRoIGRlc3RpbmF0aW9uUGF0aGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5hbWUoc291cmNlUGF0aDogc3RyaW5nLCBkZXN0aW5hdGlvblBhdGg6IHN0cmluZyk6IFByb21pc2Uge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZzUGx1cyA9IHJlcXVpcmUoJ2ZzLXBsdXMnKTtcbiAgICBmc1BsdXMubW92ZShzb3VyY2VQYXRoLCBkZXN0aW5hdGlvblBhdGgsIGVycm9yID0+IHtcbiAgICAgIGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUnVucyB0aGUgZXF1aXZhbGVudCBvZiBgY3Agc291cmNlUGF0aCBkZXN0aW5hdGlvblBhdGhgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29weShzb3VyY2VQYXRoOiBzdHJpbmcsIGRlc3RpbmF0aW9uUGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGlzRXhpc3RpbmdGaWxlID0gYXdhaXQgZnNQcm9taXNlLmV4aXN0cyhkZXN0aW5hdGlvblBhdGgpO1xuICBpZiAoaXNFeGlzdGluZ0ZpbGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZzUGx1cyA9IHJlcXVpcmUoJ2ZzLXBsdXMnKTtcbiAgICBmc1BsdXMuY29weShzb3VyY2VQYXRoLCBkZXN0aW5hdGlvblBhdGgsIGVycm9yID0+IHtcbiAgICAgIGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZGlyZWN0b3JpZXMgZXZlbiBpZiB0aGV5IGFyZSBub24tZW1wdHkuIERvZXMgbm90IGZhaWwgaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm1kaXIocGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBmc1Byb21pc2Uucm1kaXIocGF0aCk7XG59XG5cbi8qKlxuICogVGhlIHN0YXQgZW5kcG9pbnQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHF1ZXJ5IHBhcmFtZXRlcnM6XG4gKlxuICogICBwYXRoOiBwYXRoIHRvIHRoZSBmaWxlIHRvIHJlYWRcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0KHBhdGg6IHN0cmluZyk6IFByb21pc2U8ZnMuU3RhdHM+IHtcbiAgcmV0dXJuIGZzUHJvbWlzZS5zdGF0KHBhdGgpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMuIERvZXMgbm90IGZhaWwgaWYgdGhlIGZpbGUgZG9lc24ndCBleGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGluayhwYXRoOiBzdHJpbmcpOiBQcm9taXNlIHtcbiAgcmV0dXJuIGZzUHJvbWlzZS51bmxpbmsocGF0aCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yLmNvZGUgIT09ICdFTk9FTlQnKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqICAgcGF0aDogdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZFxuICogICBvcHRpb25zOiBvcHRpb25zIHRvIHBhc3MgdG8gZnMucmVhZEZpbGUuXG4gKiAgICAgIE5vdGUgdGhhdCBvcHRpb25zIGRvZXMgTk9UIGluY2x1ZGUgJ2VuY29kaW5nJyB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgcmV0dXJuIHZhbHVlXG4gKiAgICAgIGlzIGFsd2F5cyBhIEJ1ZmZlciBhbmQgbmV2ZXIgYSBzdHJpbmcuXG4gKlxuICogICBDYWxsZXJzIHdobyB3YW50IGEgc3RyaW5nIHNob3VsZCBjYWxsIGJ1ZmZlci50b1N0cmluZygndXRmOCcpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEZpbGUocGF0aDogc3RyaW5nLCBvcHRpb25zPzoge2ZsYWc/OiBzdHJpbmd9KTpcbiAgICBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gZnNQcm9taXNlLnJlYWRGaWxlKHBhdGgsIG9wdGlvbnMpO1xufVxuXG4vLyBUT0RPOiBNb3ZlIHRvIG51Y2xpZGUtY29tbW9uc1xuZnVuY3Rpb24gbXZQcm9taXNlKHNvdXJjZVBhdGg6IHN0cmluZywgZGVzdGluYXRpb25QYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtdihzb3VyY2VQYXRoLCBkZXN0aW5hdGlvblBhdGgsIHtta2RpcnA6IGZhbHNlfSwgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSB3cml0ZUZpbGUgZW5kcG9pbnQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHF1ZXJ5IHBhcmFtZXRlcnM6XG4gKlxuICogICBwYXRoOiBwYXRoIHRvIHRoZSBmaWxlIHRvIHJlYWQgKGl0IG11c3QgYmUgdXJsIGVuY29kZWQpLlxuICogICBvcHRpb25zOiBvcHRpb25zIHRvIHBhc3MgdG8gZnMud3JpdGVGaWxlXG4gKlxuICogVE9ETzogbW92ZSB0byBudWNsaWRlLWNvbW1vbnMgYW5kIHJlbmFtZSB0byB3cml0ZUZpbGVBdG9taWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZShwYXRoOiBzdHJpbmcsIGRhdGE6IHN0cmluZyxcbiAgICBvcHRpb25zOiA/e2VuY29kaW5nPzogc3RyaW5nOyBtb2RlPzogbnVtYmVyOyBmbGFnPzpzdHJpbmd9KTogUHJvbWlzZTx2b2lkPiB7XG5cbiAgbGV0IGNvbXBsZXRlID0gZmFsc2U7XG4gIGNvbnN0IHRlbXBGaWxlUGF0aCA9IGF3YWl0IGZzUHJvbWlzZS50ZW1wZmlsZSgnbnVjbGlkZScpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzUHJvbWlzZS53cml0ZUZpbGUodGVtcEZpbGVQYXRoLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIC8vIEVuc3VyZSBmaWxlIHN0aWxsIGhhcyBvcmlnaW5hbCBwZXJtaXNzaW9uczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svbnVjbGlkZS9pc3N1ZXMvMTU3XG4gICAgLy8gV2UgdXBkYXRlIHRoZSBtb2RlIG9mIHRoZSB0ZW1wIGZpbGUgcmF0aGVyIHRoYW4gdGhlIGRlc3RpbmF0aW9uIGZpbGUgYmVjYXVzZVxuICAgIC8vIGlmIHdlIGRpZCB0aGUgbXYoKSB0aGVuIHRoZSBjaG1vZCgpLCB0aGVyZSB3b3VsZCBiZSBhIGJyaWVmIHBlcmlvZCBiZXR3ZWVuXG4gICAgLy8gdGhvc2UgdHdvIG9wZXJhdGlvbnMgd2hlcmUgdGhlIGRlc3RpbmF0aW9uIGZpbGUgbWlnaHQgaGF2ZSB0aGUgd3JvbmcgcGVybWlzc2lvbnMuXG4gICAgbGV0IHBlcm1pc3Npb25zID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcGVybWlzc2lvbnMgPSAoYXdhaXQgZnNQcm9taXNlLnN0YXQocGF0aCkpLm1vZGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QsIHRoZW4gRU5PRU5UIHdpbGwgYmUgdGhyb3duLlxuICAgICAgaWYgKGUuY29kZSAhPT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBlcm1pc3Npb25zICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IGZzUHJvbWlzZS5jaG1vZCh0ZW1wRmlsZVBhdGgsIHBlcm1pc3Npb25zKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKG1pa2VvKTogcHV0IHJlbmFtZXMgaW50byBhIHF1ZXVlIHNvIHdlIGRvbid0IHdyaXRlIG9sZGVyIHNhdmUgb3ZlciBuZXcgc2F2ZS5cbiAgICAvLyBVc2UgbXYgYXMgZnMucmVuYW1lIGRvZXNuJ3Qgd29yayBhY3Jvc3MgcGFydGl0aW9ucy5cbiAgICBhd2FpdCBtdlByb21pc2UodGVtcEZpbGVQYXRoLCBwYXRoKTtcbiAgICBjb21wbGV0ZSA9IHRydWU7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgYXdhaXQgZnNQcm9taXNlLnVubGluayh0ZW1wRmlsZVBhdGgpO1xuICAgIH1cbiAgfVxufVxuIl19
