Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _utils = require('./utils');

var _eventKit = require('event-kit');

var _DbgpMessageHandler = require('./DbgpMessageHandler');

var _ConnectionUtils = require('./ConnectionUtils');

/**
 * xdebugPort is the port to listen for dbgp connections on.
 *
 * If present scriptRegex must be a valid RegExp. Only dbgp connections whose script
 * path matches scriptRegex will be accepted. Dbgp connections which do not match
 * the scriptRegex will be ignored.
 *
 * Similarly, the idekeyRegex filters incoming dbgp connections by idekey,
 * and pid filters connections by process id (appid in the dbgp terminology).
 * Note that 0 pid also does not filter on process id.
 */
'use babel';

var DBGP_ATTACH_EVENT = 'dbgp-attach-event';
var DBGP_CLOSE_EVENT = 'dbgp-close-event';
var DBGP_ERROR_EVENT = 'dbgp-error-event';

/**
 * Connect to requested dbgp debuggee on given port.
 *
 * Starts listening for socket connections on the given port.
 * Waits for dbgp init connection message for each connection.
 * If the connection matches the given pid/ideky/path then
 * resolve with the connection and stop listening for new
 * connections.
 * If the connection does not match the given pid/idekey/path
 * then close the connection and continue waiting for a match.
 */

var DbgpConnector = (function () {
  function DbgpConnector(config) {
    _classCallCheck(this, DbgpConnector);

    this._config = config;
    this._server = null;
    this._emitter = new _eventKit.Emitter();
    this._messageHandler = (0, _DbgpMessageHandler.getDbgpMessageHandlerInstance)();
  }

  _createClass(DbgpConnector, [{
    key: 'onAttach',
    value: function onAttach(callback) {
      return this._emitter.on(DBGP_ATTACH_EVENT, callback);
    }
  }, {
    key: 'onClose',
    value: function onClose(callback) {
      return this._emitter.on(DBGP_CLOSE_EVENT, callback);
    }
  }, {
    key: 'onError',
    value: function onError(callback) {
      return this._emitter.on(DBGP_ERROR_EVENT, callback);
    }
  }, {
    key: 'listen',
    value: function listen() {
      var _this = this;

      var port = this._config.xdebugPort;

      (0, _utils.log)('Creating debug server on port ' + port);

      var server = require('net').createServer();

      server.on('close', function (socket) {
        return (0, _utils.log)('Closing port ' + port);
      });
      server.listen(port, function () {
        return (0, _utils.log)('Listening on port ' + port);
      });

      server.on('error', function (error) {
        return _this._onServerError(error);
      });
      server.on('connection', function (socket) {
        return _this._onSocketConnection(socket);
      });
      server.on('close', function () {
        (0, _utils.log)('DBGP Server closed.');
      });

      this._server = server;
    }
  }, {
    key: '_onSocketConnection',
    value: function _onSocketConnection(socket) {
      var _this2 = this;

      var port = this._config.xdebugPort;

      (0, _utils.log)('Connection on port ' + port);
      if (!this._checkListening(socket, 'Connection')) {
        return;
      }
      socket.once('data', function (data) {
        return _this2._onSocketData(socket, data);
      });
    }
  }, {
    key: '_onServerError',
    value: function _onServerError(error) {
      var port = this._config.xdebugPort;

      var errorMessage = undefined;
      if (error.code === 'EADDRINUSE') {
        errorMessage = 'Can\'t start debugging because port ' + port + ' is being used by another process. ' + 'Try running \'killall node\' on your devserver and then restarting Nuclide.';
      } else {
        errorMessage = 'Unknown debugger socket error: ' + error.code + '.';
      }

      (0, _utils.logError)(errorMessage);
      this._emitter.emit(DBGP_ERROR_EVENT, errorMessage);

      this.dispose();
    }
  }, {
    key: '_onSocketData',
    value: function _onSocketData(socket, data) {
      if (!this._checkListening(socket, 'Data')) {
        return;
      }

      var messages = undefined;
      try {
        messages = this._messageHandler.parseMessages(data.toString());
      } catch (error) {
        (0, _ConnectionUtils.failConnection)(socket, 'Non XML connection string: ' + data.toString() + '. Discarding connection.');
        return;
      }

      if (messages.length !== 1) {
        (0, _ConnectionUtils.failConnection)(socket, 'Expected a single connection message. Got ' + messages.length);
        return;
      }

      var message = messages[0];
      this._emitter.emit(DBGP_ATTACH_EVENT, { socket: socket, message: message });
    }

    /**
     * Checks if listening for connections. If not then close the new socket.
     */
  }, {
    key: '_checkListening',
    value: function _checkListening(socket, message) {
      if (!this.isListening()) {
        var port = this._config.xdebugPort;
        (0, _utils.log)('Ignoring ' + message + ' on port ' + port + ' after stopped connection.');
        return false;
      }
      return true;
    }
  }, {
    key: 'isListening',
    value: function isListening() {
      return !!this._server;
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      if (this._server) {
        this._server.close();
        this._emitter.emit(DBGP_CLOSE_EVENT);
        this._server = null;
      }
    }
  }]);

  return DbgpConnector;
})();

exports.DbgpConnector = DbgpConnector;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWRlYnVnZ2VyLWhodm0tcHJveHkvbGliL0RiZ3BDb25uZWN0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztxQkFXNEIsU0FBUzs7d0JBQ2YsV0FBVzs7a0NBQytCLHNCQUFzQjs7K0JBQ3pELG1CQUFtQjs7Ozs7Ozs7Ozs7OztBQWRoRCxXQUFXLENBQUM7O0FBdUNaLElBQU0saUJBQWlCLEdBQUcsbUJBQW1CLENBQUM7QUFDOUMsSUFBTSxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQztBQUM1QyxJQUFNLGdCQUFnQixHQUFHLGtCQUFrQixDQUFDOzs7Ozs7Ozs7Ozs7OztJQWEvQixhQUFhO0FBTWIsV0FOQSxhQUFhLENBTVosTUFBd0IsRUFBRTswQkFOM0IsYUFBYTs7QUFPdEIsUUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdEIsUUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDcEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxjQW5EWixPQUFPLEVBbURrQixDQUFDO0FBQzlCLFFBQUksQ0FBQyxlQUFlLEdBQUcsd0JBbkRDLDZCQUE2QixHQW1EQyxDQUFDO0dBQ3hEOztlQVhVLGFBQWE7O1dBYWhCLGtCQUFDLFFBQWdFLEVBQWM7QUFDckYsYUFBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUN0RDs7O1dBRU0saUJBQUMsUUFBb0IsRUFBYztBQUN4QyxhQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ3JEOzs7V0FFTSxpQkFBQyxRQUFvQixFQUFjO0FBQ3hDLGFBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMs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QUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUN6Qiw2QkE3SEUsY0FBYyxFQTZIRCxNQUFNLEVBQUUsNENBQTRDLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZGLGVBQU87T0FDUjs7QUFFRCxVQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUIsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBQyxNQUFNLEVBQU4sTUFBTSxFQUFFLE9BQU8sRUFBUCxPQUFPLEVBQUMsQ0FBQyxDQUFDO0tBQzFEOzs7Ozs7O1dBS2MseUJBQUMsTUFBYyxFQUFFLE9BQWUsRUFBVztBQUN4RCxVQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO0FBQ3ZCLFlBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ3JDLG1CQTlJRSxHQUFHLEVBOElELFdBQVcsR0FBRyxPQUFPLEdBQUcsV0FBVyxHQUFHLElBQUksR0FBRyw0QkFBNEIsQ0FBQyxDQUFDO0FBQy9FLGVBQU8sS0FBSyxDQUFDO09BQ2Q7QUFDRCxhQUFPLElBQUksQ0FBQztLQUNiOzs7V0FFVSx1QkFBWTtBQUNyQixhQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0tBQ3ZCOzs7V0FFTSxtQkFBRztBQUNSLFVBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNoQixZQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3JCLFlBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDckMsWUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7T0FDckI7S0FDRjs7O1NBbkhVLGFBQWEiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcHBmbDUybnB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtZGVidWdnZXItaGh2bS1wcm94eS9saWIvRGJncENvbm5lY3Rvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7bG9nLCBsb2dFcnJvcn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge0VtaXR0ZXJ9IGZyb20gJ2V2ZW50LWtpdCc7XG5pbXBvcnQge0RiZ3BNZXNzYWdlSGFuZGxlciwgZ2V0RGJncE1lc3NhZ2VIYW5kbGVySW5zdGFuY2V9IGZyb20gJy4vRGJncE1lc3NhZ2VIYW5kbGVyJztcbmltcG9ydCB7ZmFpbENvbm5lY3Rpb259IGZyb20gJy4vQ29ubmVjdGlvblV0aWxzJztcblxuaW1wb3J0IHR5cGUge1NvY2tldCwgU2VydmVyfSBmcm9tICduZXQnO1xuXG4vKipcbiAqIHhkZWJ1Z1BvcnQgaXMgdGhlIHBvcnQgdG8gbGlzdGVuIGZvciBkYmdwIGNvbm5lY3Rpb25zIG9uLlxuICpcbiAqIElmIHByZXNlbnQgc2NyaXB0UmVnZXggbXVzdCBiZSBhIHZhbGlkIFJlZ0V4cC4gT25seSBkYmdwIGNvbm5lY3Rpb25zIHdob3NlIHNjcmlwdFxuICogcGF0aCBtYXRjaGVzIHNjcmlwdFJlZ2V4IHdpbGwgYmUgYWNjZXB0ZWQuIERiZ3AgY29ubmVjdGlvbnMgd2hpY2ggZG8gbm90IG1hdGNoXG4gKiB0aGUgc2NyaXB0UmVnZXggd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIFNpbWlsYXJseSwgdGhlIGlkZWtleVJlZ2V4IGZpbHRlcnMgaW5jb21pbmcgZGJncCBjb25uZWN0aW9ucyBieSBpZGVrZXksXG4gKiBhbmQgcGlkIGZpbHRlcnMgY29ubmVjdGlvbnMgYnkgcHJvY2VzcyBpZCAoYXBwaWQgaW4gdGhlIGRiZ3AgdGVybWlub2xvZ3kpLlxuICogTm90ZSB0aGF0IDAgcGlkIGFsc28gZG9lcyBub3QgZmlsdGVyIG9uIHByb2Nlc3MgaWQuXG4gKi9cbmV4cG9ydCB0eXBlIENvbm5lY3Rpb25Db25maWcgPSB7XG4gIHhkZWJ1Z1BvcnQ6IG51bWJlcjtcbiAgcGlkOiA/bnVtYmVyO1xuICBzY3JpcHRSZWdleDogP3N0cmluZztcbiAgaWRla2V5UmVnZXg6ID9zdHJpbmc7XG4gIGVuZERlYnVnV2hlbk5vUmVxdWVzdHM6IGJvb2xlYW47XG4gIGxvZ0xldmVsOiBzdHJpbmc7XG4gIHRhcmdldFVyaTogc3RyaW5nO1xufTtcblxuY29uc3QgREJHUF9BVFRBQ0hfRVZFTlQgPSAnZGJncC1hdHRhY2gtZXZlbnQnO1xuY29uc3QgREJHUF9DTE9TRV9FVkVOVCA9ICdkYmdwLWNsb3NlLWV2ZW50JztcbmNvbnN0IERCR1BfRVJST1JfRVZFTlQgPSAnZGJncC1lcnJvci1ldmVudCc7XG5cbi8qKlxuICogQ29ubmVjdCB0byByZXF1ZXN0ZWQgZGJncCBkZWJ1Z2dlZSBvbiBnaXZlbiBwb3J0LlxuICpcbiAqIFN0YXJ0cyBsaXN0ZW5pbmcgZm9yIHNvY2tldCBjb25uZWN0aW9ucyBvbiB0aGUgZ2l2ZW4gcG9ydC5cbiAqIFdhaXRzIGZvciBkYmdwIGluaXQgY29ubmVjdGlvbiBtZXNzYWdlIGZvciBlYWNoIGNvbm5lY3Rpb24uXG4gKiBJZiB0aGUgY29ubmVjdGlvbiBtYXRjaGVzIHRoZSBnaXZlbiBwaWQvaWRla3kvcGF0aCB0aGVuXG4gKiByZXNvbHZlIHdpdGggdGhlIGNvbm5lY3Rpb24gYW5kIHN0b3AgbGlzdGVuaW5nIGZvciBuZXdcbiAqIGNvbm5lY3Rpb25zLlxuICogSWYgdGhlIGNvbm5lY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIGdpdmVuIHBpZC9pZGVrZXkvcGF0aFxuICogdGhlbiBjbG9zZSB0aGUgY29ubmVjdGlvbiBhbmQgY29udGludWUgd2FpdGluZyBmb3IgYSBtYXRjaC5cbiAqL1xuZXhwb3J0IGNsYXNzIERiZ3BDb25uZWN0b3Ige1xuICBfY29uZmlnOiBDb25uZWN0aW9uQ29uZmlnO1xuICBfc2VydmVyOiA/U2VydmVyO1xuICBfZW1pdHRlcjogRW1pdHRlcjtcbiAgX21lc3NhZ2VIYW5kbGVyOiBEYmdwTWVzc2FnZUhhbmRsZXI7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBDb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBnZXREYmdwTWVzc2FnZUhhbmRsZXJJbnN0YW5jZSgpO1xuICB9XG5cbiAgb25BdHRhY2goY2FsbGJhY2s6IChwYXJhbXM6IHtzb2NrZXQ6IFNvY2tldCwgbWVzc2FnZTogT2JqZWN0fSkgPT4gUHJvbWlzZSk6IERpc3Bvc2FibGUge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLm9uKERCR1BfQVRUQUNIX0VWRU5ULCBjYWxsYmFjayk7XG4gIH1cblxuICBvbkNsb3NlKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogRGlzcG9zYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIub24oREJHUF9DTE9TRV9FVkVOVCwgY2FsbGJhY2spO1xuICB9XG5cbiAgb25FcnJvcihjYWxsYmFjazogKCkgPT4gdm9pZCk6IERpc3Bvc2FibGUge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLm9uKERCR1BfRVJST1JfRVZFTlQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGxpc3RlbigpOiB2b2lkIHtcbiAgICBjb25zdCBwb3J0ID0gdGhpcy5fY29uZmlnLnhkZWJ1Z1BvcnQ7XG5cbiAgICBsb2coJ0NyZWF0aW5nIGRlYnVnIHNlcnZlciBvbiBwb3J0ICcgKyBwb3J0KTtcblxuICAgIGNvbnN0IHNlcnZlciA9IHJlcXVpcmUoJ25ldCcpLmNyZWF0ZVNlcnZlcigpO1xuXG4gICAgc2VydmVyLm9uKCdjbG9zZScsIHNvY2tldCA9PiBsb2coJ0Nsb3NpbmcgcG9ydCAnICsgcG9ydCkpO1xuICAgIHNlcnZlci5saXN0ZW4ocG9ydCwgKCkgPT4gbG9nKCdMaXN0ZW5pbmcgb24gcG9ydCAnICsgcG9ydCkpO1xuXG4gICAgc2VydmVyLm9uKCdlcnJvcicsIGVycm9yID0+IHRoaXMuX29uU2VydmVyRXJyb3IoZXJyb3IpKTtcbiAgICBzZXJ2ZXIub24oJ2Nvbm5lY3Rpb24nLCBzb2NrZXQgPT4gdGhpcy5fb25Tb2NrZXRDb25uZWN0aW9uKHNvY2tldCkpO1xuICAgIHNlcnZlci5vbignY2xvc2UnLCAoKSA9PiB7IGxvZygnREJHUCBTZXJ2ZXIgY2xvc2VkLicpOyB9KTtcblxuICAgIHRoaXMuX3NlcnZlciA9IHNlcnZlcjtcbiAgfVxuXG4gIF9vblNvY2tldENvbm5lY3Rpb24oc29ja2V0OiBTb2NrZXQpIHtcbiAgICBjb25zdCBwb3J0ID0gdGhpcy5fY29uZmlnLnhkZWJ1Z1BvcnQ7XG5cbiAgICBsb2coJ0Nvbm5lY3Rpb24gb24gcG9ydCAnICsgcG9ydCk7XG4gICAgaWYgKCF0aGlzLl9jaGVja0xpc3RlbmluZyhzb2NrZXQsICdDb25uZWN0aW9uJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc29ja2V0Lm9uY2UoJ2RhdGEnLCBkYXRhID0+IHRoaXMuX29uU29ja2V0RGF0YShzb2NrZXQsIGRhdGEpKTtcbiAgfVxuXG4gIF9vblNlcnZlckVycm9yKGVycm9yOiBPYmplY3QpOiB2b2lkIHtcbiAgICBjb25zdCBwb3J0ID0gdGhpcy5fY29uZmlnLnhkZWJ1Z1BvcnQ7XG5cbiAgICBsZXQgZXJyb3JNZXNzYWdlO1xuICAgIGlmIChlcnJvci5jb2RlID09PSAnRUFERFJJTlVTRScpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBDYW4ndCBzdGFydCBkZWJ1Z2dpbmcgYmVjYXVzZSBwb3J0ICR7cG9ydH0gaXMgYmVpbmcgdXNlZCBieSBhbm90aGVyIHByb2Nlc3MuIGBcbiAgICAgICAgKyBgVHJ5IHJ1bm5pbmcgJ2tpbGxhbGwgbm9kZScgb24geW91ciBkZXZzZXJ2ZXIgYW5kIHRoZW4gcmVzdGFydGluZyBOdWNsaWRlLmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBVbmtub3duIGRlYnVnZ2VyIHNvY2tldCBlcnJvcjogJHtlcnJvci5jb2RlfS5gO1xuICAgIH1cblxuICAgIGxvZ0Vycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgdGhpcy5fZW1pdHRlci5lbWl0KERCR1BfRVJST1JfRVZFTlQsIGVycm9yTWVzc2FnZSk7XG5cbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIF9vblNvY2tldERhdGEoc29ja2V0OiBTb2NrZXQsIGRhdGE6IEJ1ZmZlciB8IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fY2hlY2tMaXN0ZW5pbmcoc29ja2V0LCAnRGF0YScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG1lc3NhZ2VzO1xuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlcyA9IHRoaXMuX21lc3NhZ2VIYW5kbGVyLnBhcnNlTWVzc2FnZXMoZGF0YS50b1N0cmluZygpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZmFpbENvbm5lY3Rpb24oXG4gICAgICAgIHNvY2tldCxcbiAgICAgICAgJ05vbiBYTUwgY29ubmVjdGlvbiBzdHJpbmc6ICcgKyBkYXRhLnRvU3RyaW5nKCkgKyAnLiBEaXNjYXJkaW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgZmFpbENvbm5lY3Rpb24oc29ja2V0LCAnRXhwZWN0ZWQgYSBzaW5nbGUgY29ubmVjdGlvbiBtZXNzYWdlLiBHb3QgJyArIG1lc3NhZ2VzLmxlbmd0aCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzWzBdO1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChEQkdQX0FUVEFDSF9FVkVOVCwge3NvY2tldCwgbWVzc2FnZX0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBsaXN0ZW5pbmcgZm9yIGNvbm5lY3Rpb25zLiBJZiBub3QgdGhlbiBjbG9zZSB0aGUgbmV3IHNvY2tldC5cbiAgICovXG4gIF9jaGVja0xpc3RlbmluZyhzb2NrZXQ6IFNvY2tldCwgbWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgIGNvbnN0IHBvcnQgPSB0aGlzLl9jb25maWcueGRlYnVnUG9ydDtcbiAgICAgIGxvZygnSWdub3JpbmcgJyArIG1lc3NhZ2UgKyAnIG9uIHBvcnQgJyArIHBvcnQgKyAnIGFmdGVyIHN0b3BwZWQgY29ubmVjdGlvbi4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc0xpc3RlbmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9zZXJ2ZXI7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlci5jbG9zZSgpO1xuICAgICAgdGhpcy5fZW1pdHRlci5lbWl0KERCR1BfQ0xPU0VfRVZFTlQpO1xuICAgICAgdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==
