var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _findClangServerArgs = _asyncToGenerator(function* () {
  var findClangServerArgs = undefined;
  try {
    findClangServerArgs = require('./fb/find-clang-server-args');
  } catch (e) {
    // Ignore.
  }

  var libClangLibraryFile = undefined;
  if (process.platform === 'darwin') {
    var result = yield checkOutput('xcode-select', ['--print-path']);
    if (result.exitCode === 0) {
      libClangLibraryFile = result.stdout.trim() + '/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib';
    }
  }

  var clangServerArgs = {
    libClangLibraryFile: libClangLibraryFile,
    pythonExecutable: 'python',
    pythonPathEnv: path.join(__dirname, '../pythonpath')
  };
  if (typeof findClangServerArgs === 'function') {
    var clangServerArgsOverrides = yield findClangServerArgs();
    return _extends({}, clangServerArgs, clangServerArgsOverrides);
  } else {
    return clangServerArgs;
  }
});

var createAsyncConnection = _asyncToGenerator(function* (pathToLibClangServer) {
  // $FlowIssue D2268946
  return yield new Promise(_asyncToGenerator(function* (resolve, reject) {
    var _ref = yield _findClangServerArgs();

    var libClangLibraryFile = _ref.libClangLibraryFile;
    var pythonPathEnv = _ref.pythonPathEnv;
    var pythonExecutable = _ref.pythonExecutable;

    var options = {
      cwd: path.dirname(pathToLibClangServer),
      // The process should use its ordinary stderr for errors.
      stdio: ['pipe', null, 'pipe', 'pipe'],
      detached: false, // When Atom is killed, clang_server.py should be killed, too.
      env: {
        // On Mac OSX El Capitan, bash seems to wipe out the `LD_LIBRARY_PATH` and
        // `DYLD_LIBRARY_PATH` environment variables. So, set this env var which is read by
        // clang_server.py to explicitly set the file path to load.
        LIB_CLANG_LIBRARY_FILE: libClangLibraryFile,
        PYTHONPATH: pythonPathEnv
      }
    };

    // Note that safeSpawn() often overrides options.env.PATH, but that only happens when
    // options.env is undefined (which is not the case here). This will only be an issue if the
    // system cannot find `pythonExecutable`.
    var child = yield safeSpawn(pythonExecutable, /* args */[pathToLibClangServer], options);
    child.on('close', function (exitCode) {
      logger.error('%s exited with code %s', pathToLibClangServer, exitCode);
    });
    child.stderr.on('data', function (error) {
      if (error instanceof Buffer) {
        error = error.toString('utf8');
      }
      logger.error('Error receiving data', error);
    });
    /* $FlowFixMe - update Flow defs for ChildProcess */
    var writableStream = child.stdio[3];

    // Make sure the bidirectional communication channel is set up before
    // resolving this Promise.
    child.stdout.once('data', function (data) {
      if (data.toString() === 'ack\n') {
        var result = {
          readableStream: child.stdout,
          writableStream: writableStream
        };
        resolve(result);
      } else {
        reject(data);
      }
    });
    writableStream.write('init\n');
  }));
}

/**
 * Nuclide runs clang in its own process. For simplicity, it is run as a Python
 * program, as Python has a nice libclang wrapper.
 */
);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _nuclideBuckBaseLibBuckUtils = require('nuclide-buck-base/lib/BuckUtils');

'use babel';

var _require = require('nuclide-commons');

var checkOutput = _require.checkOutput;
var fsPromise = _require.fsPromise;
var safeSpawn = _require.safeSpawn;

var logger = require('nuclide-logging').getLogger();
var path = require('path');
var split = require('split');

var _require2 = require('events');

var EventEmitter = _require2.EventEmitter;

var ClangFlagsManager = require('./ClangFlagsManager');
var ClangService = require('./ClangService');

var LocalClangService = (function (_ClangService) {
  _inherits(LocalClangService, _ClangService);

  function LocalClangService() {
    _classCallCheck(this, LocalClangService);

    _get(Object.getPrototypeOf(LocalClangService.prototype), 'constructor', this).call(this);
    this._asyncConnection = null;
    this._clangFlagsManager = new ClangFlagsManager(new _nuclideBuckBaseLibBuckUtils.BuckUtils());
    this._readableStream = null;
    this._writableStream = null;
    this._nextRequestId = 1;
    this._pathToLibClangServer = path.join(__dirname, '../python/clang_server.py');
    this._emitter = new EventEmitter();
  }

  _createClass(LocalClangService, [{
    key: '_connect',
    value: function _connect() {
      var _this = this;

      var asyncConnection = this._asyncConnection;
      if (asyncConnection == null) {
        asyncConnection = createAsyncConnection(this._pathToLibClangServer).then(function (connection) {
          var readableStream = connection.readableStream;
          var writableStream = connection.writableStream;

          _this._readableStream = readableStream;
          _this._writableStream = writableStream;
          readableStream.pipe(split(JSON.parse)).on('data', function (response) {
            var id = response['reqid'];
            _this._emitter.emit(id, response);
          });
        }, function (error) {
          // If an error occurs, clear out `this._asyncConnection`, so that if `_connect()` is
          // called again, we make a new attempt to create a connection,
          // rather than holding onto a rejected Promise indefinitely.
          _this._asyncConnection = null;
        });
      }
      this._asyncConnection = asyncConnection;
      return asyncConnection;
    }
  }, {
    key: '_makeRequest',
    value: _asyncToGenerator(function* (request) {
      var _this2 = this;

      yield this._connect();

      var id = request['reqid'] = this._getNextRequestId();
      var logData = JSON.stringify(request, function (key, value) {
        // File contents are too large and clutter up the logs, so exclude them.
        if (key === 'contents') {
          return undefined;
        } else {
          return value;
        }
      });
      logger.debug('LibClang request: ' + logData);
      var writableStream = this._writableStream;
      if (writableStream == null) {
        return;
      }
      // Because Node uses an event-loop, we do not have to worry about a call to
      // write() coming in from another thread between our two calls here.
      writableStream.write(JSON.stringify(request));
      writableStream.write('\n');

      return new Promise(function (resolve, reject) {
        _this2._emitter.once(id, function (response) {
          var isError = ('error' in response);
          if (isError) {
            logger.error('error received from clang_server.py for request:\n%o\nError:%s', logData, response['error']);
          }
          (isError ? reject : resolve)(response);
        });
      });
    })
  }, {
    key: '_getNextRequestId',
    value: function _getNextRequestId() {
      return (this._nextRequestId++).toString(16);
    }
  }, {
    key: 'compile',
    value: _asyncToGenerator(function* (src, contents) {
      var flags = yield this._clangFlagsManager.getFlagsForSrc(src);
      return this._makeRequest({
        method: 'compile',
        src: src,
        contents: contents,
        flags: flags
      });
    })
  }, {
    key: 'getCompletions',
    value: _asyncToGenerator(function* (src, contents, line, column, tokenStartColumn, prefix) {
      var flags = yield this._clangFlagsManager.getFlagsForSrc(src);
      return this._makeRequest({
        method: 'get_completions',
        src: src,
        contents: contents,
        line: line,
        column: column,
        tokenStartColumn: tokenStartColumn,
        prefix: prefix,
        flags: flags
      });
    })

    /**
     * @return An Object with the following fields:
     *   file: NuclideUri of the source file where the declaration is.
     *   line: The line number of the declaration within `file`.
     *   column: The column number of the declaration within `file`.
     *   spelling: The spelling of the entity.
     */
  }, {
    key: 'getDeclaration',
    value: _asyncToGenerator(function* (src, contents, line, column) {
      var flags = yield this._clangFlagsManager.getFlagsForSrc(src);
      var data = yield this._makeRequest({
        method: 'get_declaration',
        src: src,
        contents: contents,
        line: line,
        column: column,
        flags: flags
      });

      var locationAndSpelling = data.locationAndSpelling;

      if (!locationAndSpelling) {
        return null;
      }

      var state = yield fsPromise.lstat(locationAndSpelling.file);
      if (state.isSymbolicLink()) {
        locationAndSpelling.file = yield fsPromise.readlink(locationAndSpelling.file);
      }

      return locationAndSpelling;
    })
  }, {
    key: 'getDeclarationInfo',
    value: _asyncToGenerator(function* (src, contents, line, column) {
      var flags = yield this._clangFlagsManager.getFlagsForSrc(src);
      return this._makeRequest({
        method: 'get_declaration_info',
        src: src,
        contents: contents,
        line: line,
        column: column,
        flags: flags
      });
    })
  }]);

  return LocalClangService;
})(ClangService);

module.exports = LocalClangService;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNsYW5nL2xpYi9Mb2NhbENsYW5nU2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7SUF1QmUsb0JBQW9CLHFCQUFuQyxhQUlHO0FBQ0QsTUFBSSxtQkFBbUIsWUFBQSxDQUFDO0FBQ3hCLE1BQUk7QUFDRix1QkFBbUIsR0FBRyxPQUFPLENBQUMsNkJBQTZCLENBQUMsQ0FBQztHQUM5RCxDQUFDLE9BQU8sQ0FBQyxFQUFFOztHQUVYOztBQUVELE1BQUksbUJBQW1CLFlBQUEsQ0FBQztBQUN4QixNQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO0FBQ2pDLFFBQU0sTUFBTSxHQUFHLE1BQU0sV0FBVyxDQUFDLGNBQWMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7QUFDbkUsUUFBSSxNQUFNLENBQUMsUUFBUSxLQUFLLENBQUMsRUFBRTtBQUN6Qix5QkFBbUIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxHQUN4Qyw2REFBNkQsQ0FBQztLQUNqRTtHQUNGOztBQUVELE1BQU0sZUFBZSxHQUFHO0FBQ3RCLHVCQUFtQixFQUFuQixtQkFBbUI7QUFDbkIsb0JBQWdCLEVBQUUsUUFBUTtBQUMxQixpQkFBYSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGVBQWUsQ0FBQztHQUNyRCxDQUFDO0FBQ0YsTUFBSSxPQUFPLG1CQUFtQixLQUFLLFVBQVUsRUFBRTtBQUM3QyxRQUFNLHdCQUF3QixHQUFHLE1BQU0sbUJBQW1CLEVBQUUsQ0FBQztBQUM3RCx3QkFBVyxlQUFlLEVBQUssd0JBQXdCLEVBQUU7R0FDMUQsTUFBTTtBQUNMLFdBQU8sZUFBZSxDQUFDO0dBQ3hCO0NBQ0Y7O0lBT2MscUJBQXFCLHFCQUFwQyxXQUFxQyxvQkFBNEIs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TUFBTSxDQUFDLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wcGZsNTJucHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1jbGFuZy9saWIvTG9jYWxDbGFuZ1NlcnZpY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7TnVjbGlkZVVyaSwgRGVjbGFyYXRpb25JbmZvLCBDbGFuZ0N1cnNvckV4dGVudH0gZnJvbSAnLi9tYWluJztcblxuY29uc3Qge2NoZWNrT3V0cHV0LCBmc1Byb21pc2UsIHNhZmVTcGF3bn0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHNwbGl0ID0gcmVxdWlyZSgnc3BsaXQnKTtcbmNvbnN0IHtFdmVudEVtaXR0ZXJ9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBDbGFuZ0ZsYWdzTWFuYWdlciA9IHJlcXVpcmUoJy4vQ2xhbmdGbGFnc01hbmFnZXInKTtcbmNvbnN0IENsYW5nU2VydmljZSA9IHJlcXVpcmUoJy4vQ2xhbmdTZXJ2aWNlJyk7XG5pbXBvcnQge0J1Y2tVdGlsc30gZnJvbSAnbnVjbGlkZS1idWNrLWJhc2UvbGliL0J1Y2tVdGlscyc7XG5cblxuYXN5bmMgZnVuY3Rpb24gX2ZpbmRDbGFuZ1NlcnZlckFyZ3MoKTogUHJvbWlzZTx7XG4gIGxpYkNsYW5nTGlicmFyeUZpbGU6ID9zdHJpbmc7XG4gIHB5dGhvbkV4ZWN1dGFibGU6IHN0cmluZztcbiAgcHl0aG9uUGF0aEVudjogP3N0cmluZztcbn0+IHtcbiAgbGV0IGZpbmRDbGFuZ1NlcnZlckFyZ3M7XG4gIHRyeSB7XG4gICAgZmluZENsYW5nU2VydmVyQXJncyA9IHJlcXVpcmUoJy4vZmIvZmluZC1jbGFuZy1zZXJ2ZXItYXJncycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLlxuICB9XG5cbiAgbGV0IGxpYkNsYW5nTGlicmFyeUZpbGU7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrT3V0cHV0KCd4Y29kZS1zZWxlY3QnLCBbJy0tcHJpbnQtcGF0aCddKTtcbiAgICBpZiAocmVzdWx0LmV4aXRDb2RlID09PSAwKSB7XG4gICAgICBsaWJDbGFuZ0xpYnJhcnlGaWxlID0gcmVzdWx0LnN0ZG91dC50cmltKCkgK1xuICAgICAgICAnL1Rvb2xjaGFpbnMvWGNvZGVEZWZhdWx0LnhjdG9vbGNoYWluL3Vzci9saWIvbGliY2xhbmcuZHlsaWInO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNsYW5nU2VydmVyQXJncyA9IHtcbiAgICBsaWJDbGFuZ0xpYnJhcnlGaWxlLFxuICAgIHB5dGhvbkV4ZWN1dGFibGU6ICdweXRob24nLFxuICAgIHB5dGhvblBhdGhFbnY6IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9weXRob25wYXRoJyksXG4gIH07XG4gIGlmICh0eXBlb2YgZmluZENsYW5nU2VydmVyQXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNsYW5nU2VydmVyQXJnc092ZXJyaWRlcyA9IGF3YWl0IGZpbmRDbGFuZ1NlcnZlckFyZ3MoKTtcbiAgICByZXR1cm4gey4uLmNsYW5nU2VydmVyQXJncywgLi4uY2xhbmdTZXJ2ZXJBcmdzT3ZlcnJpZGVzfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2xhbmdTZXJ2ZXJBcmdzO1xuICB9XG59XG5cbnR5cGUgQ29ubmVjdGlvbiA9IHtcbiAgcmVhZGFibGVTdHJlYW06IGFueSxcbiAgd3JpdGFibGVTdHJlYW06IGFueSxcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQXN5bmNDb25uZWN0aW9uKHBhdGhUb0xpYkNsYW5nU2VydmVyOiBzdHJpbmcpOiBQcm9taXNlPENvbm5lY3Rpb24+IHtcbiAgLy8gJEZsb3dJc3N1ZSBEMjI2ODk0NlxuICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHtsaWJDbGFuZ0xpYnJhcnlGaWxlLCBweXRob25QYXRoRW52LCBweXRob25FeGVjdXRhYmxlfSA9IGF3YWl0IF9maW5kQ2xhbmdTZXJ2ZXJBcmdzKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGN3ZDogcGF0aC5kaXJuYW1lKHBhdGhUb0xpYkNsYW5nU2VydmVyKSxcbiAgICAgIC8vIFRoZSBwcm9jZXNzIHNob3VsZCB1c2UgaXRzIG9yZGluYXJ5IHN0ZGVyciBmb3IgZXJyb3JzLlxuICAgICAgc3RkaW86IFsncGlwZScsIG51bGwsICdwaXBlJywgJ3BpcGUnXSxcbiAgICAgIGRldGFjaGVkOiBmYWxzZSwgLy8gV2hlbiBBdG9tIGlzIGtpbGxlZCwgY2xhbmdfc2VydmVyLnB5IHNob3VsZCBiZSBraWxsZWQsIHRvby5cbiAgICAgIGVudjoge1xuICAgICAgICAvLyBPbiBNYWMgT1NYIEVsIENhcGl0YW4sIGJhc2ggc2VlbXMgdG8gd2lwZSBvdXQgdGhlIGBMRF9MSUJSQVJZX1BBVEhgIGFuZFxuICAgICAgICAvLyBgRFlMRF9MSUJSQVJZX1BBVEhgIGVudmlyb25tZW50IHZhcmlhYmxlcy4gU28sIHNldCB0aGlzIGVudiB2YXIgd2hpY2ggaXMgcmVhZCBieVxuICAgICAgICAvLyBjbGFuZ19zZXJ2ZXIucHkgdG8gZXhwbGljaXRseSBzZXQgdGhlIGZpbGUgcGF0aCB0byBsb2FkLlxuICAgICAgICBMSUJfQ0xBTkdfTElCUkFSWV9GSUxFOiBsaWJDbGFuZ0xpYnJhcnlGaWxlLFxuICAgICAgICBQWVRIT05QQVRIOiBweXRob25QYXRoRW52LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gTm90ZSB0aGF0IHNhZmVTcGF3bigpIG9mdGVuIG92ZXJyaWRlcyBvcHRpb25zLmVudi5QQVRILCBidXQgdGhhdCBvbmx5IGhhcHBlbnMgd2hlblxuICAgIC8vIG9wdGlvbnMuZW52IGlzIHVuZGVmaW5lZCAod2hpY2ggaXMgbm90IHRoZSBjYXNlIGhlcmUpLiBUaGlzIHdpbGwgb25seSBiZSBhbiBpc3N1ZSBpZiB0aGVcbiAgICAvLyBzeXN0ZW0gY2Fubm90IGZpbmQgYHB5dGhvbkV4ZWN1dGFibGVgLlxuICAgIGNvbnN0IGNoaWxkID0gYXdhaXQgc2FmZVNwYXduKHB5dGhvbkV4ZWN1dGFibGUsIC8qIGFyZ3MgKi8gW3BhdGhUb0xpYkNsYW5nU2VydmVyXSwgb3B0aW9ucyk7XG4gICAgY2hpbGQub24oJ2Nsb3NlJywgZnVuY3Rpb24oZXhpdENvZGUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignJXMgZXhpdGVkIHdpdGggY29kZSAlcycsIHBhdGhUb0xpYkNsYW5nU2VydmVyLCBleGl0Q29kZSk7XG4gICAgfSk7XG4gICAgY2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICBlcnJvciA9IGVycm9yLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICB9XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHJlY2VpdmluZyBkYXRhJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8qICRGbG93Rml4TWUgLSB1cGRhdGUgRmxvdyBkZWZzIGZvciBDaGlsZFByb2Nlc3MgKi9cbiAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IGNoaWxkLnN0ZGlvWzNdO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBiaWRpcmVjdGlvbmFsIGNvbW11bmljYXRpb24gY2hhbm5lbCBpcyBzZXQgdXAgYmVmb3JlXG4gICAgLy8gcmVzb2x2aW5nIHRoaXMgUHJvbWlzZS5cbiAgICBjaGlsZC5zdGRvdXQub25jZSgnZGF0YScsIGZ1bmN0aW9uKGRhdGE6IEJ1ZmZlcikge1xuICAgICAgaWYgKGRhdGEudG9TdHJpbmcoKSA9PT0gJ2Fja1xcbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiBjaGlsZC5zdGRvdXQsXG4gICAgICAgICAgd3JpdGFibGVTdHJlYW06IHdyaXRhYmxlU3RyZWFtLFxuICAgICAgICB9O1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd3JpdGFibGVTdHJlYW0ud3JpdGUoJ2luaXRcXG4nKTtcbiAgfSk7XG59XG5cbi8qKlxuICogTnVjbGlkZSBydW5zIGNsYW5nIGluIGl0cyBvd24gcHJvY2Vzcy4gRm9yIHNpbXBsaWNpdHksIGl0IGlzIHJ1biBhcyBhIFB5dGhvblxuICogcHJvZ3JhbSwgYXMgUHl0aG9uIGhhcyBhIG5pY2UgbGliY2xhbmcgd3JhcHBlci5cbiAqL1xuY2xhc3MgTG9jYWxDbGFuZ1NlcnZpY2UgZXh0ZW5kcyBDbGFuZ1NlcnZpY2Uge1xuICBfYXN5bmNDb25uZWN0aW9uOiA/UHJvbWlzZTx2b2lkPjtcbiAgX2NsYW5nRmxhZ3NNYW5hZ2VyOiBDbGFuZ0ZsYWdzTWFuYWdlcjtcbiAgX3JlYWRhYmxlU3RyZWFtOiA/c3RyZWFtJFJlYWRhYmxlO1xuICBfd3JpdGFibGVTdHJlYW06ID9zdHJlYW0kV3JpdGFibGU7XG4gIF9uZXh0UmVxdWVzdElkOiBudW1iZXI7XG4gIF9wYXRoVG9MaWJDbGFuZ1NlcnZlcjogc3RyaW5nO1xuICBfZW1pdHRlcjogRXZlbnRFbWl0dGVyO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYXN5bmNDb25uZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLl9jbGFuZ0ZsYWdzTWFuYWdlciA9IG5ldyBDbGFuZ0ZsYWdzTWFuYWdlcihuZXcgQnVja1V0aWxzKCkpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl93cml0YWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fbmV4dFJlcXVlc3RJZCA9IDE7XG4gICAgdGhpcy5fcGF0aFRvTGliQ2xhbmdTZXJ2ZXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vcHl0aG9uL2NsYW5nX3NlcnZlci5weScpO1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIH1cblxuICBfY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgYXN5bmNDb25uZWN0aW9uID0gdGhpcy5fYXN5bmNDb25uZWN0aW9uO1xuICAgIGlmIChhc3luY0Nvbm5lY3Rpb24gPT0gbnVsbCkge1xuICAgICAgYXN5bmNDb25uZWN0aW9uID0gY3JlYXRlQXN5bmNDb25uZWN0aW9uKHRoaXMuX3BhdGhUb0xpYkNsYW5nU2VydmVyKS50aGVuKFxuICAgICAgICAoY29ubmVjdGlvbjogQ29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHtyZWFkYWJsZVN0cmVhbSwgd3JpdGFibGVTdHJlYW19ID0gY29ubmVjdGlvbjtcbiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RyZWFtID0gd3JpdGFibGVTdHJlYW07XG4gICAgICAgICAgcmVhZGFibGVTdHJlYW0ucGlwZShzcGxpdChKU09OLnBhcnNlKSkub24oJ2RhdGEnLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gcmVzcG9uc2VbJ3JlcWlkJ107XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmVtaXQoaWQsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIC8vIElmIGFuIGVycm9yIG9jY3VycywgY2xlYXIgb3V0IGB0aGlzLl9hc3luY0Nvbm5lY3Rpb25gLCBzbyB0aGF0IGlmIGBfY29ubmVjdCgpYCBpc1xuICAgICAgICAgIC8vIGNhbGxlZCBhZ2Fpbiwgd2UgbWFrZSBhIG5ldyBhdHRlbXB0IHRvIGNyZWF0ZSBhIGNvbm5lY3Rpb24sXG4gICAgICAgICAgLy8gcmF0aGVyIHRoYW4gaG9sZGluZyBvbnRvIGEgcmVqZWN0ZWQgUHJvbWlzZSBpbmRlZmluaXRlbHkuXG4gICAgICAgICAgdGhpcy5fYXN5bmNDb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fYXN5bmNDb25uZWN0aW9uID0gYXN5bmNDb25uZWN0aW9uO1xuICAgIHJldHVybiBhc3luY0Nvbm5lY3Rpb247XG4gIH1cblxuICBhc3luYyBfbWFrZVJlcXVlc3QocmVxdWVzdDogT2JqZWN0KTogUHJvbWlzZSB7XG4gICAgYXdhaXQgdGhpcy5fY29ubmVjdCgpO1xuXG4gICAgY29uc3QgaWQgPSByZXF1ZXN0WydyZXFpZCddID0gdGhpcy5fZ2V0TmV4dFJlcXVlc3RJZCgpO1xuICAgIGNvbnN0IGxvZ0RhdGEgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgLy8gRmlsZSBjb250ZW50cyBhcmUgdG9vIGxhcmdlIGFuZCBjbHV0dGVyIHVwIHRoZSBsb2dzLCBzbyBleGNsdWRlIHRoZW0uXG4gICAgICBpZiAoa2V5ID09PSAnY29udGVudHMnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9nZ2VyLmRlYnVnKCdMaWJDbGFuZyByZXF1ZXN0OiAnICsgbG9nRGF0YSk7XG4gICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSB0aGlzLl93cml0YWJsZVN0cmVhbTtcbiAgICBpZiAod3JpdGFibGVTdHJlYW0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIE5vZGUgdXNlcyBhbiBldmVudC1sb29wLCB3ZSBkbyBub3QgaGF2ZSB0byB3b3JyeSBhYm91dCBhIGNhbGwgdG9cbiAgICAvLyB3cml0ZSgpIGNvbWluZyBpbiBmcm9tIGFub3RoZXIgdGhyZWFkIGJldHdlZW4gb3VyIHR3byBjYWxscyBoZXJlLlxuICAgIHdyaXRhYmxlU3RyZWFtLndyaXRlKEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpKTtcbiAgICB3cml0YWJsZVN0cmVhbS53cml0ZSgnXFxuJyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fZW1pdHRlci5vbmNlKGlkLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNFcnJvciA9ICdlcnJvcicgaW4gcmVzcG9uc2U7XG4gICAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdlcnJvciByZWNlaXZlZCBmcm9tIGNsYW5nX3NlcnZlci5weSBmb3IgcmVxdWVzdDpcXG4lb1xcbkVycm9yOiVzJyxcbiAgICAgICAgICAgIGxvZ0RhdGEsXG4gICAgICAgICAgICByZXNwb25zZVsnZXJyb3InXSk7XG4gICAgICAgIH1cbiAgICAgICAgKGlzRXJyb3IgPyByZWplY3QgOiByZXNvbHZlKShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXROZXh0UmVxdWVzdElkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICh0aGlzLl9uZXh0UmVxdWVzdElkKyspLnRvU3RyaW5nKDE2KTtcbiAgfVxuXG4gIGFzeW5jIGNvbXBpbGUoXG4gICAgc3JjOiBOdWNsaWRlVXJpLFxuICAgIGNvbnRlbnRzOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7XG4gICAgZGlhZ25vc3RpY3M6IEFycmF5PHtcbiAgICAgIHNwZWxsaW5nOiBzdHJpbmc7XG4gICAgICBzZXZlcml0eTogbnVtYmVyO1xuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgY29sdW1uOiBudW1iZXI7XG4gICAgICAgIGZpbGU6IE51Y2xpZGVVcmk7XG4gICAgICAgIGxpbmU6IG51bWJlcjtcbiAgICAgIH07XG4gICAgICByYW5nZXM6IGFueTtcbiAgICB9PlxuICB9PiB7XG4gICAgY29uc3QgZmxhZ3MgPSBhd2FpdCB0aGlzLl9jbGFuZ0ZsYWdzTWFuYWdlci5nZXRGbGFnc0ZvclNyYyhzcmMpO1xuICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdjb21waWxlJyxcbiAgICAgIHNyYyxcbiAgICAgIGNvbnRlbnRzLFxuICAgICAgZmxhZ3MsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZXRDb21wbGV0aW9ucyhzcmM6IE51Y2xpZGVVcmksIGNvbnRlbnRzOiBzdHJpbmcsIGxpbmU6IG51bWJlciwgY29sdW1uOiBudW1iZXIsXG4gICAgICB0b2tlblN0YXJ0Q29sdW1uOiBudW1iZXIsIHByZWZpeDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBmbGFncyA9IGF3YWl0IHRoaXMuX2NsYW5nRmxhZ3NNYW5hZ2VyLmdldEZsYWdzRm9yU3JjKHNyYyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ2dldF9jb21wbGV0aW9ucycsXG4gICAgICBzcmMsXG4gICAgICBjb250ZW50cyxcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW4sXG4gICAgICB0b2tlblN0YXJ0Q29sdW1uLFxuICAgICAgcHJlZml4LFxuICAgICAgZmxhZ3MsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiBBbiBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICogICBmaWxlOiBOdWNsaWRlVXJpIG9mIHRoZSBzb3VyY2UgZmlsZSB3aGVyZSB0aGUgZGVjbGFyYXRpb24gaXMuXG4gICAqICAgbGluZTogVGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBkZWNsYXJhdGlvbiB3aXRoaW4gYGZpbGVgLlxuICAgKiAgIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgb2YgdGhlIGRlY2xhcmF0aW9uIHdpdGhpbiBgZmlsZWAuXG4gICAqICAgc3BlbGxpbmc6IFRoZSBzcGVsbGluZyBvZiB0aGUgZW50aXR5LlxuICAgKi9cbiAgYXN5bmMgZ2V0RGVjbGFyYXRpb24oc3JjOiBOdWNsaWRlVXJpLCBjb250ZW50czogc3RyaW5nLCBsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyXG4gICAgICApOiBQcm9taXNlPD97XG4gICAgICAgICAgZmlsZTogTnVjbGlkZVVyaTtcbiAgICAgICAgICBsaW5lOiBudW1iZXI7XG4gICAgICAgICAgY29sdW1uOiBudW1iZXI7XG4gICAgICAgICAgc3BlbGxpbmc6IHN0cmluZztcbiAgICAgICAgICBleHRlbnQ6IENsYW5nQ3Vyc29yRXh0ZW50O1xuICAgICAgICB9PiB7XG4gICAgY29uc3QgZmxhZ3MgPSBhd2FpdCB0aGlzLl9jbGFuZ0ZsYWdzTWFuYWdlci5nZXRGbGFnc0ZvclNyYyhzcmMpO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9tYWtlUmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdnZXRfZGVjbGFyYXRpb24nLFxuICAgICAgc3JjLFxuICAgICAgY29udGVudHMsXG4gICAgICBsaW5lLFxuICAgICAgY29sdW1uLFxuICAgICAgZmxhZ3MsXG4gICAgfSk7XG5cbiAgICBjb25zdCB7bG9jYXRpb25BbmRTcGVsbGluZ30gPSBkYXRhO1xuXG4gICAgaWYgKCFsb2NhdGlvbkFuZFNwZWxsaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IGZzUHJvbWlzZS5sc3RhdChsb2NhdGlvbkFuZFNwZWxsaW5nLmZpbGUpO1xuICAgIGlmIChzdGF0ZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICBsb2NhdGlvbkFuZFNwZWxsaW5nLmZpbGUgPSBhd2FpdCBmc1Byb21pc2UucmVhZGxpbmsobG9jYXRpb25BbmRTcGVsbGluZy5maWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYXRpb25BbmRTcGVsbGluZztcbiAgfVxuXG4gIGFzeW5jIGdldERlY2xhcmF0aW9uSW5mbyhcbiAgICBzcmM6IE51Y2xpZGVVcmksXG4gICAgY29udGVudHM6IHN0cmluZyxcbiAgICBsaW5lOiBudW1iZXIsXG4gICAgY29sdW1uOiBudW1iZXJcbiAgKTogUHJvbWlzZTw/RGVjbGFyYXRpb25JbmZvPiB7XG4gICAgY29uc3QgZmxhZ3MgPSBhd2FpdCB0aGlzLl9jbGFuZ0ZsYWdzTWFuYWdlci5nZXRGbGFnc0ZvclNyYyhzcmMpO1xuICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdnZXRfZGVjbGFyYXRpb25faW5mbycsXG4gICAgICBzcmMsXG4gICAgICBjb250ZW50cyxcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW4sXG4gICAgICBmbGFncyxcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsQ2xhbmdTZXJ2aWNlO1xuIl19
