Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */
exports['default'] = addPrepareStackTraceHook;
'use babel';

var PREPARE_STACK_TRACE_HOOKED_KEY = '_nuclide_error_stack_trace_hooked';

var hookedPrepareStackTrace = undefined;

/**
 * v8 provided a way to customize Error stacktrace generation by overwriting
 * Error.prepareStackTrace (https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).
 * Here we added a hook to Error.prepareStackTrace to achieve following goals:
 *  1) Whenever `error.stack` is called, error.stackTrace will be generated.
 *  2) Other module's customization to Error.prepareStackTrace, no matter before or after the hook
 *     is added, will still work as expected.
 * In this way, other module could still overwrite Error.prepareStackTrace to customize stacktrace.
 * This is required as Atom's builtin coffeescript package need to show coffeescript stacktrace by
 * customize Error.prepareStackTrace.
 */

function addPrepareStackTraceHook() {
  require('nuclide-commons').singleton.get(PREPARE_STACK_TRACE_HOOKED_KEY, function () {
    hookedPrepareStackTrace = createHookedPrepareStackTrace(Error.prepareStackTrace || defaultPrepareStackTrace);

    // Hook Error.prepareStackTrace by leveraging get/set accessor. In this way, writing to
    // Error.prepareStackTrace will put the new prepareStackTrace functions in a wrapper that
    // calls the hook.
    // $FlowIssue
    Object.defineProperty(Error, 'prepareStackTrace', {
      get: function get() {
        return hookedPrepareStackTrace;
      },
      set: function set(newValue) {
        hookedPrepareStackTrace = createHookedPrepareStackTrace(newValue || defaultPrepareStackTrace);
      },
      enumerable: false,
      configurable: true
    });

    // TODO (chenshen) t8789330.
    // Atom added getRawStack to Error.prototype to get Error's structured stacktrace
    // (https://github.com/atom/grim/blob/master/src/grim.coffee#L43). However, this
    // doesn't work well with our customization of stacktrace. So here we temporarily
    // walk around this by following hack, until https://github.com/atom/atom/issues/9641
    // get addressed.
    /* eslint-disable no-extend-native */
    /* $FlowFixMe */
    Error.prototype.getRawStack = null;
    /* eslint-enable no-extend-native */
    return true;
  });
}

/**
 * Create a wrapper that calls to structuredStackTraceHook first, then return the result of
 * prepareStackTrace.
 */
function createHookedPrepareStackTrace(prepareStackTrace) {
  // If the prepareStackTrace is already been hooked, just return it.
  if (prepareStackTrace.name === 'nuclideHookedPrepareStackTrace') {
    return prepareStackTrace;
  }

  var hookedFunction = function nuclideHookedPrepareStackTrace(error, frames) {
    structuredStackTraceHook(error, frames);
    return prepareStackTrace(error, frames);
  };

  return hookedFunction;
}

function structuredStackTraceHook(error, frames) {
  // $FlowFixMe
  error['stackTrace'] = frames.map(function (frame) {
    return {
      functionName: frame.getFunctionName(),
      methodName: frame.getMethodName(),
      fileName: frame.getFileName(),
      lineNumber: frame.getLineNumber(),
      columnNumber: frame.getColumnNumber(),
      evalOrigin: frame.getEvalOrigin(),
      isTopLevel: frame.isToplevel(),
      isEval: frame.isEval(),
      isNative: frame.isNative(),
      isConstructor: frame.isConstructor()
    };
  });
}

function defaultPrepareStackTrace(error, frames) {
  var formattedStackTrace = error.message ? error.name + ': ' + error.message : '' + error.name;
  frames.forEach(function (frame) {
    formattedStackTrace += '\n    at ' + frame.toString();
  });
  return formattedStackTrace;
}

var __test__ = {
  createHookedPrepareStackTrace: createHookedPrepareStackTrace,
  resetPrepareStackTraceHooked: function resetPrepareStackTraceHooked() {
    require('nuclide-commons').singleton.clear(PREPARE_STACK_TRACE_HOOKED_KEY);
  }
};
exports.__test__ = __test__;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWxvZ2dpbmcvbGliL3N0YWNrdHJhY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7cUJBNkJ3Qix3QkFBd0I7QUE3QmhELFdBQVcsQ0FBQzs7QUFjWixJQUFNLDhCQUE4QixHQUFHLG1DQUFtQyxDQUFDOztBQUUzRSxJQUFJLHVCQUFtRCxZQUFBLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FBYXpDLFNBQVMsd0JBQXdCLEdBQVM7QUFDdkQsU0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FDdEMsOEJBQThCLEVBQzlCLFlBQU07QUFDSiwyQkFBdUIsR0FBRyw2QkFBNkIsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLElBQzFFLHdCQUF3QixDQUFDLENBQUM7Ozs7OztBQU0vQixVQUFNLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxtQkFBbUIsRUFBRTtBQUNoRCxTQUFHLEVBQUEsZUFBRztBQUNKLGVBQU8sdUJBQXVCLENBQUM7T0FDaEM7QUFDRCxTQUFHLEVBQUEsYUFBQyxRQUFRLEVBQUU7QUFDWiwrQkFBdUIsR0FBRyw2QkFBNkIsQ0FBQyxRQUFRLElBQzNELHdCQUF3QixDQUFDLENBQUM7T0FDaEM7QUFDRCxnQkFBVSxFQUFFLEtBQUs7QUFDakIsa0JBQVksRUFBRSxJQUFJO0tBQ25CLENBQUMsQ0FBQzs7Ozs7Ozs7OztBQVVILFNBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzs7QUFFbkMsV0FBTyxJQUFJLENBQUM7R0FDYixDQUNGLENBQUM7Q0FDSDs7Ozs7O0FBTUQsU0FBUyw2QkFBNkIsQ0FDcEMsaUJBQTRDLEVBQ2pCOztBQUUzQixNQUFJLGlCQUFpQixDQUFDLElBQUksS0FBSyxnQ0FBZ0MsRUFBRTtBQUMvRCxXQUFPLGlCQUFpQixDQUFDO0dBQzFCOztBQUVELE1BQU0sY0FBYyxHQUFHLFNBQVMsOEJBQThCLENBQzVELEtBQVksRUFDWixNQUE0QixFQUN2QjtBQUNMLDRCQUF3QixDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN4QyxXQUFPLGlCQUFpQixDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztHQUN6QyxDQUFDOztBQUVGLFNBQU8sY0FBYyxDQUFDO0NBQ3ZCOztBQUVELFNBQVMsd0JBQXdCLENBQUMsS0FBWSxFQUFFLE1BQTRCLEVBQVE7O0FBRWxGLE9BQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQUEsS0FBSyxFQUFJO0FBQ3hDLFdBQU87QUFDTCxrQkFBWSxFQUFFLEtBQUssQ0FBQyxlQUFlLEVBQUU7QUFDckMsZ0JBQVUsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUFFO0FBQ2pDLGNBQVEsRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFO0FBQzdCLGdCQUFVLEVBQUUsS0FBSyxDQUFDLGFBQWEsRUFBRTtBQUNqQyxrQkFBWSxFQUFFLEtBQUssQ0FBQyxlQUFlLEVBQUU7QUFDckMsZ0JBQVUsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUFFO0FBQ2pDLGdCQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVUsRUFBRTtBQUM5QixZQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRTtBQUN0QixjQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsRUFBRTtBQUMxQixtQkFBYSxFQUFFLEtBQUssQ0FBQyxhQUFhLEVBQUU7S0FDckMsQ0FBQztHQUNILENBQUMsQ0FBQztDQUNKOztBQUVELFNBQVMsd0JBQXdCLENBQUMsS0FBWSxFQUFFLE1BQTRCLEVBQVU7QUFDcEYsTUFBSSxtQkFBbUIsR0FBRyxLQUFLLENBQUMsT0FBTyxHQUFNLEtBQUssQ0FBQyxJQUFJLFVBQUssS0FBSyxDQUFDLE9BQU8sUUFBUSxLQUFLLENBQUMsSUFBSSxBQUFFLENBQUM7QUFDOUYsUUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEtBQUssRUFBSTtBQUN0Qix1QkFBbUIsa0JBQWdCLEtBQUssQ0FBQyxRQUFRLEVBQUUsQUFBRSxDQUFDO0dBQ3ZELENBQUMsQ0FBQztBQUNILFNBQU8sbUJBQW1CLENBQUM7Q0FDNUI7O0FBRU0sSUFBTSxRQUFRLEdBQUc7QUFDdEIsK0JBQTZCLEVBQTdCLDZCQUE2QjtBQUM3Qiw4QkFBNEIsRUFBQSx3Q0FBRztBQUM3QixXQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7R0FDNUU7Q0FDRixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBwZmw1Mm5wdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWxvZ2dpbmcvbGliL3N0YWNrdHJhY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IHR5cGUge25vZGUkQ2FsbFNpdGV9IGZyb20gJy4vdHlwZXMnO1xuXG50eXBlIFByZXBhcmVTdGFja1RyYWNlRnVuY3Rpb24gPSAoZXJyb3I6IEVycm9yLCBmcmFtZXM6IEFycmF5PG5vZGUkQ2FsbFNpdGU+KSA9PiBhbnk7XG5cbmNvbnN0IFBSRVBBUkVfU1RBQ0tfVFJBQ0VfSE9PS0VEX0tFWSA9ICdfbnVjbGlkZV9lcnJvcl9zdGFja190cmFjZV9ob29rZWQnO1xuXG5sZXQgaG9va2VkUHJlcGFyZVN0YWNrVHJhY2U6ID9QcmVwYXJlU3RhY2tUcmFjZUZ1bmN0aW9uO1xuXG4vKipcbiAqIHY4IHByb3ZpZGVkIGEgd2F5IHRvIGN1c3RvbWl6ZSBFcnJvciBzdGFja3RyYWNlIGdlbmVyYXRpb24gYnkgb3ZlcndyaXRpbmdcbiAqIEVycm9yLnByZXBhcmVTdGFja1RyYWNlIChodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGkpLlxuICogSGVyZSB3ZSBhZGRlZCBhIGhvb2sgdG8gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgdG8gYWNoaWV2ZSBmb2xsb3dpbmcgZ29hbHM6XG4gKiAgMSkgV2hlbmV2ZXIgYGVycm9yLnN0YWNrYCBpcyBjYWxsZWQsIGVycm9yLnN0YWNrVHJhY2Ugd2lsbCBiZSBnZW5lcmF0ZWQuXG4gKiAgMikgT3RoZXIgbW9kdWxlJ3MgY3VzdG9taXphdGlvbiB0byBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSwgbm8gbWF0dGVyIGJlZm9yZSBvciBhZnRlciB0aGUgaG9va1xuICogICAgIGlzIGFkZGVkLCB3aWxsIHN0aWxsIHdvcmsgYXMgZXhwZWN0ZWQuXG4gKiBJbiB0aGlzIHdheSwgb3RoZXIgbW9kdWxlIGNvdWxkIHN0aWxsIG92ZXJ3cml0ZSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSB0byBjdXN0b21pemUgc3RhY2t0cmFjZS5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYXMgQXRvbSdzIGJ1aWx0aW4gY29mZmVlc2NyaXB0IHBhY2thZ2UgbmVlZCB0byBzaG93IGNvZmZlZXNjcmlwdCBzdGFja3RyYWNlIGJ5XG4gKiBjdXN0b21pemUgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZFByZXBhcmVTdGFja1RyYWNlSG9vaygpOiB2b2lkIHtcbiAgcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJykuc2luZ2xldG9uLmdldChcbiAgICBQUkVQQVJFX1NUQUNLX1RSQUNFX0hPT0tFRF9LRVksXG4gICAgKCkgPT4ge1xuICAgICAgaG9va2VkUHJlcGFyZVN0YWNrVHJhY2UgPSBjcmVhdGVIb29rZWRQcmVwYXJlU3RhY2tUcmFjZShFcnJvci5wcmVwYXJlU3RhY2tUcmFjZVxuICAgICAgICB8fCBkZWZhdWx0UHJlcGFyZVN0YWNrVHJhY2UpO1xuXG4gICAgICAvLyBIb29rIEVycm9yLnByZXBhcmVTdGFja1RyYWNlIGJ5IGxldmVyYWdpbmcgZ2V0L3NldCBhY2Nlc3Nvci4gSW4gdGhpcyB3YXksIHdyaXRpbmcgdG9cbiAgICAgIC8vIEVycm9yLnByZXBhcmVTdGFja1RyYWNlIHdpbGwgcHV0IHRoZSBuZXcgcHJlcGFyZVN0YWNrVHJhY2UgZnVuY3Rpb25zIGluIGEgd3JhcHBlciB0aGF0XG4gICAgICAvLyBjYWxscyB0aGUgaG9vay5cbiAgICAgIC8vICRGbG93SXNzdWVcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvciwgJ3ByZXBhcmVTdGFja1RyYWNlJywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2tlZFByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICBob29rZWRQcmVwYXJlU3RhY2tUcmFjZSA9IGNyZWF0ZUhvb2tlZFByZXBhcmVTdGFja1RyYWNlKG5ld1ZhbHVlXG4gICAgICAgICAgICB8fCBkZWZhdWx0UHJlcGFyZVN0YWNrVHJhY2UpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE8gKGNoZW5zaGVuKSB0ODc4OTMzMC5cbiAgICAgIC8vIEF0b20gYWRkZWQgZ2V0UmF3U3RhY2sgdG8gRXJyb3IucHJvdG90eXBlIHRvIGdldCBFcnJvcidzIHN0cnVjdHVyZWQgc3RhY2t0cmFjZVxuICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9tL2dyaW0vYmxvYi9tYXN0ZXIvc3JjL2dyaW0uY29mZmVlI0w0MykuIEhvd2V2ZXIsIHRoaXNcbiAgICAgIC8vIGRvZXNuJ3Qgd29yayB3ZWxsIHdpdGggb3VyIGN1c3RvbWl6YXRpb24gb2Ygc3RhY2t0cmFjZS4gU28gaGVyZSB3ZSB0ZW1wb3JhcmlseVxuICAgICAgLy8gd2FsayBhcm91bmQgdGhpcyBieSBmb2xsb3dpbmcgaGFjaywgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL2F0b20vYXRvbS9pc3N1ZXMvOTY0MVxuICAgICAgLy8gZ2V0IGFkZHJlc3NlZC5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbiAgICAgIC8qICRGbG93Rml4TWUgKi9cbiAgICAgIEVycm9yLnByb3RvdHlwZS5nZXRSYXdTdGFjayA9IG51bGw7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgd3JhcHBlciB0aGF0IGNhbGxzIHRvIHN0cnVjdHVyZWRTdGFja1RyYWNlSG9vayBmaXJzdCwgdGhlbiByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICogcHJlcGFyZVN0YWNrVHJhY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhvb2tlZFByZXBhcmVTdGFja1RyYWNlKFxuICBwcmVwYXJlU3RhY2tUcmFjZTogUHJlcGFyZVN0YWNrVHJhY2VGdW5jdGlvbixcbik6IFByZXBhcmVTdGFja1RyYWNlRnVuY3Rpb24ge1xuICAvLyBJZiB0aGUgcHJlcGFyZVN0YWNrVHJhY2UgaXMgYWxyZWFkeSBiZWVuIGhvb2tlZCwganVzdCByZXR1cm4gaXQuXG4gIGlmIChwcmVwYXJlU3RhY2tUcmFjZS5uYW1lID09PSAnbnVjbGlkZUhvb2tlZFByZXBhcmVTdGFja1RyYWNlJykge1xuICAgIHJldHVybiBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgfVxuXG4gIGNvbnN0IGhvb2tlZEZ1bmN0aW9uID0gZnVuY3Rpb24gbnVjbGlkZUhvb2tlZFByZXBhcmVTdGFja1RyYWNlKFxuICAgIGVycm9yOiBFcnJvcixcbiAgICBmcmFtZXM6IEFycmF5PG5vZGUkQ2FsbFNpdGU+LFxuICApOiBhbnkge1xuICAgIHN0cnVjdHVyZWRTdGFja1RyYWNlSG9vayhlcnJvciwgZnJhbWVzKTtcbiAgICByZXR1cm4gcHJlcGFyZVN0YWNrVHJhY2UoZXJyb3IsIGZyYW1lcyk7XG4gIH07XG5cbiAgcmV0dXJuIGhvb2tlZEZ1bmN0aW9uO1xufVxuXG5mdW5jdGlvbiBzdHJ1Y3R1cmVkU3RhY2tUcmFjZUhvb2soZXJyb3I6IEVycm9yLCBmcmFtZXM6IEFycmF5PG5vZGUkQ2FsbFNpdGU+KTogdm9pZCB7XG4gIC8vICRGbG93Rml4TWVcbiAgZXJyb3JbJ3N0YWNrVHJhY2UnXSA9IGZyYW1lcy5tYXAoZnJhbWUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmdW5jdGlvbk5hbWU6IGZyYW1lLmdldEZ1bmN0aW9uTmFtZSgpLFxuICAgICAgbWV0aG9kTmFtZTogZnJhbWUuZ2V0TWV0aG9kTmFtZSgpLFxuICAgICAgZmlsZU5hbWU6IGZyYW1lLmdldEZpbGVOYW1lKCksXG4gICAgICBsaW5lTnVtYmVyOiBmcmFtZS5nZXRMaW5lTnVtYmVyKCksXG4gICAgICBjb2x1bW5OdW1iZXI6IGZyYW1lLmdldENvbHVtbk51bWJlcigpLFxuICAgICAgZXZhbE9yaWdpbjogZnJhbWUuZ2V0RXZhbE9yaWdpbigpLFxuICAgICAgaXNUb3BMZXZlbDogZnJhbWUuaXNUb3BsZXZlbCgpLFxuICAgICAgaXNFdmFsOiBmcmFtZS5pc0V2YWwoKSxcbiAgICAgIGlzTmF0aXZlOiBmcmFtZS5pc05hdGl2ZSgpLFxuICAgICAgaXNDb25zdHJ1Y3RvcjogZnJhbWUuaXNDb25zdHJ1Y3RvcigpLFxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlcGFyZVN0YWNrVHJhY2UoZXJyb3I6IEVycm9yLCBmcmFtZXM6IEFycmF5PG5vZGUkQ2FsbFNpdGU+KTogc3RyaW5nIHtcbiAgbGV0IGZvcm1hdHRlZFN0YWNrVHJhY2UgPSBlcnJvci5tZXNzYWdlID8gYCR7ZXJyb3IubmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gIDogYCR7ZXJyb3IubmFtZX1gO1xuICBmcmFtZXMuZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgZm9ybWF0dGVkU3RhY2tUcmFjZSArPSBgXFxuICAgIGF0ICR7ZnJhbWUudG9TdHJpbmcoKX1gO1xuICB9KTtcbiAgcmV0dXJuIGZvcm1hdHRlZFN0YWNrVHJhY2U7XG59XG5cbmV4cG9ydCBjb25zdCBfX3Rlc3RfXyA9IHtcbiAgY3JlYXRlSG9va2VkUHJlcGFyZVN0YWNrVHJhY2UsXG4gIHJlc2V0UHJlcGFyZVN0YWNrVHJhY2VIb29rZWQoKSB7XG4gICAgcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJykuc2luZ2xldG9uLmNsZWFyKFBSRVBBUkVfU1RBQ0tfVFJBQ0VfSE9PS0VEX0tFWSk7XG4gIH0sXG59O1xuIl19
